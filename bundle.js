/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _framework = __webpack_require__(1);
	
	var _framework2 = _interopRequireDefault(_framework);
	
	var _world = __webpack_require__(9);
	
	var _world2 = _interopRequireDefault(_world);
	
	var _basicWorld = __webpack_require__(12);
	
	var _basicWorld2 = _interopRequireDefault(_basicWorld);
	
	var _cameraControls = __webpack_require__(18);
	
	var _cameraControls2 = _interopRequireDefault(_cameraControls);
	
	var _flowerWorld = __webpack_require__(19);
	
	var _flowerWorld2 = _interopRequireDefault(_flowerWorld);
	
	var _waterWorld = __webpack_require__(21);
	
	var _waterWorld2 = _interopRequireDefault(_waterWorld);
	
	var _crystalWorld = __webpack_require__(31);
	
	var _crystalWorld2 = _interopRequireDefault(_crystalWorld);
	
	var _galaxybackground = __webpack_require__(37);
	
	var _galaxybackground2 = _interopRequireDefault(_galaxybackground);
	
	var _verticalRoll = __webpack_require__(40);
	
	var _verticalRoll2 = _interopRequireDefault(_verticalRoll);
	
	var _rgbShift = __webpack_require__(49);
	
	var _rgbShift2 = _interopRequireDefault(_rgbShift);
	
	var _dots = __webpack_require__(51);
	
	var _dots2 = _interopRequireDefault(_dots);
	
	var _dotsbw = __webpack_require__(53);
	
	var _dotsbw2 = _interopRequireDefault(_dotsbw);
	
	var _saturate = __webpack_require__(55);
	
	var _saturate2 = _interopRequireDefault(_saturate);
	
	var _retro = __webpack_require__(57);
	
	var _retro2 = _interopRequireDefault(_retro);
	
	var _audio = __webpack_require__(59);
	
	var _audio2 = _interopRequireDefault(_audio);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var THREE = __webpack_require__(6); // older modules are imported like this. You shouldn't have to worry about this much
	var EffectComposer = __webpack_require__(41)(THREE);
	
	
	// initialize global clock
	var clock = new THREE.Clock(false);
	var cameraControls;
	
	var koiGeo;
	
	// worlds
	var flowerWorld;
	var waterWorld;
	var crystalWorld;
	var currentWorld;
	var galaxy;
	
	// scene nodes
	var scene;
	var camera;
	var renderer;
	var directionalLight;
	var composer;
	
	// Post-processing shaders
	var allPost = [_verticalRoll2.default, _rgbShift2.default, _dots2.default, _dotsbw2.default, _saturate2.default, _retro2.default];
	var currentPost = [];
	
	var humble = "./audio/humble.mp3";
	var wildcat = "./audio/wildcat.mp3";
	var flowers = "./audio/the-deli-flowers.mp3";
	var ysl = "./audio/ysl-bengfang.mp3";
	
	var zoomIn;
	var zoomOut;
	
	var music = {
	  humble: 1,
	  wildcat: 2,
	  flowers: 3,
	  ysl: 4
	};
	
	var song = music.wildcat;
	
	var audioControl = { 'mute': false, 'music': 'wildcat' };
	var planetControl = { 'planet': 'flower' };
	
	var cameraOffset = 20;
	// called after the scene loads
	function onLoad(framework) {
	
	  // initialize framework
	  scene = framework.scene;
	  camera = framework.camera;
	  renderer = framework.renderer;
	  var gui = framework.gui;
	  var stats = framework.stats;
	
	  // initialize a simple box and material
	  directionalLight = new THREE.DirectionalLight(0xffffff, 1);
	  directionalLight.color.setHSL(0.1, 1, 0.95);
	  directionalLight.position.set(1, 5, 2);
	  directionalLight.position.multiplyScalar(10);
	
	  scene.add(directionalLight);
	
	  var backLight = new THREE.DirectionalLight(0xffffff, 1);
	  backLight.color.setHSL(0.1, 1, 0.95);
	  backLight.position.set(1, 1, -2);
	  backLight.position.multiplyScalar(10);
	
	  scene.add(backLight);
	
	  // set camera position
	  camera.position.set(0, 0, -10);
	  camera.lookAt(new THREE.Vector3(0, 0, camera.position.z - 20));
	  camera.updateProjectionMatrix();
	
	  cameraControls = new _cameraControls2.default(scene, clock, camera);
	
	  // putting in a simple axis helper to help visualize
	  // var axisHelper = new THREE.AxisHelper( 10 );
	  // scene.add( axisHelper );
	
	  var objLoader = new THREE.OBJLoader();
	
	  // audio
	  objLoader.load('textures/koi2.obj', function (obj) {
	    koiGeo = obj.children[0].geometry;
	    var path;
	    switch (song) {
	      case music.humble:
	        path = humble;
	        break;
	      case music.wildcat:
	        path = wildcat;
	        break;
	      case music.flowers:
	        path = flowers;
	        break;
	    }
	    _audio2.default.init(path, initWorlds);
	  });
	
	  currentPost = [];
	  setPostProcessing();
	
	  // load in background planets
	  galaxy = new _galaxybackground2.default(scene, clock, directionalLight);
	  galaxy.initializeBackground();
	
	  gui.add(audioControl, 'music', ['humble', 'wildcat', 'the-deli-flowers', 'ysl-bengfang', 'dont-want-to-leave', 'american-boy']).onChange(function (newVal) {
	    _audio2.default.setMusic(newVal, resetAnalysers);
	    if (audioControl.mute) _audio2.default.mute();
	    switch (newVal) {
	      case 'humble':
	        currentPost = [_verticalRoll2.default];break;
	      case 'ysl-bengfang':
	        currentPost = [_rgbShift2.default];break;
	      case 'the-deli-flowers':
	        currentPost = [_dots2.default];break;
	      case 'dont-want-to-leave':
	        currentPost = [_retro2.default];break;
	      case 'american-boy':
	        currentPost = [_dotsbw2.default];break;
	      default:
	        currentPost = [];
	    }
	    setPostProcessing();
	  });
	
	  gui.add(audioControl, 'mute').onChange(function (newVal) {
	    if (newVal) {
	      _audio2.default.mute();
	    } else {
	      _audio2.default.unmute();
	    }
	  });
	
	  gui.add(planetControl, 'planet', ['flower', 'water', 'crystal']).onChange(function (newVal) {
	    currentWorld.toggleDisplay(false);
	    if (newVal == 'flower') {
	      currentWorld = flowerWorld;
	    } else if (newVal == 'water') {
	      currentWorld = waterWorld;
	    } else if (newVal == 'crystal') {
	      currentWorld = crystalWorld;
	    }
	    currentWorld.toggleDisplay(true);
	  });
	}
	
	// Note: Currently can only have 1 shader pass at time.
	// TODO: Get multiple passes to work
	function setPostProcessing(shaders) {
	  for (var s in allPost) {
	    allPost[s].turnOff();
	  }
	  composer = new EffectComposer(renderer);
	  var renderPass = new EffectComposer.RenderPass(scene, camera);
	  composer.addPass(renderPass);
	  for (var s in currentPost) {
	    currentPost[s].turnOn();
	    var pass = currentPost[s].shader;
	    pass.renderToScreen = true;
	    composer.addPass(pass);
	  }
	  render();
	}
	
	function render() {
	  composer.render();
	  requestAnimationFrame(render);
	}
	
	function initWorlds() {
	  crystalWorld = new _crystalWorld2.default(scene, camera, clock, directionalLight, new THREE.Vector3(0, 0, 0));
	  crystalWorld.analyser = _audio2.default.getAnalyser();
	
	  flowerWorld = new _flowerWorld2.default(scene, clock, directionalLight, new THREE.Vector3(0, 0, 0));
	  flowerWorld.analyser = _audio2.default.getAnalyser();
	
	  waterWorld = new _waterWorld2.default(scene, clock, directionalLight, koiGeo, new THREE.Vector3(0, 0, 0));
	  waterWorld.analyser = _audio2.default.getAnalyser();
	
	  currentWorld = flowerWorld;
	  currentWorld.toggleDisplay(true);
	
	  setWorldSpeeds();
	  if (audioControl.mute) _audio2.default.mute();
	  _audio2.default.playSound();
	  clock.start();
	}
	
	function setWorldSpeeds() {
	  var speed = _audio2.default.getRateFromSound() / 8000;
	  flowerWorld.rotateSpeed = speed;
	  waterWorld.rotateSpeed = speed;
	  crystalWorld.rotateSpeed = speed;
	}
	
	function resetAnalysers() {
	  crystalWorld.analyser = _audio2.default.getAnalyser();
	  flowerWorld.analyser = _audio2.default.getAnalyser();
	  waterWorld.analyser = _audio2.default.getAnalyser();
	  setWorldSpeeds();
	}
	
	function timeTarget(time) {
	  var epsilon = 0.1;
	  return Math.abs(clock.elapsedTime - time) < epsilon;
	}
	
	var FLOWER_ZOOMOUT = 0;
	var FLOWER_ZOOMOUT_END = FLOWER_ZOOMOUT + 5;
	
	var FLOWER_ZOOMIN = FLOWER_ZOOMOUT_END + 20;
	var FLOWER_ZOOMIN_END = FLOWER_ZOOMIN + 2;
	
	var CRYSTAL_ZOOMOUT = FLOWER_ZOOMIN_END;
	var CRYSTAL_ZOOMOUT_END = CRYSTAL_ZOOMOUT + 2.5;
	
	var CRYSTAL_EXPLODE = CRYSTAL_ZOOMOUT_END + 10;
	var CRYSTAL_EXPLODE_END = CRYSTAL_EXPLODE + 1;
	
	var CRYSTAL_ZOOM = CRYSTAL_EXPLODE_END;
	var CRYSTAL_ZOOM_END = CRYSTAL_ZOOM + 4;
	
	var WATER_ZOOMOUT = CRYSTAL_ZOOM_END;
	var WATER_ZOOMOUT_END = WATER_ZOOMOUT + 4;
	
	function choreo() {
	  if (cameraControls) {
	    cameraControls.zoom(FLOWER_ZOOMOUT, FLOWER_ZOOMOUT_END, -10, 20);
	    cameraControls.zoom(FLOWER_ZOOMIN, FLOWER_ZOOMIN_END, 20, -10);
	
	    if (timeTarget(1)) {
	      setWorldSpeeds();
	    }
	
	    if (timeTarget(CRYSTAL_ZOOMOUT)) {
	      currentWorld.toggleDisplay(false);
	      currentWorld.normalOffset = -1;
	      currentWorld = crystalWorld;
	      var oldSpeed = currentWorld.rotateSpeed;
	      currentWorld.toggleDisplay(true);
	      currentWorld.rotateSpeed = oldSpeed;
	      setWorldSpeeds();
	    }
	
	    var zooming = cameraControls.zoom(CRYSTAL_ZOOMOUT, CRYSTAL_ZOOMOUT_END, -10, 20);
	
	    if (clock.elapsedTime > CRYSTAL_EXPLODE && clock.elapsedTime < CRYSTAL_EXPLODE_END) {
	      currentWorld.normalOffset += 2;
	    }
	
	    if (clock.elapsedTime > CRYSTAL_ZOOM && clock.elapsedTime < CRYSTAL_ZOOM_END) {
	      cameraControls.zoom(CRYSTAL_ZOOM, CRYSTAL_ZOOM_END, 20, -10);
	      currentWorld.rotateSpeed += Math.PI / 800;
	    }
	
	    if (timeTarget(WATER_ZOOMOUT)) {
	      currentWorld.toggleDisplay(false);
	      currentWorld.normalOffset = -1;
	      currentWorld.rotateSpeed = Math.PI / 200;
	      currentWorld = waterWorld;
	      currentWorld.toggleDisplay(true);
	      setWorldSpeeds();
	    }
	
	    cameraControls.zoom(WATER_ZOOMOUT, WATER_ZOOMOUT_END, -10, 20);
	
	    if (!zooming && currentWorld) {
	      currentWorld.tick();
	    }
	  }
	}
	
	// called on frame updates
	function onUpdate(framework) {
	  if (clock) clock.getDelta();
	  if (crystalWorld && flowerWorld && waterWorld) choreo();
	
	  if (_audio2.default.isPlaying()) {
	    // Change the background color
	    var bg = scene.background ? scene.background : new THREE.Color(0, 0, 0);
	    var color = _audio2.default.getColorFromSound(bg);
	    scene.background = color;
	
	    var size = _audio2.default.getSizeFromSound();
	    var speed = _audio2.default.getRateFromSound();
	
	    if (_verticalRoll2.default.isOn()) {
	      var unif = _verticalRoll2.default.shader.material.uniforms;
	      unif.distortion.value = size / 35;
	      unif.distortion2.value = size / 25;
	      unif.speed.value = speed / 200;
	      unif.rollSpeed.value = speed / 1000;
	      unif.time.value = clock.elapsedTime;
	    }
	    if (_rgbShift2.default.isOn()) {
	      _rgbShift2.default.shader.material.uniforms.aberration.value = size / 5000;
	    }
	    if (_dots2.default.isOn()) {
	      _dots2.default.shader.material.uniforms.scale.value = size / 100;
	    }
	    if (_dotsbw2.default.isOn()) {
	      _dotsbw2.default.shader.material.uniforms.scale.value = size / 100;
	    }
	    if (_retro2.default.isOn()) {
	      _retro2.default.shader.material.uniforms.warmth.value = color.r;
	      _retro2.default.shader.material.uniforms.time.value = clock.elapsedTime;
	      _retro2.default.shader.material.uniforms.size.value = size;
	    }
	  }
	
	  if (galaxy) galaxy.tick();
	}
	
	// when the scene is done initializing, it will call onLoad, then on frame updates, call onUpdate
	_framework2.default.init(onLoad, onUpdate);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _statsJs = __webpack_require__(2);
	
	var _statsJs2 = _interopRequireDefault(_statsJs);
	
	var _datGui = __webpack_require__(3);
	
	var _datGui2 = _interopRequireDefault(_datGui);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var THREE = __webpack_require__(6);
	var OBJLoader = __webpack_require__(7)(THREE);
	var OrbitControls = __webpack_require__(8)(THREE);
	
	// when the scene is done initializing, the function passed as `callback` will be executed
	// then, every frame, the function passed as `update` will be executed
	function init(callback, update) {
	  var stats = new _statsJs2.default();
	  stats.setMode(1);
	  stats.domElement.style.position = 'absolute';
	  stats.domElement.style.left = '0px';
	  stats.domElement.style.top = '0px';
	  document.body.appendChild(stats.domElement);
	
	  var gui = new _datGui2.default.GUI();
	
	  var framework = {
	    gui: gui,
	    stats: stats
	  };
	
	  // run this function after the window loads
	  window.addEventListener('load', function () {
	
	    var scene = new THREE.Scene();
	    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
	    var renderer = new THREE.WebGLRenderer({ antialias: true });
	    renderer.setPixelRatio(window.devicePixelRatio);
	    renderer.setSize(window.innerWidth, window.innerHeight);
	    renderer.setClearColor(0x000000, 1);
	
	    var controls = new OrbitControls(camera, renderer.domElement);
	    controls.enableDamping = true;
	    controls.enableZoom = true;
	    controls.target.set(0, 0, 0);
	    controls.rotateSpeed = 0.3;
	    controls.zoomSpeed = 1.0;
	    controls.panSpeed = 2.0;
	
	    document.body.appendChild(renderer.domElement);
	
	    // resize the canvas when the window changes
	    window.addEventListener('resize', function () {
	      camera.aspect = window.innerWidth / window.innerHeight;
	      camera.updateProjectionMatrix();
	      renderer.setSize(window.innerWidth, window.innerHeight);
	    }, false);
	
	    // assign THREE.js objects to the object we will return
	    framework.scene = scene;
	    framework.camera = camera;
	    framework.renderer = renderer;
	
	    // begin the animation loop
	    (function tick() {
	      stats.begin();
	      update(framework); // perform any requested updates
	      renderer.render(scene, camera); // render the scene
	      stats.end();
	      requestAnimationFrame(tick); // register to call this again when the browser renders a new frame
	    })();
	
	    // we will pass the scene, gui, renderer, camera, etc... to the callback function
	    return callback(framework);
	  });
	}
	
	exports.default = {
	  init: init
	};

/***/ },
/* 2 */
/***/ function(module, exports) {

	// stats.js - http://github.com/mrdoob/stats.js
	var Stats=function(){var l=Date.now(),m=l,g=0,n=Infinity,o=0,h=0,p=Infinity,q=0,r=0,s=0,f=document.createElement("div");f.id="stats";f.addEventListener("mousedown",function(b){b.preventDefault();t(++s%2)},!1);f.style.cssText="width:80px;opacity:0.9;cursor:pointer";var a=document.createElement("div");a.id="fps";a.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#002";f.appendChild(a);var i=document.createElement("div");i.id="fpsText";i.style.cssText="color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
	i.innerHTML="FPS";a.appendChild(i);var c=document.createElement("div");c.id="fpsGraph";c.style.cssText="position:relative;width:74px;height:30px;background-color:#0ff";for(a.appendChild(c);74>c.children.length;){var j=document.createElement("span");j.style.cssText="width:1px;height:30px;float:left;background-color:#113";c.appendChild(j)}var d=document.createElement("div");d.id="ms";d.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";f.appendChild(d);var k=document.createElement("div");
	k.id="msText";k.style.cssText="color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";k.innerHTML="MS";d.appendChild(k);var e=document.createElement("div");e.id="msGraph";e.style.cssText="position:relative;width:74px;height:30px;background-color:#0f0";for(d.appendChild(e);74>e.children.length;)j=document.createElement("span"),j.style.cssText="width:1px;height:30px;float:left;background-color:#131",e.appendChild(j);var t=function(b){s=b;switch(s){case 0:a.style.display=
	"block";d.style.display="none";break;case 1:a.style.display="none",d.style.display="block"}};return{REVISION:12,domElement:f,setMode:t,begin:function(){l=Date.now()},end:function(){var b=Date.now();g=b-l;n=Math.min(n,g);o=Math.max(o,g);k.textContent=g+" MS ("+n+"-"+o+")";var a=Math.min(30,30-30*(g/200));e.appendChild(e.firstChild).style.height=a+"px";r++;b>m+1E3&&(h=Math.round(1E3*r/(b-m)),p=Math.min(p,h),q=Math.max(q,h),i.textContent=h+" FPS ("+p+"-"+q+")",a=Math.min(30,30-30*(h/100)),c.appendChild(c.firstChild).style.height=
	a+"px",m=b,r=0);return b},update:function(){l=this.end()}}};"object"===typeof module&&(module.exports=Stats);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4)
	module.exports.color = __webpack_require__(5)

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * dat-gui JavaScript Controller Library
	 * http://code.google.com/p/dat-gui
	 *
	 * Copyright 2011 Data Arts Team, Google Creative Lab
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */
	
	/** @namespace */
	var dat = module.exports = dat || {};
	
	/** @namespace */
	dat.gui = dat.gui || {};
	
	/** @namespace */
	dat.utils = dat.utils || {};
	
	/** @namespace */
	dat.controllers = dat.controllers || {};
	
	/** @namespace */
	dat.dom = dat.dom || {};
	
	/** @namespace */
	dat.color = dat.color || {};
	
	dat.utils.css = (function () {
	  return {
	    load: function (url, doc) {
	      doc = doc || document;
	      var link = doc.createElement('link');
	      link.type = 'text/css';
	      link.rel = 'stylesheet';
	      link.href = url;
	      doc.getElementsByTagName('head')[0].appendChild(link);
	    },
	    inject: function(css, doc) {
	      doc = doc || document;
	      var injected = document.createElement('style');
	      injected.type = 'text/css';
	      injected.innerHTML = css;
	      doc.getElementsByTagName('head')[0].appendChild(injected);
	    }
	  }
	})();
	
	
	dat.utils.common = (function () {
	  
	  var ARR_EACH = Array.prototype.forEach;
	  var ARR_SLICE = Array.prototype.slice;
	
	  /**
	   * Band-aid methods for things that should be a lot easier in JavaScript.
	   * Implementation and structure inspired by underscore.js
	   * http://documentcloud.github.com/underscore/
	   */
	
	  return { 
	    
	    BREAK: {},
	  
	    extend: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (!this.isUndefined(obj[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	      
	    },
	    
	    defaults: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (this.isUndefined(target[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	    
	    },
	    
	    compose: function() {
	      var toCall = ARR_SLICE.call(arguments);
	            return function() {
	              var args = ARR_SLICE.call(arguments);
	              for (var i = toCall.length -1; i >= 0; i--) {
	                args = [toCall[i].apply(this, args)];
	              }
	              return args[0];
	            }
	    },
	    
	    each: function(obj, itr, scope) {
	
	      
	      if (ARR_EACH && obj.forEach === ARR_EACH) { 
	        
	        obj.forEach(itr, scope);
	        
	      } else if (obj.length === obj.length + 0) { // Is number but not NaN
	        
	        for (var key = 0, l = obj.length; key < l; key++)
	          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
	            return;
	            
	      } else {
	
	        for (var key in obj) 
	          if (itr.call(scope, obj[key], key) === this.BREAK)
	            return;
	            
	      }
	            
	    },
	    
	    defer: function(fnc) {
	      setTimeout(fnc, 0);
	    },
	    
	    toArray: function(obj) {
	      if (obj.toArray) return obj.toArray();
	      return ARR_SLICE.call(obj);
	    },
	
	    isUndefined: function(obj) {
	      return obj === undefined;
	    },
	    
	    isNull: function(obj) {
	      return obj === null;
	    },
	    
	    isNaN: function(obj) {
	      return obj !== obj;
	    },
	    
	    isArray: Array.isArray || function(obj) {
	      return obj.constructor === Array;
	    },
	    
	    isObject: function(obj) {
	      return obj === Object(obj);
	    },
	    
	    isNumber: function(obj) {
	      return obj === obj+0;
	    },
	    
	    isString: function(obj) {
	      return obj === obj+'';
	    },
	    
	    isBoolean: function(obj) {
	      return obj === false || obj === true;
	    },
	    
	    isFunction: function(obj) {
	      return Object.prototype.toString.call(obj) === '[object Function]';
	    }
	  
	  };
	    
	})();
	
	
	dat.controllers.Controller = (function (common) {
	
	  /**
	   * @class An "abstract" class that represents a given property of an object.
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var Controller = function(object, property) {
	
	    this.initialValue = object[property];
	
	    /**
	     * Those who extend this class will put their DOM elements in here.
	     * @type {DOMElement}
	     */
	    this.domElement = document.createElement('div');
	
	    /**
	     * The object to manipulate
	     * @type {Object}
	     */
	    this.object = object;
	
	    /**
	     * The name of the property to manipulate
	     * @type {String}
	     */
	    this.property = property;
	
	    /**
	     * The function to be called on change.
	     * @type {Function}
	     * @ignore
	     */
	    this.__onChange = undefined;
	
	    /**
	     * The function to be called on finishing change.
	     * @type {Function}
	     * @ignore
	     */
	    this.__onFinishChange = undefined;
	
	  };
	
	  common.extend(
	
	      Controller.prototype,
	
	      /** @lends dat.controllers.Controller.prototype */
	      {
	
	        /**
	         * Specify that a function fire every time someone changes the value with
	         * this Controller.
	         *
	         * @param {Function} fnc This function will be called whenever the value
	         * is modified via this Controller.
	         * @returns {dat.controllers.Controller} this
	         */
	        onChange: function(fnc) {
	          this.__onChange = fnc;
	          return this;
	        },
	
	        /**
	         * Specify that a function fire every time someone "finishes" changing
	         * the value wih this Controller. Useful for values that change
	         * incrementally like numbers or strings.
	         *
	         * @param {Function} fnc This function will be called whenever
	         * someone "finishes" changing the value via this Controller.
	         * @returns {dat.controllers.Controller} this
	         */
	        onFinishChange: function(fnc) {
	          this.__onFinishChange = fnc;
	          return this;
	        },
	
	        /**
	         * Change the value of <code>object[property]</code>
	         *
	         * @param {Object} newValue The new value of <code>object[property]</code>
	         */
	        setValue: function(newValue) {
	          this.object[this.property] = newValue;
	          if (this.__onChange) {
	            this.__onChange.call(this, newValue);
	          }
	          this.updateDisplay();
	          return this;
	        },
	
	        /**
	         * Gets the value of <code>object[property]</code>
	         *
	         * @returns {Object} The current value of <code>object[property]</code>
	         */
	        getValue: function() {
	          return this.object[this.property];
	        },
	
	        /**
	         * Refreshes the visual display of a Controller in order to keep sync
	         * with the object's current value.
	         * @returns {dat.controllers.Controller} this
	         */
	        updateDisplay: function() {
	          return this;
	        },
	
	        /**
	         * @returns {Boolean} true if the value has deviated from initialValue
	         */
	        isModified: function() {
	          return this.initialValue !== this.getValue()
	        }
	
	      }
	
	  );
	
	  return Controller;
	
	
	})(dat.utils.common);
	
	
	dat.dom.dom = (function (common) {
	
	  var EVENT_MAP = {
	    'HTMLEvents': ['change'],
	    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
	    'KeyboardEvents': ['keydown']
	  };
	
	  var EVENT_MAP_INV = {};
	  common.each(EVENT_MAP, function(v, k) {
	    common.each(v, function(e) {
	      EVENT_MAP_INV[e] = k;
	    });
	  });
	
	  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
	
	  function cssValueToPixels(val) {
	
	    if (val === '0' || common.isUndefined(val)) return 0;
	
	    var match = val.match(CSS_VALUE_PIXELS);
	
	    if (!common.isNull(match)) {
	      return parseFloat(match[1]);
	    }
	
	    // TODO ...ems? %?
	
	    return 0;
	
	  }
	
	  /**
	   * @namespace
	   * @member dat.dom
	   */
	  var dom = {
	
	    /**
	     * 
	     * @param elem
	     * @param selectable
	     */
	    makeSelectable: function(elem, selectable) {
	
	      if (elem === undefined || elem.style === undefined) return;
	
	      elem.onselectstart = selectable ? function() {
	        return false;
	      } : function() {
	      };
	
	      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
	      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
	      elem.unselectable = selectable ? 'on' : 'off';
	
	    },
	
	    /**
	     *
	     * @param elem
	     * @param horizontal
	     * @param vertical
	     */
	    makeFullscreen: function(elem, horizontal, vertical) {
	
	      if (common.isUndefined(horizontal)) horizontal = true;
	      if (common.isUndefined(vertical)) vertical = true;
	
	      elem.style.position = 'absolute';
	
	      if (horizontal) {
	        elem.style.left = 0;
	        elem.style.right = 0;
	      }
	      if (vertical) {
	        elem.style.top = 0;
	        elem.style.bottom = 0;
	      }
	
	    },
	
	    /**
	     *
	     * @param elem
	     * @param eventType
	     * @param params
	     */
	    fakeEvent: function(elem, eventType, params, aux) {
	      params = params || {};
	      var className = EVENT_MAP_INV[eventType];
	      if (!className) {
	        throw new Error('Event type ' + eventType + ' not supported.');
	      }
	      var evt = document.createEvent(className);
	      switch (className) {
	        case 'MouseEvents':
	          var clientX = params.x || params.clientX || 0;
	          var clientY = params.y || params.clientY || 0;
	          evt.initMouseEvent(eventType, params.bubbles || false,
	              params.cancelable || true, window, params.clickCount || 1,
	              0, //screen X
	              0, //screen Y
	              clientX, //client X
	              clientY, //client Y
	              false, false, false, false, 0, null);
	          break;
	        case 'KeyboardEvents':
	          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
	          common.defaults(params, {
	            cancelable: true,
	            ctrlKey: false,
	            altKey: false,
	            shiftKey: false,
	            metaKey: false,
	            keyCode: undefined,
	            charCode: undefined
	          });
	          init(eventType, params.bubbles || false,
	              params.cancelable, window,
	              params.ctrlKey, params.altKey,
	              params.shiftKey, params.metaKey,
	              params.keyCode, params.charCode);
	          break;
	        default:
	          evt.initEvent(eventType, params.bubbles || false,
	              params.cancelable || true);
	          break;
	      }
	      common.defaults(evt, aux);
	      elem.dispatchEvent(evt);
	    },
	
	    /**
	     *
	     * @param elem
	     * @param event
	     * @param func
	     * @param bool
	     */
	    bind: function(elem, event, func, bool) {
	      bool = bool || false;
	      if (elem.addEventListener)
	        elem.addEventListener(event, func, bool);
	      else if (elem.attachEvent)
	        elem.attachEvent('on' + event, func);
	      return dom;
	    },
	
	    /**
	     *
	     * @param elem
	     * @param event
	     * @param func
	     * @param bool
	     */
	    unbind: function(elem, event, func, bool) {
	      bool = bool || false;
	      if (elem.removeEventListener)
	        elem.removeEventListener(event, func, bool);
	      else if (elem.detachEvent)
	        elem.detachEvent('on' + event, func);
	      return dom;
	    },
	
	    /**
	     *
	     * @param elem
	     * @param className
	     */
	    addClass: function(elem, className) {
	      if (elem.className === undefined) {
	        elem.className = className;
	      } else if (elem.className !== className) {
	        var classes = elem.className.split(/ +/);
	        if (classes.indexOf(className) == -1) {
	          classes.push(className);
	          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
	        }
	      }
	      return dom;
	    },
	
	    /**
	     *
	     * @param elem
	     * @param className
	     */
	    removeClass: function(elem, className) {
	      if (className) {
	        if (elem.className === undefined) {
	          // elem.className = className;
	        } else if (elem.className === className) {
	          elem.removeAttribute('class');
	        } else {
	          var classes = elem.className.split(/ +/);
	          var index = classes.indexOf(className);
	          if (index != -1) {
	            classes.splice(index, 1);
	            elem.className = classes.join(' ');
	          }
	        }
	      } else {
	        elem.className = undefined;
	      }
	      return dom;
	    },
	
	    hasClass: function(elem, className) {
	      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
	    },
	
	    /**
	     *
	     * @param elem
	     */
	    getWidth: function(elem) {
	
	      var style = getComputedStyle(elem);
	
	      return cssValueToPixels(style['border-left-width']) +
	          cssValueToPixels(style['border-right-width']) +
	          cssValueToPixels(style['padding-left']) +
	          cssValueToPixels(style['padding-right']) +
	          cssValueToPixels(style['width']);
	    },
	
	    /**
	     *
	     * @param elem
	     */
	    getHeight: function(elem) {
	
	      var style = getComputedStyle(elem);
	
	      return cssValueToPixels(style['border-top-width']) +
	          cssValueToPixels(style['border-bottom-width']) +
	          cssValueToPixels(style['padding-top']) +
	          cssValueToPixels(style['padding-bottom']) +
	          cssValueToPixels(style['height']);
	    },
	
	    /**
	     *
	     * @param elem
	     */
	    getOffset: function(elem) {
	      var offset = {left: 0, top:0};
	      if (elem.offsetParent) {
	        do {
	          offset.left += elem.offsetLeft;
	          offset.top += elem.offsetTop;
	        } while (elem = elem.offsetParent);
	      }
	      return offset;
	    },
	
	    // http://stackoverflow.com/posts/2684561/revisions
	    /**
	     * 
	     * @param elem
	     */
	    isActive: function(elem) {
	      return elem === document.activeElement && ( elem.type || elem.href );
	    }
	
	  };
	
	  return dom;
	
	})(dat.utils.common);
	
	
	dat.controllers.OptionController = (function (Controller, dom, common) {
	
	  /**
	   * @class Provides a select input to alter the property of an object, using a
	   * list of accepted values.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object|string[]} options A map of labels to acceptable values, or
	   * a list of acceptable string values.
	   *
	   * @member dat.controllers
	   */
	  var OptionController = function(object, property, options) {
	
	    OptionController.superclass.call(this, object, property);
	
	    var _this = this;
	
	    /**
	     * The drop down menu
	     * @ignore
	     */
	    this.__select = document.createElement('select');
	
	    if (common.isArray(options)) {
	      var map = {};
	      common.each(options, function(element) {
	        map[element] = element;
	      });
	      options = map;
	    }
	
	    common.each(options, function(value, key) {
	
	      var opt = document.createElement('option');
	      opt.innerHTML = key;
	      opt.setAttribute('value', value);
	      _this.__select.appendChild(opt);
	
	    });
	
	    // Acknowledge original value
	    this.updateDisplay();
	
	    dom.bind(this.__select, 'change', function() {
	      var desiredValue = this.options[this.selectedIndex].value;
	      _this.setValue(desiredValue);
	    });
	
	    this.domElement.appendChild(this.__select);
	
	  };
	
	  OptionController.superclass = Controller;
	
	  common.extend(
	
	      OptionController.prototype,
	      Controller.prototype,
	
	      {
	
	        setValue: function(v) {
	          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
	          if (this.__onFinishChange) {
	            this.__onFinishChange.call(this, this.getValue());
	          }
	          return toReturn;
	        },
	
	        updateDisplay: function() {
	          this.__select.value = this.getValue();
	          return OptionController.superclass.prototype.updateDisplay.call(this);
	        }
	
	      }
	
	  );
	
	  return OptionController;
	
	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common);
	
	
	dat.controllers.NumberController = (function (Controller, common) {
	
	  /**
	   * @class Represents a given property of an object that is a number.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object} [params] Optional parameters
	   * @param {Number} [params.min] Minimum allowed value
	   * @param {Number} [params.max] Maximum allowed value
	   * @param {Number} [params.step] Increment by which to change value
	   *
	   * @member dat.controllers
	   */
	  var NumberController = function(object, property, params) {
	
	    NumberController.superclass.call(this, object, property);
	
	    params = params || {};
	
	    this.__min = params.min;
	    this.__max = params.max;
	    this.__step = params.step;
	
	    if (common.isUndefined(this.__step)) {
	
	      if (this.initialValue == 0) {
	        this.__impliedStep = 1; // What are we, psychics?
	      } else {
	        // Hey Doug, check this out.
	        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
	      }
	
	    } else {
	
	      this.__impliedStep = this.__step;
	
	    }
	
	    this.__precision = numDecimals(this.__impliedStep);
	
	
	  };
	
	  NumberController.superclass = Controller;
	
	  common.extend(
	
	      NumberController.prototype,
	      Controller.prototype,
	
	      /** @lends dat.controllers.NumberController.prototype */
	      {
	
	        setValue: function(v) {
	
	          if (this.__min !== undefined && v < this.__min) {
	            v = this.__min;
	          } else if (this.__max !== undefined && v > this.__max) {
	            v = this.__max;
	          }
	
	          if (this.__step !== undefined && v % this.__step != 0) {
	            v = Math.round(v / this.__step) * this.__step;
	          }
	
	          return NumberController.superclass.prototype.setValue.call(this, v);
	
	        },
	
	        /**
	         * Specify a minimum value for <code>object[property]</code>.
	         *
	         * @param {Number} minValue The minimum value for
	         * <code>object[property]</code>
	         * @returns {dat.controllers.NumberController} this
	         */
	        min: function(v) {
	          this.__min = v;
	          return this;
	        },
	
	        /**
	         * Specify a maximum value for <code>object[property]</code>.
	         *
	         * @param {Number} maxValue The maximum value for
	         * <code>object[property]</code>
	         * @returns {dat.controllers.NumberController} this
	         */
	        max: function(v) {
	          this.__max = v;
	          return this;
	        },
	
	        /**
	         * Specify a step value that dat.controllers.NumberController
	         * increments by.
	         *
	         * @param {Number} stepValue The step value for
	         * dat.controllers.NumberController
	         * @default if minimum and maximum specified increment is 1% of the
	         * difference otherwise stepValue is 1
	         * @returns {dat.controllers.NumberController} this
	         */
	        step: function(v) {
	          this.__step = v;
	          return this;
	        }
	
	      }
	
	  );
	
	  function numDecimals(x) {
	    x = x.toString();
	    if (x.indexOf('.') > -1) {
	      return x.length - x.indexOf('.') - 1;
	    } else {
	      return 0;
	    }
	  }
	
	  return NumberController;
	
	})(dat.controllers.Controller,
	dat.utils.common);
	
	
	dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {
	
	  /**
	   * @class Represents a given property of an object that is a number and
	   * provides an input element with which to manipulate it.
	   *
	   * @extends dat.controllers.Controller
	   * @extends dat.controllers.NumberController
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Object} [params] Optional parameters
	   * @param {Number} [params.min] Minimum allowed value
	   * @param {Number} [params.max] Maximum allowed value
	   * @param {Number} [params.step] Increment by which to change value
	   *
	   * @member dat.controllers
	   */
	  var NumberControllerBox = function(object, property, params) {
	
	    this.__truncationSuspended = false;
	
	    NumberControllerBox.superclass.call(this, object, property, params);
	
	    var _this = this;
	
	    /**
	     * {Number} Previous mouse y position
	     * @ignore
	     */
	    var prev_y;
	
	    this.__input = document.createElement('input');
	    this.__input.setAttribute('type', 'text');
	
	    // Makes it so manually specified values are not truncated.
	
	    dom.bind(this.__input, 'change', onChange);
	    dom.bind(this.__input, 'blur', onBlur);
	    dom.bind(this.__input, 'mousedown', onMouseDown);
	    dom.bind(this.__input, 'keydown', function(e) {
	
	      // When pressing entire, you can be as precise as you want.
	      if (e.keyCode === 13) {
	        _this.__truncationSuspended = true;
	        this.blur();
	        _this.__truncationSuspended = false;
	      }
	
	    });
	
	    function onChange() {
	      var attempted = parseFloat(_this.__input.value);
	      if (!common.isNaN(attempted)) _this.setValue(attempted);
	    }
	
	    function onBlur() {
	      onChange();
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	
	    function onMouseDown(e) {
	      dom.bind(window, 'mousemove', onMouseDrag);
	      dom.bind(window, 'mouseup', onMouseUp);
	      prev_y = e.clientY;
	    }
	
	    function onMouseDrag(e) {
	
	      var diff = prev_y - e.clientY;
	      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
	
	      prev_y = e.clientY;
	
	    }
	
	    function onMouseUp() {
	      dom.unbind(window, 'mousemove', onMouseDrag);
	      dom.unbind(window, 'mouseup', onMouseUp);
	    }
	
	    this.updateDisplay();
	
	    this.domElement.appendChild(this.__input);
	
	  };
	
	  NumberControllerBox.superclass = NumberController;
	
	  common.extend(
	
	      NumberControllerBox.prototype,
	      NumberController.prototype,
	
	      {
	
	        updateDisplay: function() {
	
	          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
	          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
	        }
	
	      }
	
	  );
	
	  function roundToDecimal(value, decimals) {
	    var tenTo = Math.pow(10, decimals);
	    return Math.round(value * tenTo) / tenTo;
	  }
	
	  return NumberControllerBox;
	
	})(dat.controllers.NumberController,
	dat.dom.dom,
	dat.utils.common);
	
	
	dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {
	
	  /**
	   * @class Represents a given property of an object that is a number, contains
	   * a minimum and maximum, and provides a slider element with which to
	   * manipulate it. It should be noted that the slider element is made up of
	   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
	   * <code>&lt;slider&gt;</code> element.
	   *
	   * @extends dat.controllers.Controller
	   * @extends dat.controllers.NumberController
	   * 
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   * @param {Number} minValue Minimum allowed value
	   * @param {Number} maxValue Maximum allowed value
	   * @param {Number} stepValue Increment by which to change value
	   *
	   * @member dat.controllers
	   */
	  var NumberControllerSlider = function(object, property, min, max, step) {
	
	    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });
	
	    var _this = this;
	
	    this.__background = document.createElement('div');
	    this.__foreground = document.createElement('div');
	    
	
	
	    dom.bind(this.__background, 'mousedown', onMouseDown);
	    
	    dom.addClass(this.__background, 'slider');
	    dom.addClass(this.__foreground, 'slider-fg');
	
	    function onMouseDown(e) {
	
	      dom.bind(window, 'mousemove', onMouseDrag);
	      dom.bind(window, 'mouseup', onMouseUp);
	
	      onMouseDrag(e);
	    }
	
	    function onMouseDrag(e) {
	
	      e.preventDefault();
	
	      var offset = dom.getOffset(_this.__background);
	      var width = dom.getWidth(_this.__background);
	      
	      _this.setValue(
	        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
	      );
	
	      return false;
	
	    }
	
	    function onMouseUp() {
	      dom.unbind(window, 'mousemove', onMouseDrag);
	      dom.unbind(window, 'mouseup', onMouseUp);
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	
	    this.updateDisplay();
	
	    this.__background.appendChild(this.__foreground);
	    this.domElement.appendChild(this.__background);
	
	  };
	
	  NumberControllerSlider.superclass = NumberController;
	
	  /**
	   * Injects default stylesheet for slider elements.
	   */
	  NumberControllerSlider.useDefaultStyles = function() {
	    css.inject(styleSheet);
	  };
	
	  common.extend(
	
	      NumberControllerSlider.prototype,
	      NumberController.prototype,
	
	      {
	
	        updateDisplay: function() {
	          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
	          this.__foreground.style.width = pct*100+'%';
	          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
	        }
	
	      }
	
	
	
	  );
	
	  function map(v, i1, i2, o1, o2) {
	    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
	  }
	
	  return NumberControllerSlider;
	  
	})(dat.controllers.NumberController,
	dat.dom.dom,
	dat.utils.css,
	dat.utils.common,
	".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");
	
	
	dat.controllers.FunctionController = (function (Controller, dom, common) {
	
	  /**
	   * @class Provides a GUI interface to fire a specified method, a property of an object.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var FunctionController = function(object, property, text) {
	
	    FunctionController.superclass.call(this, object, property);
	
	    var _this = this;
	
	    this.__button = document.createElement('div');
	    this.__button.innerHTML = text === undefined ? 'Fire' : text;
	    dom.bind(this.__button, 'click', function(e) {
	      e.preventDefault();
	      _this.fire();
	      return false;
	    });
	
	    dom.addClass(this.__button, 'button');
	
	    this.domElement.appendChild(this.__button);
	
	
	  };
	
	  FunctionController.superclass = Controller;
	
	  common.extend(
	
	      FunctionController.prototype,
	      Controller.prototype,
	      {
	        
	        fire: function() {
	          if (this.__onChange) {
	            this.__onChange.call(this);
	          }
	          if (this.__onFinishChange) {
	            this.__onFinishChange.call(this, this.getValue());
	          }
	          this.getValue().call(this.object);
	        }
	      }
	
	  );
	
	  return FunctionController;
	
	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common);
	
	
	dat.controllers.BooleanController = (function (Controller, dom, common) {
	
	  /**
	   * @class Provides a checkbox input to alter the boolean property of an object.
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var BooleanController = function(object, property) {
	
	    BooleanController.superclass.call(this, object, property);
	
	    var _this = this;
	    this.__prev = this.getValue();
	
	    this.__checkbox = document.createElement('input');
	    this.__checkbox.setAttribute('type', 'checkbox');
	
	
	    dom.bind(this.__checkbox, 'change', onChange, false);
	
	    this.domElement.appendChild(this.__checkbox);
	
	    // Match original value
	    this.updateDisplay();
	
	    function onChange() {
	      _this.setValue(!_this.__prev);
	    }
	
	  };
	
	  BooleanController.superclass = Controller;
	
	  common.extend(
	
	      BooleanController.prototype,
	      Controller.prototype,
	
	      {
	
	        setValue: function(v) {
	          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
	          if (this.__onFinishChange) {
	            this.__onFinishChange.call(this, this.getValue());
	          }
	          this.__prev = this.getValue();
	          return toReturn;
	        },
	
	        updateDisplay: function() {
	          
	          if (this.getValue() === true) {
	            this.__checkbox.setAttribute('checked', 'checked');
	            this.__checkbox.checked = true;    
	          } else {
	              this.__checkbox.checked = false;
	          }
	
	          return BooleanController.superclass.prototype.updateDisplay.call(this);
	
	        }
	
	
	      }
	
	  );
	
	  return BooleanController;
	
	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common);
	
	
	dat.color.toString = (function (common) {
	
	  return function(color) {
	
	    if (color.a == 1 || common.isUndefined(color.a)) {
	
	      var s = color.hex.toString(16);
	      while (s.length < 6) {
	        s = '0' + s;
	      }
	
	      return '#' + s;
	
	    } else {
	
	      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';
	
	    }
	
	  }
	
	})(dat.utils.common);
	
	
	dat.color.interpret = (function (toString, common) {
	
	  var result, toReturn;
	
	  var interpret = function() {
	
	    toReturn = false;
	
	    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];
	
	    common.each(INTERPRETATIONS, function(family) {
	
	      if (family.litmus(original)) {
	
	        common.each(family.conversions, function(conversion, conversionName) {
	
	          result = conversion.read(original);
	
	          if (toReturn === false && result !== false) {
	            toReturn = result;
	            result.conversionName = conversionName;
	            result.conversion = conversion;
	            return common.BREAK;
	
	          }
	
	        });
	
	        return common.BREAK;
	
	      }
	
	    });
	
	    return toReturn;
	
	  };
	
	  var INTERPRETATIONS = [
	
	    // Strings
	    {
	
	      litmus: common.isString,
	
	      conversions: {
	
	        THREE_CHAR_HEX: {
	
	          read: function(original) {
	
	            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
	            if (test === null) return false;
	
	            return {
	              space: 'HEX',
	              hex: parseInt(
	                  '0x' +
	                      test[1].toString() + test[1].toString() +
	                      test[2].toString() + test[2].toString() +
	                      test[3].toString() + test[3].toString())
	            };
	
	          },
	
	          write: toString
	
	        },
	
	        SIX_CHAR_HEX: {
	
	          read: function(original) {
	
	            var test = original.match(/^#([A-F0-9]{6})$/i);
	            if (test === null) return false;
	
	            return {
	              space: 'HEX',
	              hex: parseInt('0x' + test[1].toString())
	            };
	
	          },
	
	          write: toString
	
	        },
	
	        CSS_RGB: {
	
	          read: function(original) {
	
	            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
	            if (test === null) return false;
	
	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3])
	            };
	
	          },
	
	          write: toString
	
	        },
	
	        CSS_RGBA: {
	
	          read: function(original) {
	
	            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
	            if (test === null) return false;
	
	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3]),
	              a: parseFloat(test[4])
	            };
	
	          },
	
	          write: toString
	
	        }
	
	      }
	
	    },
	
	    // Numbers
	    {
	
	      litmus: common.isNumber,
	
	      conversions: {
	
	        HEX: {
	          read: function(original) {
	            return {
	              space: 'HEX',
	              hex: original,
	              conversionName: 'HEX'
	            }
	          },
	
	          write: function(color) {
	            return color.hex;
	          }
	        }
	
	      }
	
	    },
	
	    // Arrays
	    {
	
	      litmus: common.isArray,
	
	      conversions: {
	
	        RGB_ARRAY: {
	          read: function(original) {
	            if (original.length != 3) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2]
	            };
	          },
	
	          write: function(color) {
	            return [color.r, color.g, color.b];
	          }
	
	        },
	
	        RGBA_ARRAY: {
	          read: function(original) {
	            if (original.length != 4) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2],
	              a: original[3]
	            };
	          },
	
	          write: function(color) {
	            return [color.r, color.g, color.b, color.a];
	          }
	
	        }
	
	      }
	
	    },
	
	    // Objects
	    {
	
	      litmus: common.isObject,
	
	      conversions: {
	
	        RGBA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b,
	                a: original.a
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b,
	              a: color.a
	            }
	          }
	        },
	
	        RGB_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b
	            }
	          }
	        },
	
	        HSVA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v,
	                a: original.a
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v,
	              a: color.a
	            }
	          }
	        },
	
	        HSV_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v
	            }
	          }
	
	        }
	
	      }
	
	    }
	
	
	  ];
	
	  return interpret;
	
	
	})(dat.color.toString,
	dat.utils.common);
	
	
	dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {
	
	  css.inject(styleSheet);
	
	  /** Outer-most className for GUI's */
	  var CSS_NAMESPACE = 'dg';
	
	  var HIDE_KEY_CODE = 72;
	
	  /** The only value shared between the JS and SCSS. Use caution. */
	  var CLOSE_BUTTON_HEIGHT = 20;
	
	  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
	
	  var SUPPORTS_LOCAL_STORAGE = (function() {
	    try {
	      return 'localStorage' in window && window['localStorage'] !== null;
	    } catch (e) {
	      return false;
	    }
	  })();
	
	  var SAVE_DIALOGUE;
	
	  /** Have we yet to create an autoPlace GUI? */
	  var auto_place_virgin = true;
	
	  /** Fixed position div that auto place GUI's go inside */
	  var auto_place_container;
	
	  /** Are we hiding the GUI's ? */
	  var hide = false;
	
	  /** GUI's which should be hidden */
	  var hideable_guis = [];
	
	  /**
	   * A lightweight controller library for JavaScript. It allows you to easily
	   * manipulate variables and fire functions on the fly.
	   * @class
	   *
	   * @member dat.gui
	   *
	   * @param {Object} [params]
	   * @param {String} [params.name] The name of this GUI.
	   * @param {Object} [params.load] JSON object representing the saved state of
	   * this GUI.
	   * @param {Boolean} [params.auto=true]
	   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
	   * @param {Boolean} [params.closed] If true, starts closed
	   */
	  var GUI = function(params) {
	
	    var _this = this;
	
	    /**
	     * Outermost DOM Element
	     * @type DOMElement
	     */
	    this.domElement = document.createElement('div');
	    this.__ul = document.createElement('ul');
	    this.domElement.appendChild(this.__ul);
	
	    dom.addClass(this.domElement, CSS_NAMESPACE);
	
	    /**
	     * Nested GUI's by name
	     * @ignore
	     */
	    this.__folders = {};
	
	    this.__controllers = [];
	
	    /**
	     * List of objects I'm remembering for save, only used in top level GUI
	     * @ignore
	     */
	    this.__rememberedObjects = [];
	
	    /**
	     * Maps the index of remembered objects to a map of controllers, only used
	     * in top level GUI.
	     *
	     * @private
	     * @ignore
	     *
	     * @example
	     * [
	     *  {
	     *    propertyName: Controller,
	     *    anotherPropertyName: Controller
	     *  },
	     *  {
	     *    propertyName: Controller
	     *  }
	     * ]
	     */
	    this.__rememberedObjectIndecesToControllers = [];
	
	    this.__listening = [];
	
	    params = params || {};
	
	    // Default parameters
	    params = common.defaults(params, {
	      autoPlace: true,
	      width: GUI.DEFAULT_WIDTH
	    });
	
	    params = common.defaults(params, {
	      resizable: params.autoPlace,
	      hideable: params.autoPlace
	    });
	
	
	    if (!common.isUndefined(params.load)) {
	
	      // Explicit preset
	      if (params.preset) params.load.preset = params.preset;
	
	    } else {
	
	      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
	
	    }
	
	    if (common.isUndefined(params.parent) && params.hideable) {
	      hideable_guis.push(this);
	    }
	
	    // Only root level GUI's are resizable.
	    params.resizable = common.isUndefined(params.parent) && params.resizable;
	
	
	    if (params.autoPlace && common.isUndefined(params.scrollable)) {
	      params.scrollable = true;
	    }
	//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;
	
	    // Not part of params because I don't want people passing this in via
	    // constructor. Should be a 'remembered' value.
	    var use_local_storage =
	        SUPPORTS_LOCAL_STORAGE &&
	            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
	
	    Object.defineProperties(this,
	
	        /** @lends dat.gui.GUI.prototype */
	        {
	
	          /**
	           * The parent <code>GUI</code>
	           * @type dat.gui.GUI
	           */
	          parent: {
	            get: function() {
	              return params.parent;
	            }
	          },
	
	          scrollable: {
	            get: function() {
	              return params.scrollable;
	            }
	          },
	
	          /**
	           * Handles <code>GUI</code>'s element placement for you
	           * @type Boolean
	           */
	          autoPlace: {
	            get: function() {
	              return params.autoPlace;
	            }
	          },
	
	          /**
	           * The identifier for a set of saved values
	           * @type String
	           */
	          preset: {
	
	            get: function() {
	              if (_this.parent) {
	                return _this.getRoot().preset;
	              } else {
	                return params.load.preset;
	              }
	            },
	
	            set: function(v) {
	              if (_this.parent) {
	                _this.getRoot().preset = v;
	              } else {
	                params.load.preset = v;
	              }
	              setPresetSelectIndex(this);
	              _this.revert();
	            }
	
	          },
	
	          /**
	           * The width of <code>GUI</code> element
	           * @type Number
	           */
	          width: {
	            get: function() {
	              return params.width;
	            },
	            set: function(v) {
	              params.width = v;
	              setWidth(_this, v);
	            }
	          },
	
	          /**
	           * The name of <code>GUI</code>. Used for folders. i.e
	           * a folder's name
	           * @type String
	           */
	          name: {
	            get: function() {
	              return params.name;
	            },
	            set: function(v) {
	              // TODO Check for collisions among sibling folders
	              params.name = v;
	              if (title_row_name) {
	                title_row_name.innerHTML = params.name;
	              }
	            }
	          },
	
	          /**
	           * Whether the <code>GUI</code> is collapsed or not
	           * @type Boolean
	           */
	          closed: {
	            get: function() {
	              return params.closed;
	            },
	            set: function(v) {
	              params.closed = v;
	              if (params.closed) {
	                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
	              } else {
	                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
	              }
	              // For browsers that aren't going to respect the CSS transition,
	              // Lets just check our height against the window height right off
	              // the bat.
	              this.onResize();
	
	              if (_this.__closeButton) {
	                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
	              }
	            }
	          },
	
	          /**
	           * Contains all presets
	           * @type Object
	           */
	          load: {
	            get: function() {
	              return params.load;
	            }
	          },
	
	          /**
	           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
	           * <code>remember</code>ing
	           * @type Boolean
	           */
	          useLocalStorage: {
	
	            get: function() {
	              return use_local_storage;
	            },
	            set: function(bool) {
	              if (SUPPORTS_LOCAL_STORAGE) {
	                use_local_storage = bool;
	                if (bool) {
	                  dom.bind(window, 'unload', saveToLocalStorage);
	                } else {
	                  dom.unbind(window, 'unload', saveToLocalStorage);
	                }
	                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
	              }
	            }
	
	          }
	
	        });
	
	    // Are we a root level GUI?
	    if (common.isUndefined(params.parent)) {
	
	      params.closed = false;
	
	      dom.addClass(this.domElement, GUI.CLASS_MAIN);
	      dom.makeSelectable(this.domElement, false);
	
	      // Are we supposed to be loading locally?
	      if (SUPPORTS_LOCAL_STORAGE) {
	
	        if (use_local_storage) {
	
	          _this.useLocalStorage = true;
	
	          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
	
	          if (saved_gui) {
	            params.load = JSON.parse(saved_gui);
	          }
	
	        }
	
	      }
	
	      this.__closeButton = document.createElement('div');
	      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
	      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
	      this.domElement.appendChild(this.__closeButton);
	
	      dom.bind(this.__closeButton, 'click', function() {
	
	        _this.closed = !_this.closed;
	
	
	      });
	
	
	      // Oh, you're a nested GUI!
	    } else {
	
	      if (params.closed === undefined) {
	        params.closed = true;
	      }
	
	      var title_row_name = document.createTextNode(params.name);
	      dom.addClass(title_row_name, 'controller-name');
	
	      var title_row = addRow(_this, title_row_name);
	
	      var on_click_title = function(e) {
	        e.preventDefault();
	        _this.closed = !_this.closed;
	        return false;
	      };
	
	      dom.addClass(this.__ul, GUI.CLASS_CLOSED);
	
	      dom.addClass(title_row, 'title');
	      dom.bind(title_row, 'click', on_click_title);
	
	      if (!params.closed) {
	        this.closed = false;
	      }
	
	    }
	
	    if (params.autoPlace) {
	
	      if (common.isUndefined(params.parent)) {
	
	        if (auto_place_virgin) {
	          auto_place_container = document.createElement('div');
	          dom.addClass(auto_place_container, CSS_NAMESPACE);
	          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
	          document.body.appendChild(auto_place_container);
	          auto_place_virgin = false;
	        }
	
	        // Put it in the dom for you.
	        auto_place_container.appendChild(this.domElement);
	
	        // Apply the auto styles
	        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
	
	      }
	
	
	      // Make it not elastic.
	      if (!this.parent) setWidth(_this, params.width);
	
	    }
	
	    dom.bind(window, 'resize', function() { _this.onResize() });
	    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
	    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
	    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
	    this.onResize();
	
	
	    if (params.resizable) {
	      addResizeHandle(this);
	    }
	
	    function saveToLocalStorage() {
	      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
	    }
	
	    var root = _this.getRoot();
	    function resetWidth() {
	        var root = _this.getRoot();
	        root.width += 1;
	        common.defer(function() {
	          root.width -= 1;
	        });
	      }
	
	      if (!params.parent) {
	        resetWidth();
	      }
	
	  };
	
	  GUI.toggleHide = function() {
	
	    hide = !hide;
	    common.each(hideable_guis, function(gui) {
	      gui.domElement.style.zIndex = hide ? -999 : 999;
	      gui.domElement.style.opacity = hide ? 0 : 1;
	    });
	  };
	
	  GUI.CLASS_AUTO_PLACE = 'a';
	  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
	  GUI.CLASS_MAIN = 'main';
	  GUI.CLASS_CONTROLLER_ROW = 'cr';
	  GUI.CLASS_TOO_TALL = 'taller-than-window';
	  GUI.CLASS_CLOSED = 'closed';
	  GUI.CLASS_CLOSE_BUTTON = 'close-button';
	  GUI.CLASS_DRAG = 'drag';
	
	  GUI.DEFAULT_WIDTH = 245;
	  GUI.TEXT_CLOSED = 'Close Controls';
	  GUI.TEXT_OPEN = 'Open Controls';
	
	  dom.bind(window, 'keydown', function(e) {
	
	    if (document.activeElement.type !== 'text' &&
	        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
	      GUI.toggleHide();
	    }
	
	  }, false);
	
	  common.extend(
	
	      GUI.prototype,
	
	      /** @lends dat.gui.GUI */
	      {
	
	        /**
	         * @param object
	         * @param property
	         * @returns {dat.controllers.Controller} The new controller that was added.
	         * @instance
	         */
	        add: function(object, property) {
	
	          return add(
	              this,
	              object,
	              property,
	              {
	                factoryArgs: Array.prototype.slice.call(arguments, 2)
	              }
	          );
	
	        },
	
	        /**
	         * @param object
	         * @param property
	         * @returns {dat.controllers.ColorController} The new controller that was added.
	         * @instance
	         */
	        addColor: function(object, property) {
	
	          return add(
	              this,
	              object,
	              property,
	              {
	                color: true
	              }
	          );
	
	        },
	
	        /**
	         * @param controller
	         * @instance
	         */
	        remove: function(controller) {
	
	          // TODO listening?
	          this.__ul.removeChild(controller.__li);
	          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
	          var _this = this;
	          common.defer(function() {
	            _this.onResize();
	          });
	
	        },
	
	        destroy: function() {
	
	          if (this.autoPlace) {
	            auto_place_container.removeChild(this.domElement);
	          }
	
	        },
	
	        /**
	         * @param name
	         * @returns {dat.gui.GUI} The new folder.
	         * @throws {Error} if this GUI already has a folder by the specified
	         * name
	         * @instance
	         */
	        addFolder: function(name) {
	
	          // We have to prevent collisions on names in order to have a key
	          // by which to remember saved values
	          if (this.__folders[name] !== undefined) {
	            throw new Error('You already have a folder in this GUI by the' +
	                ' name "' + name + '"');
	          }
	
	          var new_gui_params = { name: name, parent: this };
	
	          // We need to pass down the autoPlace trait so that we can
	          // attach event listeners to open/close folder actions to
	          // ensure that a scrollbar appears if the window is too short.
	          new_gui_params.autoPlace = this.autoPlace;
	
	          // Do we have saved appearance data for this folder?
	
	          if (this.load && // Anything loaded?
	              this.load.folders && // Was my parent a dead-end?
	              this.load.folders[name]) { // Did daddy remember me?
	
	            // Start me closed if I was closed
	            new_gui_params.closed = this.load.folders[name].closed;
	
	            // Pass down the loaded data
	            new_gui_params.load = this.load.folders[name];
	
	          }
	
	          var gui = new GUI(new_gui_params);
	          this.__folders[name] = gui;
	
	          var li = addRow(this, gui.domElement);
	          dom.addClass(li, 'folder');
	          return gui;
	
	        },
	
	        open: function() {
	          this.closed = false;
	        },
	
	        close: function() {
	          this.closed = true;
	        },
	
	        onResize: function() {
	
	          var root = this.getRoot();
	
	          if (root.scrollable) {
	
	            var top = dom.getOffset(root.__ul).top;
	            var h = 0;
	
	            common.each(root.__ul.childNodes, function(node) {
	              if (! (root.autoPlace && node === root.__save_row))
	                h += dom.getHeight(node);
	            });
	
	            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
	              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
	              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
	            } else {
	              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
	              root.__ul.style.height = 'auto';
	            }
	
	          }
	
	          if (root.__resize_handle) {
	            common.defer(function() {
	              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
	            });
	          }
	
	          if (root.__closeButton) {
	            root.__closeButton.style.width = root.width + 'px';
	          }
	
	        },
	
	        /**
	         * Mark objects for saving. The order of these objects cannot change as
	         * the GUI grows. When remembering new objects, append them to the end
	         * of the list.
	         *
	         * @param {Object...} objects
	         * @throws {Error} if not called on a top level GUI.
	         * @instance
	         */
	        remember: function() {
	
	          if (common.isUndefined(SAVE_DIALOGUE)) {
	            SAVE_DIALOGUE = new CenteredDiv();
	            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
	          }
	
	          if (this.parent) {
	            throw new Error("You can only call remember on a top level GUI.");
	          }
	
	          var _this = this;
	
	          common.each(Array.prototype.slice.call(arguments), function(object) {
	            if (_this.__rememberedObjects.length == 0) {
	              addSaveMenu(_this);
	            }
	            if (_this.__rememberedObjects.indexOf(object) == -1) {
	              _this.__rememberedObjects.push(object);
	            }
	          });
	
	          if (this.autoPlace) {
	            // Set save row width
	            setWidth(this, this.width);
	          }
	
	        },
	
	        /**
	         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
	         * @instance
	         */
	        getRoot: function() {
	          var gui = this;
	          while (gui.parent) {
	            gui = gui.parent;
	          }
	          return gui;
	        },
	
	        /**
	         * @returns {Object} a JSON object representing the current state of
	         * this GUI as well as its remembered properties.
	         * @instance
	         */
	        getSaveObject: function() {
	
	          var toReturn = this.load;
	
	          toReturn.closed = this.closed;
	
	          // Am I remembering any values?
	          if (this.__rememberedObjects.length > 0) {
	
	            toReturn.preset = this.preset;
	
	            if (!toReturn.remembered) {
	              toReturn.remembered = {};
	            }
	
	            toReturn.remembered[this.preset] = getCurrentPreset(this);
	
	          }
	
	          toReturn.folders = {};
	          common.each(this.__folders, function(element, key) {
	            toReturn.folders[key] = element.getSaveObject();
	          });
	
	          return toReturn;
	
	        },
	
	        save: function() {
	
	          if (!this.load.remembered) {
	            this.load.remembered = {};
	          }
	
	          this.load.remembered[this.preset] = getCurrentPreset(this);
	          markPresetModified(this, false);
	
	        },
	
	        saveAs: function(presetName) {
	
	          if (!this.load.remembered) {
	
	            // Retain default values upon first save
	            this.load.remembered = {};
	            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
	
	          }
	
	          this.load.remembered[presetName] = getCurrentPreset(this);
	          this.preset = presetName;
	          addPresetOption(this, presetName, true);
	
	        },
	
	        revert: function(gui) {
	
	          common.each(this.__controllers, function(controller) {
	            // Make revert work on Default.
	            if (!this.getRoot().load.remembered) {
	              controller.setValue(controller.initialValue);
	            } else {
	              recallSavedValue(gui || this.getRoot(), controller);
	            }
	          }, this);
	
	          common.each(this.__folders, function(folder) {
	            folder.revert(folder);
	          });
	
	          if (!gui) {
	            markPresetModified(this.getRoot(), false);
	          }
	
	
	        },
	
	        listen: function(controller) {
	
	          var init = this.__listening.length == 0;
	          this.__listening.push(controller);
	          if (init) updateDisplays(this.__listening);
	
	        }
	
	      }
	
	  );
	
	  function add(gui, object, property, params) {
	
	    if (object[property] === undefined) {
	      throw new Error("Object " + object + " has no property \"" + property + "\"");
	    }
	
	    var controller;
	
	    if (params.color) {
	
	      controller = new ColorController(object, property);
	
	    } else {
	
	      var factoryArgs = [object,property].concat(params.factoryArgs);
	      controller = controllerFactory.apply(gui, factoryArgs);
	
	    }
	
	    if (params.before instanceof Controller) {
	      params.before = params.before.__li;
	    }
	
	    recallSavedValue(gui, controller);
	
	    dom.addClass(controller.domElement, 'c');
	
	    var name = document.createElement('span');
	    dom.addClass(name, 'property-name');
	    name.innerHTML = controller.property;
	
	    var container = document.createElement('div');
	    container.appendChild(name);
	    container.appendChild(controller.domElement);
	
	    var li = addRow(gui, container, params.before);
	
	    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
	    dom.addClass(li, typeof controller.getValue());
	
	    augmentController(gui, li, controller);
	
	    gui.__controllers.push(controller);
	
	    return controller;
	
	  }
	
	  /**
	   * Add a row to the end of the GUI or before another row.
	   *
	   * @param gui
	   * @param [dom] If specified, inserts the dom content in the new row
	   * @param [liBefore] If specified, places the new row before another row
	   */
	  function addRow(gui, dom, liBefore) {
	    var li = document.createElement('li');
	    if (dom) li.appendChild(dom);
	    if (liBefore) {
	      gui.__ul.insertBefore(li, params.before);
	    } else {
	      gui.__ul.appendChild(li);
	    }
	    gui.onResize();
	    return li;
	  }
	
	  function augmentController(gui, li, controller) {
	
	    controller.__li = li;
	    controller.__gui = gui;
	
	    common.extend(controller, {
	
	      options: function(options) {
	
	        if (arguments.length > 1) {
	          controller.remove();
	
	          return add(
	              gui,
	              controller.object,
	              controller.property,
	              {
	                before: controller.__li.nextElementSibling,
	                factoryArgs: [common.toArray(arguments)]
	              }
	          );
	
	        }
	
	        if (common.isArray(options) || common.isObject(options)) {
	          controller.remove();
	
	          return add(
	              gui,
	              controller.object,
	              controller.property,
	              {
	                before: controller.__li.nextElementSibling,
	                factoryArgs: [options]
	              }
	          );
	
	        }
	
	      },
	
	      name: function(v) {
	        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
	        return controller;
	      },
	
	      listen: function() {
	        controller.__gui.listen(controller);
	        return controller;
	      },
	
	      remove: function() {
	        controller.__gui.remove(controller);
	        return controller;
	      }
	
	    });
	
	    // All sliders should be accompanied by a box.
	    if (controller instanceof NumberControllerSlider) {
	
	      var box = new NumberControllerBox(controller.object, controller.property,
	          { min: controller.__min, max: controller.__max, step: controller.__step });
	
	      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
	        var pc = controller[method];
	        var pb = box[method];
	        controller[method] = box[method] = function() {
	          var args = Array.prototype.slice.call(arguments);
	          pc.apply(controller, args);
	          return pb.apply(box, args);
	        }
	      });
	
	      dom.addClass(li, 'has-slider');
	      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
	
	    }
	    else if (controller instanceof NumberControllerBox) {
	
	      var r = function(returned) {
	
	        // Have we defined both boundaries?
	        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {
	
	          // Well, then lets just replace this with a slider.
	          controller.remove();
	          return add(
	              gui,
	              controller.object,
	              controller.property,
	              {
	                before: controller.__li.nextElementSibling,
	                factoryArgs: [controller.__min, controller.__max, controller.__step]
	              });
	
	        }
	
	        return returned;
	
	      };
	
	      controller.min = common.compose(r, controller.min);
	      controller.max = common.compose(r, controller.max);
	
	    }
	    else if (controller instanceof BooleanController) {
	
	      dom.bind(li, 'click', function() {
	        dom.fakeEvent(controller.__checkbox, 'click');
	      });
	
	      dom.bind(controller.__checkbox, 'click', function(e) {
	        e.stopPropagation(); // Prevents double-toggle
	      })
	
	    }
	    else if (controller instanceof FunctionController) {
	
	      dom.bind(li, 'click', function() {
	        dom.fakeEvent(controller.__button, 'click');
	      });
	
	      dom.bind(li, 'mouseover', function() {
	        dom.addClass(controller.__button, 'hover');
	      });
	
	      dom.bind(li, 'mouseout', function() {
	        dom.removeClass(controller.__button, 'hover');
	      });
	
	    }
	    else if (controller instanceof ColorController) {
	
	      dom.addClass(li, 'color');
	      controller.updateDisplay = common.compose(function(r) {
	        li.style.borderLeftColor = controller.__color.toString();
	        return r;
	      }, controller.updateDisplay);
	
	      controller.updateDisplay();
	
	    }
	
	    controller.setValue = common.compose(function(r) {
	      if (gui.getRoot().__preset_select && controller.isModified()) {
	        markPresetModified(gui.getRoot(), true);
	      }
	      return r;
	    }, controller.setValue);
	
	  }
	
	  function recallSavedValue(gui, controller) {
	
	    // Find the topmost GUI, that's where remembered objects live.
	    var root = gui.getRoot();
	
	    // Does the object we're controlling match anything we've been told to
	    // remember?
	    var matched_index = root.__rememberedObjects.indexOf(controller.object);
	
	    // Why yes, it does!
	    if (matched_index != -1) {
	
	      // Let me fetch a map of controllers for thcommon.isObject.
	      var controller_map =
	          root.__rememberedObjectIndecesToControllers[matched_index];
	
	      // Ohp, I believe this is the first controller we've created for this
	      // object. Lets make the map fresh.
	      if (controller_map === undefined) {
	        controller_map = {};
	        root.__rememberedObjectIndecesToControllers[matched_index] =
	            controller_map;
	      }
	
	      // Keep track of this controller
	      controller_map[controller.property] = controller;
	
	      // Okay, now have we saved any values for this controller?
	      if (root.load && root.load.remembered) {
	
	        var preset_map = root.load.remembered;
	
	        // Which preset are we trying to load?
	        var preset;
	
	        if (preset_map[gui.preset]) {
	
	          preset = preset_map[gui.preset];
	
	        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {
	
	          // Uhh, you can have the default instead?
	          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];
	
	        } else {
	
	          // Nada.
	
	          return;
	
	        }
	
	
	        // Did the loaded object remember thcommon.isObject?
	        if (preset[matched_index] &&
	
	          // Did we remember this particular property?
	            preset[matched_index][controller.property] !== undefined) {
	
	          // We did remember something for this guy ...
	          var value = preset[matched_index][controller.property];
	
	          // And that's what it is.
	          controller.initialValue = value;
	          controller.setValue(value);
	
	        }
	
	      }
	
	    }
	
	  }
	
	  function getLocalStorageHash(gui, key) {
	    // TODO how does this deal with multiple GUI's?
	    return document.location.href + '.' + key;
	
	  }
	
	  function addSaveMenu(gui) {
	
	    var div = gui.__save_row = document.createElement('li');
	
	    dom.addClass(gui.domElement, 'has-save');
	
	    gui.__ul.insertBefore(div, gui.__ul.firstChild);
	
	    dom.addClass(div, 'save-row');
	
	    var gears = document.createElement('span');
	    gears.innerHTML = '&nbsp;';
	    dom.addClass(gears, 'button gears');
	
	    // TODO replace with FunctionController
	    var button = document.createElement('span');
	    button.innerHTML = 'Save';
	    dom.addClass(button, 'button');
	    dom.addClass(button, 'save');
	
	    var button2 = document.createElement('span');
	    button2.innerHTML = 'New';
	    dom.addClass(button2, 'button');
	    dom.addClass(button2, 'save-as');
	
	    var button3 = document.createElement('span');
	    button3.innerHTML = 'Revert';
	    dom.addClass(button3, 'button');
	    dom.addClass(button3, 'revert');
	
	    var select = gui.__preset_select = document.createElement('select');
	
	    if (gui.load && gui.load.remembered) {
	
	      common.each(gui.load.remembered, function(value, key) {
	        addPresetOption(gui, key, key == gui.preset);
	      });
	
	    } else {
	      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
	    }
	
	    dom.bind(select, 'change', function() {
	
	
	      for (var index = 0; index < gui.__preset_select.length; index++) {
	        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
	      }
	
	      gui.preset = this.value;
	
	    });
	
	    div.appendChild(select);
	    div.appendChild(gears);
	    div.appendChild(button);
	    div.appendChild(button2);
	    div.appendChild(button3);
	
	    if (SUPPORTS_LOCAL_STORAGE) {
	
	      var saveLocally = document.getElementById('dg-save-locally');
	      var explain = document.getElementById('dg-local-explain');
	
	      saveLocally.style.display = 'block';
	
	      var localStorageCheckBox = document.getElementById('dg-local-storage');
	
	      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
	        localStorageCheckBox.setAttribute('checked', 'checked');
	      }
	
	      function showHideExplain() {
	        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
	      }
	
	      showHideExplain();
	
	      // TODO: Use a boolean controller, fool!
	      dom.bind(localStorageCheckBox, 'change', function() {
	        gui.useLocalStorage = !gui.useLocalStorage;
	        showHideExplain();
	      });
	
	    }
	
	    var newConstructorTextArea = document.getElementById('dg-new-constructor');
	
	    dom.bind(newConstructorTextArea, 'keydown', function(e) {
	      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
	        SAVE_DIALOGUE.hide();
	      }
	    });
	
	    dom.bind(gears, 'click', function() {
	      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
	      SAVE_DIALOGUE.show();
	      newConstructorTextArea.focus();
	      newConstructorTextArea.select();
	    });
	
	    dom.bind(button, 'click', function() {
	      gui.save();
	    });
	
	    dom.bind(button2, 'click', function() {
	      var presetName = prompt('Enter a new preset name.');
	      if (presetName) gui.saveAs(presetName);
	    });
	
	    dom.bind(button3, 'click', function() {
	      gui.revert();
	    });
	
	//    div.appendChild(button2);
	
	  }
	
	  function addResizeHandle(gui) {
	
	    gui.__resize_handle = document.createElement('div');
	
	    common.extend(gui.__resize_handle.style, {
	
	      width: '6px',
	      marginLeft: '-3px',
	      height: '200px',
	      cursor: 'ew-resize',
	      position: 'absolute'
	//      border: '1px solid blue'
	
	    });
	
	    var pmouseX;
	
	    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
	    dom.bind(gui.__closeButton, 'mousedown', dragStart);
	
	    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
	
	    function dragStart(e) {
	
	      e.preventDefault();
	
	      pmouseX = e.clientX;
	
	      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
	      dom.bind(window, 'mousemove', drag);
	      dom.bind(window, 'mouseup', dragStop);
	
	      return false;
	
	    }
	
	    function drag(e) {
	
	      e.preventDefault();
	
	      gui.width += pmouseX - e.clientX;
	      gui.onResize();
	      pmouseX = e.clientX;
	
	      return false;
	
	    }
	
	    function dragStop() {
	
	      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
	      dom.unbind(window, 'mousemove', drag);
	      dom.unbind(window, 'mouseup', dragStop);
	
	    }
	
	  }
	
	  function setWidth(gui, w) {
	    gui.domElement.style.width = w + 'px';
	    // Auto placed save-rows are position fixed, so we have to
	    // set the width manually if we want it to bleed to the edge
	    if (gui.__save_row && gui.autoPlace) {
	      gui.__save_row.style.width = w + 'px';
	    }if (gui.__closeButton) {
	      gui.__closeButton.style.width = w + 'px';
	    }
	  }
	
	  function getCurrentPreset(gui, useInitialValues) {
	
	    var toReturn = {};
	
	    // For each object I'm remembering
	    common.each(gui.__rememberedObjects, function(val, index) {
	
	      var saved_values = {};
	
	      // The controllers I've made for thcommon.isObject by property
	      var controller_map =
	          gui.__rememberedObjectIndecesToControllers[index];
	
	      // Remember each value for each property
	      common.each(controller_map, function(controller, property) {
	        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
	      });
	
	      // Save the values for thcommon.isObject
	      toReturn[index] = saved_values;
	
	    });
	
	    return toReturn;
	
	  }
	
	  function addPresetOption(gui, name, setSelected) {
	    var opt = document.createElement('option');
	    opt.innerHTML = name;
	    opt.value = name;
	    gui.__preset_select.appendChild(opt);
	    if (setSelected) {
	      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
	    }
	  }
	
	  function setPresetSelectIndex(gui) {
	    for (var index = 0; index < gui.__preset_select.length; index++) {
	      if (gui.__preset_select[index].value == gui.preset) {
	        gui.__preset_select.selectedIndex = index;
	      }
	    }
	  }
	
	  function markPresetModified(gui, modified) {
	    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
	//    console.log('mark', modified, opt);
	    if (modified) {
	      opt.innerHTML = opt.value + "*";
	    } else {
	      opt.innerHTML = opt.value;
	    }
	  }
	
	  function updateDisplays(controllerArray) {
	
	
	    if (controllerArray.length != 0) {
	
	      requestAnimationFrame(function() {
	        updateDisplays(controllerArray);
	      });
	
	    }
	
	    common.each(controllerArray, function(c) {
	      c.updateDisplay();
	    });
	
	  }
	
	  return GUI;
	
	})(dat.utils.css,
	"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
	".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
	dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {
	
	      return function(object, property) {
	
	        var initialValue = object[property];
	
	        // Providing options?
	        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
	          return new OptionController(object, property, arguments[2]);
	        }
	
	        // Providing a map?
	
	        if (common.isNumber(initialValue)) {
	
	          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {
	
	            // Has min and max.
	            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
	
	          } else {
	
	            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
	
	          }
	
	        }
	
	        if (common.isString(initialValue)) {
	          return new StringController(object, property);
	        }
	
	        if (common.isFunction(initialValue)) {
	          return new FunctionController(object, property, '');
	        }
	
	        if (common.isBoolean(initialValue)) {
	          return new BooleanController(object, property);
	        }
	
	      }
	
	    })(dat.controllers.OptionController,
	dat.controllers.NumberControllerBox,
	dat.controllers.NumberControllerSlider,
	dat.controllers.StringController = (function (Controller, dom, common) {
	
	  /**
	   * @class Provides a text input to alter the string property of an object.
	   *
	   * @extends dat.controllers.Controller
	   *
	   * @param {Object} object The object to be manipulated
	   * @param {string} property The name of the property to be manipulated
	   *
	   * @member dat.controllers
	   */
	  var StringController = function(object, property) {
	
	    StringController.superclass.call(this, object, property);
	
	    var _this = this;
	
	    this.__input = document.createElement('input');
	    this.__input.setAttribute('type', 'text');
	
	    dom.bind(this.__input, 'keyup', onChange);
	    dom.bind(this.__input, 'change', onChange);
	    dom.bind(this.__input, 'blur', onBlur);
	    dom.bind(this.__input, 'keydown', function(e) {
	      if (e.keyCode === 13) {
	        this.blur();
	      }
	    });
	    
	
	    function onChange() {
	      _this.setValue(_this.__input.value);
	    }
	
	    function onBlur() {
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	
	    this.updateDisplay();
	
	    this.domElement.appendChild(this.__input);
	
	  };
	
	  StringController.superclass = Controller;
	
	  common.extend(
	
	      StringController.prototype,
	      Controller.prototype,
	
	      {
	
	        updateDisplay: function() {
	          // Stops the caret from moving on account of:
	          // keyup -> setValue -> updateDisplay
	          if (!dom.isActive(this.__input)) {
	            this.__input.value = this.getValue();
	          }
	          return StringController.superclass.prototype.updateDisplay.call(this);
	        }
	
	      }
	
	  );
	
	  return StringController;
	
	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.utils.common),
	dat.controllers.FunctionController,
	dat.controllers.BooleanController,
	dat.utils.common),
	dat.controllers.Controller,
	dat.controllers.BooleanController,
	dat.controllers.FunctionController,
	dat.controllers.NumberControllerBox,
	dat.controllers.NumberControllerSlider,
	dat.controllers.OptionController,
	dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {
	
	  var ColorController = function(object, property) {
	
	    ColorController.superclass.call(this, object, property);
	
	    this.__color = new Color(this.getValue());
	    this.__temp = new Color(0);
	
	    var _this = this;
	
	    this.domElement = document.createElement('div');
	
	    dom.makeSelectable(this.domElement, false);
	
	    this.__selector = document.createElement('div');
	    this.__selector.className = 'selector';
	
	    this.__saturation_field = document.createElement('div');
	    this.__saturation_field.className = 'saturation-field';
	
	    this.__field_knob = document.createElement('div');
	    this.__field_knob.className = 'field-knob';
	    this.__field_knob_border = '2px solid ';
	
	    this.__hue_knob = document.createElement('div');
	    this.__hue_knob.className = 'hue-knob';
	
	    this.__hue_field = document.createElement('div');
	    this.__hue_field.className = 'hue-field';
	
	    this.__input = document.createElement('input');
	    this.__input.type = 'text';
	    this.__input_textShadow = '0 1px 1px ';
	
	    dom.bind(this.__input, 'keydown', function(e) {
	      if (e.keyCode === 13) { // on enter
	        onBlur.call(this);
	      }
	    });
	
	    dom.bind(this.__input, 'blur', onBlur);
	
	    dom.bind(this.__selector, 'mousedown', function(e) {
	
	      dom
	        .addClass(this, 'drag')
	        .bind(window, 'mouseup', function(e) {
	          dom.removeClass(_this.__selector, 'drag');
	        });
	
	    });
	
	    var value_field = document.createElement('div');
	
	    common.extend(this.__selector.style, {
	      width: '122px',
	      height: '102px',
	      padding: '3px',
	      backgroundColor: '#222',
	      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
	    });
	
	    common.extend(this.__field_knob.style, {
	      position: 'absolute',
	      width: '12px',
	      height: '12px',
	      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
	      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
	      borderRadius: '12px',
	      zIndex: 1
	    });
	    
	    common.extend(this.__hue_knob.style, {
	      position: 'absolute',
	      width: '15px',
	      height: '2px',
	      borderRight: '4px solid #fff',
	      zIndex: 1
	    });
	
	    common.extend(this.__saturation_field.style, {
	      width: '100px',
	      height: '100px',
	      border: '1px solid #555',
	      marginRight: '3px',
	      display: 'inline-block',
	      cursor: 'pointer'
	    });
	
	    common.extend(value_field.style, {
	      width: '100%',
	      height: '100%',
	      background: 'none'
	    });
	    
	    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');
	
	    common.extend(this.__hue_field.style, {
	      width: '15px',
	      height: '100px',
	      display: 'inline-block',
	      border: '1px solid #555',
	      cursor: 'ns-resize'
	    });
	
	    hueGradient(this.__hue_field);
	
	    common.extend(this.__input.style, {
	      outline: 'none',
	//      width: '120px',
	      textAlign: 'center',
	//      padding: '4px',
	//      marginBottom: '6px',
	      color: '#fff',
	      border: 0,
	      fontWeight: 'bold',
	      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
	    });
	
	    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
	    dom.bind(this.__field_knob, 'mousedown', fieldDown);
	
	    dom.bind(this.__hue_field, 'mousedown', function(e) {
	      setH(e);
	      dom.bind(window, 'mousemove', setH);
	      dom.bind(window, 'mouseup', unbindH);
	    });
	
	    function fieldDown(e) {
	      setSV(e);
	      // document.body.style.cursor = 'none';
	      dom.bind(window, 'mousemove', setSV);
	      dom.bind(window, 'mouseup', unbindSV);
	    }
	
	    function unbindSV() {
	      dom.unbind(window, 'mousemove', setSV);
	      dom.unbind(window, 'mouseup', unbindSV);
	      // document.body.style.cursor = 'default';
	    }
	
	    function onBlur() {
	      var i = interpret(this.value);
	      if (i !== false) {
	        _this.__color.__state = i;
	        _this.setValue(_this.__color.toOriginal());
	      } else {
	        this.value = _this.__color.toString();
	      }
	    }
	
	    function unbindH() {
	      dom.unbind(window, 'mousemove', setH);
	      dom.unbind(window, 'mouseup', unbindH);
	    }
	
	    this.__saturation_field.appendChild(value_field);
	    this.__selector.appendChild(this.__field_knob);
	    this.__selector.appendChild(this.__saturation_field);
	    this.__selector.appendChild(this.__hue_field);
	    this.__hue_field.appendChild(this.__hue_knob);
	
	    this.domElement.appendChild(this.__input);
	    this.domElement.appendChild(this.__selector);
	
	    this.updateDisplay();
	
	    function setSV(e) {
	
	      e.preventDefault();
	
	      var w = dom.getWidth(_this.__saturation_field);
	      var o = dom.getOffset(_this.__saturation_field);
	      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
	      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;
	
	      if (v > 1) v = 1;
	      else if (v < 0) v = 0;
	
	      if (s > 1) s = 1;
	      else if (s < 0) s = 0;
	
	      _this.__color.v = v;
	      _this.__color.s = s;
	
	      _this.setValue(_this.__color.toOriginal());
	
	
	      return false;
	
	    }
	
	    function setH(e) {
	
	      e.preventDefault();
	
	      var s = dom.getHeight(_this.__hue_field);
	      var o = dom.getOffset(_this.__hue_field);
	      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;
	
	      if (h > 1) h = 1;
	      else if (h < 0) h = 0;
	
	      _this.__color.h = h * 360;
	
	      _this.setValue(_this.__color.toOriginal());
	
	      return false;
	
	    }
	
	  };
	
	  ColorController.superclass = Controller;
	
	  common.extend(
	
	      ColorController.prototype,
	      Controller.prototype,
	
	      {
	
	        updateDisplay: function() {
	
	          var i = interpret(this.getValue());
	
	          if (i !== false) {
	
	            var mismatch = false;
	
	            // Check for mismatch on the interpreted value.
	
	            common.each(Color.COMPONENTS, function(component) {
	              if (!common.isUndefined(i[component]) &&
	                  !common.isUndefined(this.__color.__state[component]) &&
	                  i[component] !== this.__color.__state[component]) {
	                mismatch = true;
	                return {}; // break
	              }
	            }, this);
	
	            // If nothing diverges, we keep our previous values
	            // for statefulness, otherwise we recalculate fresh
	            if (mismatch) {
	              common.extend(this.__color.__state, i);
	            }
	
	          }
	
	          common.extend(this.__temp.__state, this.__color.__state);
	
	          this.__temp.a = 1;
	
	          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
	          var _flip = 255 - flip;
	
	          common.extend(this.__field_knob.style, {
	            marginLeft: 100 * this.__color.s - 7 + 'px',
	            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
	            backgroundColor: this.__temp.toString(),
	            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
	          });
	
	          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'
	
	          this.__temp.s = 1;
	          this.__temp.v = 1;
	
	          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());
	
	          common.extend(this.__input.style, {
	            backgroundColor: this.__input.value = this.__color.toString(),
	            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
	            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
	          });
	
	        }
	
	      }
	
	  );
	  
	  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
	  
	  function linearGradient(elem, x, a, b) {
	    elem.style.background = '';
	    common.each(vendors, function(vendor) {
	      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
	    });
	  }
	  
	  function hueGradient(elem) {
	    elem.style.background = '';
	    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
	    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
	  }
	
	
	  return ColorController;
	
	})(dat.controllers.Controller,
	dat.dom.dom,
	dat.color.Color = (function (interpret, math, toString, common) {
	
	  var Color = function() {
	
	    this.__state = interpret.apply(this, arguments);
	
	    if (this.__state === false) {
	      throw 'Failed to interpret color arguments';
	    }
	
	    this.__state.a = this.__state.a || 1;
	
	
	  };
	
	  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];
	
	  common.extend(Color.prototype, {
	
	    toString: function() {
	      return toString(this);
	    },
	
	    toOriginal: function() {
	      return this.__state.conversion.write(this);
	    }
	
	  });
	
	  defineRGBComponent(Color.prototype, 'r', 2);
	  defineRGBComponent(Color.prototype, 'g', 1);
	  defineRGBComponent(Color.prototype, 'b', 0);
	
	  defineHSVComponent(Color.prototype, 'h');
	  defineHSVComponent(Color.prototype, 's');
	  defineHSVComponent(Color.prototype, 'v');
	
	  Object.defineProperty(Color.prototype, 'a', {
	
	    get: function() {
	      return this.__state.a;
	    },
	
	    set: function(v) {
	      this.__state.a = v;
	    }
	
	  });
	
	  Object.defineProperty(Color.prototype, 'hex', {
	
	    get: function() {
	
	      if (!this.__state.space !== 'HEX') {
	        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
	      }
	
	      return this.__state.hex;
	
	    },
	
	    set: function(v) {
	
	      this.__state.space = 'HEX';
	      this.__state.hex = v;
	
	    }
	
	  });
	
	  function defineRGBComponent(target, component, componentHexIndex) {
	
	    Object.defineProperty(target, component, {
	
	      get: function() {
	
	        if (this.__state.space === 'RGB') {
	          return this.__state[component];
	        }
	
	        recalculateRGB(this, component, componentHexIndex);
	
	        return this.__state[component];
	
	      },
	
	      set: function(v) {
	
	        if (this.__state.space !== 'RGB') {
	          recalculateRGB(this, component, componentHexIndex);
	          this.__state.space = 'RGB';
	        }
	
	        this.__state[component] = v;
	
	      }
	
	    });
	
	  }
	
	  function defineHSVComponent(target, component) {
	
	    Object.defineProperty(target, component, {
	
	      get: function() {
	
	        if (this.__state.space === 'HSV')
	          return this.__state[component];
	
	        recalculateHSV(this);
	
	        return this.__state[component];
	
	      },
	
	      set: function(v) {
	
	        if (this.__state.space !== 'HSV') {
	          recalculateHSV(this);
	          this.__state.space = 'HSV';
	        }
	
	        this.__state[component] = v;
	
	      }
	
	    });
	
	  }
	
	  function recalculateRGB(color, component, componentHexIndex) {
	
	    if (color.__state.space === 'HEX') {
	
	      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);
	
	    } else if (color.__state.space === 'HSV') {
	
	      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
	
	    } else {
	
	      throw 'Corrupted color state';
	
	    }
	
	  }
	
	  function recalculateHSV(color) {
	
	    var result = math.rgb_to_hsv(color.r, color.g, color.b);
	
	    common.extend(color.__state,
	        {
	          s: result.s,
	          v: result.v
	        }
	    );
	
	    if (!common.isNaN(result.h)) {
	      color.__state.h = result.h;
	    } else if (common.isUndefined(color.__state.h)) {
	      color.__state.h = 0;
	    }
	
	  }
	
	  return Color;
	
	})(dat.color.interpret,
	dat.color.math = (function () {
	
	  var tmpComponent;
	
	  return {
	
	    hsv_to_rgb: function(h, s, v) {
	
	      var hi = Math.floor(h / 60) % 6;
	
	      var f = h / 60 - Math.floor(h / 60);
	      var p = v * (1.0 - s);
	      var q = v * (1.0 - (f * s));
	      var t = v * (1.0 - ((1.0 - f) * s));
	      var c = [
	        [v, t, p],
	        [q, v, p],
	        [p, v, t],
	        [p, q, v],
	        [t, p, v],
	        [v, p, q]
	      ][hi];
	
	      return {
	        r: c[0] * 255,
	        g: c[1] * 255,
	        b: c[2] * 255
	      };
	
	    },
	
	    rgb_to_hsv: function(r, g, b) {
	
	      var min = Math.min(r, g, b),
	          max = Math.max(r, g, b),
	          delta = max - min,
	          h, s;
	
	      if (max != 0) {
	        s = delta / max;
	      } else {
	        return {
	          h: NaN,
	          s: 0,
	          v: 0
	        };
	      }
	
	      if (r == max) {
	        h = (g - b) / delta;
	      } else if (g == max) {
	        h = 2 + (b - r) / delta;
	      } else {
	        h = 4 + (r - g) / delta;
	      }
	      h /= 6;
	      if (h < 0) {
	        h += 1;
	      }
	
	      return {
	        h: h * 360,
	        s: s,
	        v: max / 255
	      };
	    },
	
	    rgb_to_hex: function(r, g, b) {
	      var hex = this.hex_with_component(0, 2, r);
	      hex = this.hex_with_component(hex, 1, g);
	      hex = this.hex_with_component(hex, 0, b);
	      return hex;
	    },
	
	    component_from_hex: function(hex, componentIndex) {
	      return (hex >> (componentIndex * 8)) & 0xFF;
	    },
	
	    hex_with_component: function(hex, componentIndex, value) {
	      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
	    }
	
	  }
	
	})(),
	dat.color.toString,
	dat.utils.common),
	dat.color.interpret,
	dat.utils.common),
	dat.utils.requestAnimationFrame = (function () {
	
	  /**
	   * requirejs version of Paul Irish's RequestAnimationFrame
	   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	   */
	
	  return window.webkitRequestAnimationFrame ||
	      window.mozRequestAnimationFrame ||
	      window.oRequestAnimationFrame ||
	      window.msRequestAnimationFrame ||
	      function(callback, element) {
	
	        window.setTimeout(callback, 1000 / 60);
	
	      };
	})(),
	dat.dom.CenteredDiv = (function (dom, common) {
	
	
	  var CenteredDiv = function() {
	
	    this.backgroundElement = document.createElement('div');
	    common.extend(this.backgroundElement.style, {
	      backgroundColor: 'rgba(0,0,0,0.8)',
	      top: 0,
	      left: 0,
	      display: 'none',
	      zIndex: '1000',
	      opacity: 0,
	      WebkitTransition: 'opacity 0.2s linear'
	    });
	
	    dom.makeFullscreen(this.backgroundElement);
	    this.backgroundElement.style.position = 'fixed';
	
	    this.domElement = document.createElement('div');
	    common.extend(this.domElement.style, {
	      position: 'fixed',
	      display: 'none',
	      zIndex: '1001',
	      opacity: 0,
	      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
	    });
	
	
	    document.body.appendChild(this.backgroundElement);
	    document.body.appendChild(this.domElement);
	
	    var _this = this;
	    dom.bind(this.backgroundElement, 'click', function() {
	      _this.hide();
	    });
	
	
	  };
	
	  CenteredDiv.prototype.show = function() {
	
	    var _this = this;
	    
	
	
	    this.backgroundElement.style.display = 'block';
	
	    this.domElement.style.display = 'block';
	    this.domElement.style.opacity = 0;
	//    this.domElement.style.top = '52%';
	    this.domElement.style.webkitTransform = 'scale(1.1)';
	
	    this.layout();
	
	    common.defer(function() {
	      _this.backgroundElement.style.opacity = 1;
	      _this.domElement.style.opacity = 1;
	      _this.domElement.style.webkitTransform = 'scale(1)';
	    });
	
	  };
	
	  CenteredDiv.prototype.hide = function() {
	
	    var _this = this;
	
	    var hide = function() {
	
	      _this.domElement.style.display = 'none';
	      _this.backgroundElement.style.display = 'none';
	
	      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
	      dom.unbind(_this.domElement, 'transitionend', hide);
	      dom.unbind(_this.domElement, 'oTransitionEnd', hide);
	
	    };
	
	    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
	    dom.bind(this.domElement, 'transitionend', hide);
	    dom.bind(this.domElement, 'oTransitionEnd', hide);
	
	    this.backgroundElement.style.opacity = 0;
	//    this.domElement.style.top = '48%';
	    this.domElement.style.opacity = 0;
	    this.domElement.style.webkitTransform = 'scale(1.1)';
	
	  };
	
	  CenteredDiv.prototype.layout = function() {
	    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
	    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
	  };
	  
	  function lockScroll(e) {
	    console.log(e);
	  }
	
	  return CenteredDiv;
	
	})(dat.dom.dom,
	dat.utils.common),
	dat.dom.dom,
	dat.utils.common);

/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * dat-gui JavaScript Controller Library
	 * http://code.google.com/p/dat-gui
	 *
	 * Copyright 2011 Data Arts Team, Google Creative Lab
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */
	
	/** @namespace */
	var dat = module.exports = dat || {};
	
	/** @namespace */
	dat.color = dat.color || {};
	
	/** @namespace */
	dat.utils = dat.utils || {};
	
	dat.utils.common = (function () {
	  
	  var ARR_EACH = Array.prototype.forEach;
	  var ARR_SLICE = Array.prototype.slice;
	
	  /**
	   * Band-aid methods for things that should be a lot easier in JavaScript.
	   * Implementation and structure inspired by underscore.js
	   * http://documentcloud.github.com/underscore/
	   */
	
	  return { 
	    
	    BREAK: {},
	  
	    extend: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (!this.isUndefined(obj[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	      
	    },
	    
	    defaults: function(target) {
	      
	      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
	        
	        for (var key in obj)
	          if (this.isUndefined(target[key])) 
	            target[key] = obj[key];
	        
	      }, this);
	      
	      return target;
	    
	    },
	    
	    compose: function() {
	      var toCall = ARR_SLICE.call(arguments);
	            return function() {
	              var args = ARR_SLICE.call(arguments);
	              for (var i = toCall.length -1; i >= 0; i--) {
	                args = [toCall[i].apply(this, args)];
	              }
	              return args[0];
	            }
	    },
	    
	    each: function(obj, itr, scope) {
	
	      
	      if (ARR_EACH && obj.forEach === ARR_EACH) { 
	        
	        obj.forEach(itr, scope);
	        
	      } else if (obj.length === obj.length + 0) { // Is number but not NaN
	        
	        for (var key = 0, l = obj.length; key < l; key++)
	          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
	            return;
	            
	      } else {
	
	        for (var key in obj) 
	          if (itr.call(scope, obj[key], key) === this.BREAK)
	            return;
	            
	      }
	            
	    },
	    
	    defer: function(fnc) {
	      setTimeout(fnc, 0);
	    },
	    
	    toArray: function(obj) {
	      if (obj.toArray) return obj.toArray();
	      return ARR_SLICE.call(obj);
	    },
	
	    isUndefined: function(obj) {
	      return obj === undefined;
	    },
	    
	    isNull: function(obj) {
	      return obj === null;
	    },
	    
	    isNaN: function(obj) {
	      return obj !== obj;
	    },
	    
	    isArray: Array.isArray || function(obj) {
	      return obj.constructor === Array;
	    },
	    
	    isObject: function(obj) {
	      return obj === Object(obj);
	    },
	    
	    isNumber: function(obj) {
	      return obj === obj+0;
	    },
	    
	    isString: function(obj) {
	      return obj === obj+'';
	    },
	    
	    isBoolean: function(obj) {
	      return obj === false || obj === true;
	    },
	    
	    isFunction: function(obj) {
	      return Object.prototype.toString.call(obj) === '[object Function]';
	    }
	  
	  };
	    
	})();
	
	
	dat.color.toString = (function (common) {
	
	  return function(color) {
	
	    if (color.a == 1 || common.isUndefined(color.a)) {
	
	      var s = color.hex.toString(16);
	      while (s.length < 6) {
	        s = '0' + s;
	      }
	
	      return '#' + s;
	
	    } else {
	
	      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';
	
	    }
	
	  }
	
	})(dat.utils.common);
	
	
	dat.Color = dat.color.Color = (function (interpret, math, toString, common) {
	
	  var Color = function() {
	
	    this.__state = interpret.apply(this, arguments);
	
	    if (this.__state === false) {
	      throw 'Failed to interpret color arguments';
	    }
	
	    this.__state.a = this.__state.a || 1;
	
	
	  };
	
	  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];
	
	  common.extend(Color.prototype, {
	
	    toString: function() {
	      return toString(this);
	    },
	
	    toOriginal: function() {
	      return this.__state.conversion.write(this);
	    }
	
	  });
	
	  defineRGBComponent(Color.prototype, 'r', 2);
	  defineRGBComponent(Color.prototype, 'g', 1);
	  defineRGBComponent(Color.prototype, 'b', 0);
	
	  defineHSVComponent(Color.prototype, 'h');
	  defineHSVComponent(Color.prototype, 's');
	  defineHSVComponent(Color.prototype, 'v');
	
	  Object.defineProperty(Color.prototype, 'a', {
	
	    get: function() {
	      return this.__state.a;
	    },
	
	    set: function(v) {
	      this.__state.a = v;
	    }
	
	  });
	
	  Object.defineProperty(Color.prototype, 'hex', {
	
	    get: function() {
	
	      if (!this.__state.space !== 'HEX') {
	        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
	      }
	
	      return this.__state.hex;
	
	    },
	
	    set: function(v) {
	
	      this.__state.space = 'HEX';
	      this.__state.hex = v;
	
	    }
	
	  });
	
	  function defineRGBComponent(target, component, componentHexIndex) {
	
	    Object.defineProperty(target, component, {
	
	      get: function() {
	
	        if (this.__state.space === 'RGB') {
	          return this.__state[component];
	        }
	
	        recalculateRGB(this, component, componentHexIndex);
	
	        return this.__state[component];
	
	      },
	
	      set: function(v) {
	
	        if (this.__state.space !== 'RGB') {
	          recalculateRGB(this, component, componentHexIndex);
	          this.__state.space = 'RGB';
	        }
	
	        this.__state[component] = v;
	
	      }
	
	    });
	
	  }
	
	  function defineHSVComponent(target, component) {
	
	    Object.defineProperty(target, component, {
	
	      get: function() {
	
	        if (this.__state.space === 'HSV')
	          return this.__state[component];
	
	        recalculateHSV(this);
	
	        return this.__state[component];
	
	      },
	
	      set: function(v) {
	
	        if (this.__state.space !== 'HSV') {
	          recalculateHSV(this);
	          this.__state.space = 'HSV';
	        }
	
	        this.__state[component] = v;
	
	      }
	
	    });
	
	  }
	
	  function recalculateRGB(color, component, componentHexIndex) {
	
	    if (color.__state.space === 'HEX') {
	
	      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);
	
	    } else if (color.__state.space === 'HSV') {
	
	      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
	
	    } else {
	
	      throw 'Corrupted color state';
	
	    }
	
	  }
	
	  function recalculateHSV(color) {
	
	    var result = math.rgb_to_hsv(color.r, color.g, color.b);
	
	    common.extend(color.__state,
	        {
	          s: result.s,
	          v: result.v
	        }
	    );
	
	    if (!common.isNaN(result.h)) {
	      color.__state.h = result.h;
	    } else if (common.isUndefined(color.__state.h)) {
	      color.__state.h = 0;
	    }
	
	  }
	
	  return Color;
	
	})(dat.color.interpret = (function (toString, common) {
	
	  var result, toReturn;
	
	  var interpret = function() {
	
	    toReturn = false;
	
	    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];
	
	    common.each(INTERPRETATIONS, function(family) {
	
	      if (family.litmus(original)) {
	
	        common.each(family.conversions, function(conversion, conversionName) {
	
	          result = conversion.read(original);
	
	          if (toReturn === false && result !== false) {
	            toReturn = result;
	            result.conversionName = conversionName;
	            result.conversion = conversion;
	            return common.BREAK;
	
	          }
	
	        });
	
	        return common.BREAK;
	
	      }
	
	    });
	
	    return toReturn;
	
	  };
	
	  var INTERPRETATIONS = [
	
	    // Strings
	    {
	
	      litmus: common.isString,
	
	      conversions: {
	
	        THREE_CHAR_HEX: {
	
	          read: function(original) {
	
	            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
	            if (test === null) return false;
	
	            return {
	              space: 'HEX',
	              hex: parseInt(
	                  '0x' +
	                      test[1].toString() + test[1].toString() +
	                      test[2].toString() + test[2].toString() +
	                      test[3].toString() + test[3].toString())
	            };
	
	          },
	
	          write: toString
	
	        },
	
	        SIX_CHAR_HEX: {
	
	          read: function(original) {
	
	            var test = original.match(/^#([A-F0-9]{6})$/i);
	            if (test === null) return false;
	
	            return {
	              space: 'HEX',
	              hex: parseInt('0x' + test[1].toString())
	            };
	
	          },
	
	          write: toString
	
	        },
	
	        CSS_RGB: {
	
	          read: function(original) {
	
	            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
	            if (test === null) return false;
	
	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3])
	            };
	
	          },
	
	          write: toString
	
	        },
	
	        CSS_RGBA: {
	
	          read: function(original) {
	
	            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
	            if (test === null) return false;
	
	            return {
	              space: 'RGB',
	              r: parseFloat(test[1]),
	              g: parseFloat(test[2]),
	              b: parseFloat(test[3]),
	              a: parseFloat(test[4])
	            };
	
	          },
	
	          write: toString
	
	        }
	
	      }
	
	    },
	
	    // Numbers
	    {
	
	      litmus: common.isNumber,
	
	      conversions: {
	
	        HEX: {
	          read: function(original) {
	            return {
	              space: 'HEX',
	              hex: original,
	              conversionName: 'HEX'
	            }
	          },
	
	          write: function(color) {
	            return color.hex;
	          }
	        }
	
	      }
	
	    },
	
	    // Arrays
	    {
	
	      litmus: common.isArray,
	
	      conversions: {
	
	        RGB_ARRAY: {
	          read: function(original) {
	            if (original.length != 3) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2]
	            };
	          },
	
	          write: function(color) {
	            return [color.r, color.g, color.b];
	          }
	
	        },
	
	        RGBA_ARRAY: {
	          read: function(original) {
	            if (original.length != 4) return false;
	            return {
	              space: 'RGB',
	              r: original[0],
	              g: original[1],
	              b: original[2],
	              a: original[3]
	            };
	          },
	
	          write: function(color) {
	            return [color.r, color.g, color.b, color.a];
	          }
	
	        }
	
	      }
	
	    },
	
	    // Objects
	    {
	
	      litmus: common.isObject,
	
	      conversions: {
	
	        RGBA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b,
	                a: original.a
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b,
	              a: color.a
	            }
	          }
	        },
	
	        RGB_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.r) &&
	                common.isNumber(original.g) &&
	                common.isNumber(original.b)) {
	              return {
	                space: 'RGB',
	                r: original.r,
	                g: original.g,
	                b: original.b
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              r: color.r,
	              g: color.g,
	              b: color.b
	            }
	          }
	        },
	
	        HSVA_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v) &&
	                common.isNumber(original.a)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v,
	                a: original.a
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v,
	              a: color.a
	            }
	          }
	        },
	
	        HSV_OBJ: {
	          read: function(original) {
	            if (common.isNumber(original.h) &&
	                common.isNumber(original.s) &&
	                common.isNumber(original.v)) {
	              return {
	                space: 'HSV',
	                h: original.h,
	                s: original.s,
	                v: original.v
	              }
	            }
	            return false;
	          },
	
	          write: function(color) {
	            return {
	              h: color.h,
	              s: color.s,
	              v: color.v
	            }
	          }
	
	        }
	
	      }
	
	    }
	
	
	  ];
	
	  return interpret;
	
	
	})(dat.color.toString,
	dat.utils.common),
	dat.color.math = (function () {
	
	  var tmpComponent;
	
	  return {
	
	    hsv_to_rgb: function(h, s, v) {
	
	      var hi = Math.floor(h / 60) % 6;
	
	      var f = h / 60 - Math.floor(h / 60);
	      var p = v * (1.0 - s);
	      var q = v * (1.0 - (f * s));
	      var t = v * (1.0 - ((1.0 - f) * s));
	      var c = [
	        [v, t, p],
	        [q, v, p],
	        [p, v, t],
	        [p, q, v],
	        [t, p, v],
	        [v, p, q]
	      ][hi];
	
	      return {
	        r: c[0] * 255,
	        g: c[1] * 255,
	        b: c[2] * 255
	      };
	
	    },
	
	    rgb_to_hsv: function(r, g, b) {
	
	      var min = Math.min(r, g, b),
	          max = Math.max(r, g, b),
	          delta = max - min,
	          h, s;
	
	      if (max != 0) {
	        s = delta / max;
	      } else {
	        return {
	          h: NaN,
	          s: 0,
	          v: 0
	        };
	      }
	
	      if (r == max) {
	        h = (g - b) / delta;
	      } else if (g == max) {
	        h = 2 + (b - r) / delta;
	      } else {
	        h = 4 + (r - g) / delta;
	      }
	      h /= 6;
	      if (h < 0) {
	        h += 1;
	      }
	
	      return {
	        h: h * 360,
	        s: s,
	        v: max / 255
	      };
	    },
	
	    rgb_to_hex: function(r, g, b) {
	      var hex = this.hex_with_component(0, 2, r);
	      hex = this.hex_with_component(hex, 1, g);
	      hex = this.hex_with_component(hex, 0, b);
	      return hex;
	    },
	
	    component_from_hex: function(hex, componentIndex) {
	      return (hex >> (componentIndex * 8)) & 0xFF;
	    },
	
	    hex_with_component: function(hex, componentIndex, value) {
	      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
	    }
	
	  }
	
	})(),
	dat.color.toString,
	dat.utils.common);

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';
	
		// Polyfills
	
		if ( Number.EPSILON === undefined ) {
	
			Number.EPSILON = Math.pow( 2, - 52 );
	
		}
	
		//
	
		if ( Math.sign === undefined ) {
	
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
			Math.sign = function ( x ) {
	
				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
			};
	
		}
	
		if ( Function.prototype.name === undefined ) {
	
			// Missing in IE9-11.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
			Object.defineProperty( Function.prototype, 'name', {
	
				get: function () {
	
					return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];
	
				}
	
			} );
	
		}
	
		if ( Object.assign === undefined ) {
	
			// Missing in IE.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
			( function () {
	
				Object.assign = function ( target ) {
	
					'use strict';
	
					if ( target === undefined || target === null ) {
	
						throw new TypeError( 'Cannot convert undefined or null to object' );
	
					}
	
					var output = Object( target );
	
					for ( var index = 1; index < arguments.length; index ++ ) {
	
						var source = arguments[ index ];
	
						if ( source !== undefined && source !== null ) {
	
							for ( var nextKey in source ) {
	
								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
	
									output[ nextKey ] = source[ nextKey ];
	
								}
	
							}
	
						}
	
					}
	
					return output;
	
				};
	
			} )();
	
		}
	
		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */
	
		function EventDispatcher() {}
	
		Object.assign( EventDispatcher.prototype, {
	
			addEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) this._listeners = {};
	
				var listeners = this._listeners;
	
				if ( listeners[ type ] === undefined ) {
	
					listeners[ type ] = [];
	
				}
	
				if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
					listeners[ type ].push( listener );
	
				}
	
			},
	
			hasEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return false;
	
				var listeners = this._listeners;
	
				if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	
					return true;
	
				}
	
				return false;
	
			},
	
			removeEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ type ];
	
				if ( listenerArray !== undefined ) {
	
					var index = listenerArray.indexOf( listener );
	
					if ( index !== - 1 ) {
	
						listenerArray.splice( index, 1 );
	
					}
	
				}
	
			},
	
			dispatchEvent: function ( event ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];
	
				if ( listenerArray !== undefined ) {
	
					event.target = this;
	
					var array = [], i = 0;
					var length = listenerArray.length;
	
					for ( i = 0; i < length; i ++ ) {
	
						array[ i ] = listenerArray[ i ];
	
					}
	
					for ( i = 0; i < length; i ++ ) {
	
						array[ i ].call( this, event );
	
					}
	
				}
	
			}
	
		} );
	
		var REVISION = '82';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var BlendingMode = {
			NoBlending: NoBlending,
			NormalBlending: NormalBlending,
			AdditiveBlending: AdditiveBlending,
			SubtractiveBlending: SubtractiveBlending,
			MultiplyBlending: MultiplyBlending,
			CustomBlending: CustomBlending
		};
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var TextureMapping = {
			UVMapping: UVMapping,
			CubeReflectionMapping: CubeReflectionMapping,
			CubeRefractionMapping: CubeRefractionMapping,
			EquirectangularReflectionMapping: EquirectangularReflectionMapping,
			EquirectangularRefractionMapping: EquirectangularRefractionMapping,
			SphericalReflectionMapping: SphericalReflectionMapping,
			CubeUVReflectionMapping: CubeUVReflectionMapping,
			CubeUVRefractionMapping: CubeUVRefractionMapping
		};
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var TextureWrapping = {
			RepeatWrapping: RepeatWrapping,
			ClampToEdgeWrapping: ClampToEdgeWrapping,
			MirroredRepeatWrapping: MirroredRepeatWrapping
		};
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var TextureFilter = {
			NearestFilter: NearestFilter,
			NearestMipMapNearestFilter: NearestMipMapNearestFilter,
			NearestMipMapLinearFilter: NearestMipMapLinearFilter,
			LinearFilter: LinearFilter,
			LinearMipMapNearestFilter: LinearMipMapNearestFilter,
			LinearMipMapLinearFilter: LinearMipMapLinearFilter
		};
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var _Math = {
	
			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,
	
			generateUUID: function () {
	
				// http://www.broofa.com/Tools/Math.uuid.htm
	
				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;
	
				return function generateUUID() {
	
					for ( var i = 0; i < 36; i ++ ) {
	
						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
							uuid[ i ] = '-';
	
						} else if ( i === 14 ) {
	
							uuid[ i ] = '4';
	
						} else {
	
							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
						}
	
					}
	
					return uuid.join( '' );
	
				};
	
			}(),
	
			clamp: function ( value, min, max ) {
	
				return Math.max( min, Math.min( max, value ) );
	
			},
	
			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation
	
			euclideanModulo: function ( n, m ) {
	
				return ( ( n % m ) + m ) % m;
	
			},
	
			// Linear mapping from range <a1, a2> to range <b1, b2>
	
			mapLinear: function ( x, a1, a2, b1, b2 ) {
	
				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
			},
	
			// https://en.wikipedia.org/wiki/Linear_interpolation
	
			lerp: function ( x, y, t ) {
	
				return ( 1 - t ) * x + t * y;
	
			},
	
			// http://en.wikipedia.org/wiki/Smoothstep
	
			smoothstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * ( 3 - 2 * x );
	
			},
	
			smootherstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
			},
	
			random16: function () {
	
				console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
				return Math.random();
	
			},
	
			// Random integer from <low, high> interval
	
			randInt: function ( low, high ) {
	
				return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
			},
	
			// Random float from <low, high> interval
	
			randFloat: function ( low, high ) {
	
				return low + Math.random() * ( high - low );
	
			},
	
			// Random float from <-range/2, range/2> interval
	
			randFloatSpread: function ( range ) {
	
				return range * ( 0.5 - Math.random() );
	
			},
	
			degToRad: function ( degrees ) {
	
				return degrees * _Math.DEG2RAD;
	
			},
	
			radToDeg: function ( radians ) {
	
				return radians * _Math.RAD2DEG;
	
			},
	
			isPowerOfTwo: function ( value ) {
	
				return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
			},
	
			nearestPowerOfTwo: function ( value ) {
	
				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
			},
	
			nextPowerOfTwo: function ( value ) {
	
				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;
	
				return value;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		function Vector2( x, y ) {
	
			this.x = x || 0;
			this.y = y || 0;
	
		}
	
		Vector2.prototype = {
	
			constructor: Vector2,
	
			isVector2: true,
	
			get width() {
	
				return this.x;
	
			},
	
			set width( value ) {
	
				this.x = value;
	
			},
	
			get height() {
	
				return this.y;
	
			},
	
			set height( value ) {
	
				this.y = value;
	
			},
	
			//
	
			set: function ( x, y ) {
	
				this.x = x;
				this.y = y;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
				
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
	
				return this;
	
			},
	
			multiply: function ( v ) {
	
				this.x *= v.x;
				this.y *= v.y;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
	
				}
	
				return this;
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector2();
						max = new Vector2();
	
					}
	
					min.set( minVal, minVal );
					max.set( maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y );
	
			},
	
			lengthManhattan: function() {
	
				return Math.abs( this.x ) + Math.abs( this.y );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			angle: function () {
	
				// computes the angle in radians with respect to the positive x-axis
	
				var angle = Math.atan2( this.y, this.x );
	
				if ( angle < 0 ) angle += 2 * Math.PI;
	
				return angle;
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
	
				return array;
	
			},
	
			fromAttribute: function ( attribute, index, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				index = index * attribute.itemSize + offset;
	
				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
	
				return this;
	
			},
	
			rotateAround: function ( center, angle ) {
	
				var c = Math.cos( angle ), s = Math.sin( angle );
	
				var x = this.x - center.x;
				var y = this.y - center.y;
	
				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */
	
		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			Object.defineProperty( this, 'id', { value: TextureIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.sourceFile = '';
	
			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];
	
			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	
			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
	
			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;
	
			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
	
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
	
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding :  LinearEncoding;
	
			this.version = 0;
			this.onUpdate = null;
	
		}
	
		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;
	
		Texture.prototype = {
	
			constructor: Texture,
	
			isTexture: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );
	
				this.mapping = source.mapping;
	
				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;
	
				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;
	
				this.anisotropy = source.anisotropy;
	
				this.format = source.format;
				this.type = source.type;
	
				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );
	
				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				if ( meta.textures[ this.uuid ] !== undefined ) {
	
					return meta.textures[ this.uuid ];
	
				}
	
				function getDataURL( image ) {
	
					var canvas;
	
					if ( image.toDataURL !== undefined ) {
	
						canvas = image;
	
					} else {
	
						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;
	
						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
					}
	
					if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
						return canvas.toDataURL( 'image/jpeg', 0.6 );
	
					} else {
	
						return canvas.toDataURL( 'image/png' );
	
					}
	
				}
	
				var output = {
					metadata: {
						version: 4.4,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},
	
					uuid: this.uuid,
					name: this.name,
	
					mapping: this.mapping,
	
					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],
	
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
	
					flipY: this.flipY
				};
	
				if ( this.image !== undefined ) {
	
					// TODO: Move to THREE.Image
	
					var image = this.image;
	
					if ( image.uuid === undefined ) {
	
						image.uuid = _Math.generateUUID(); // UGH
	
					}
	
					if ( meta.images[ image.uuid ] === undefined ) {
	
						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};
	
					}
	
					output.image = image.uuid;
	
				}
	
				meta.textures[ this.uuid ] = output;
	
				return output;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			},
	
			transformUv: function ( uv ) {
	
				if ( this.mapping !== UVMapping )  return;
	
				uv.multiply( this.repeat );
				uv.add( this.offset );
	
				if ( uv.x < 0 || uv.x > 1 ) {
	
					switch ( this.wrapS ) {
	
						case RepeatWrapping:
	
							uv.x = uv.x - Math.floor( uv.x );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.x = uv.x < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
								uv.x = Math.ceil( uv.x ) - uv.x;
	
							} else {
	
								uv.x = uv.x - Math.floor( uv.x );
	
							}
							break;
	
					}
	
				}
	
				if ( uv.y < 0 || uv.y > 1 ) {
	
					switch ( this.wrapT ) {
	
						case RepeatWrapping:
	
							uv.y = uv.y - Math.floor( uv.y );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.y = uv.y < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
								uv.y = Math.ceil( uv.y ) - uv.y;
	
							} else {
	
								uv.y = uv.y - Math.floor( uv.y );
	
							}
							break;
	
					}
	
				}
	
				if ( this.flipY ) {
	
					uv.y = 1 - uv.y;
	
				}
	
			}
	
		};
	
		Object.assign( Texture.prototype, EventDispatcher.prototype );
	
		var count = 0;
		function TextureIdCount() { return count++; }
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector4( x, y, z, w ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;
	
		}
	
		Vector4.prototype = {
	
			constructor: Vector4,
	
			isVector4: true,
	
			set: function ( x, y, z, w ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setW: function ( w ) {
	
				this.w = w;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
				
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z, this.w );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
					this.w *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
					this.z = 0;
					this.w = 0;
	
				}
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			setAxisAngleFromQuaternion: function ( q ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
				// q is assumed to be normalized
	
				this.w = 2 * Math.acos( q.w );
	
				var s = Math.sqrt( 1 - q.w * q.w );
	
				if ( s < 0.0001 ) {
	
					 this.x = 1;
					 this.y = 0;
					 this.z = 0;
	
				} else {
	
					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;
	
				}
	
				return this;
	
			},
	
			setAxisAngleFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
					te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms
	
					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
						// this singularity is identity matrix so angle = 0
	
						this.set( 1, 0, 0, 0 );
	
						return this; // zero angle, arbitrary axis
	
					}
	
					// otherwise this singularity is angle = 180
	
					angle = Math.PI;
	
					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;
	
					if ( ( xx > yy ) && ( xx > zz ) ) {
	
						// m11 is the largest diagonal term
	
						if ( xx < epsilon ) {
	
							x = 0;
							y = 0.707106781;
							z = 0.707106781;
	
						} else {
	
							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;
	
						}
	
					} else if ( yy > zz ) {
	
						// m22 is the largest diagonal term
	
						if ( yy < epsilon ) {
	
							x = 0.707106781;
							y = 0;
							z = 0.707106781;
	
						} else {
	
							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;
	
						}
	
					} else {
	
						// m33 is the largest diagonal term so base result on this
	
						if ( zz < epsilon ) {
	
							x = 0.707106781;
							y = 0.707106781;
							z = 0;
	
						} else {
	
							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;
	
						}
	
					}
	
					this.set( x, y, z, angle );
	
					return this; // return 180 deg rotation
	
				}
	
				// as we have reached here there are no singularities so we can handle normally
	
				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
				if ( Math.abs( s ) < 0.001 ) s = 1;
	
				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case
	
				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
				return this;
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector4();
						max = new Vector4();
	
					}
	
					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;
	
				return array;
	
			},
	
			fromAttribute: function ( attribute, index, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				index = index * attribute.itemSize + offset;
	
				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
				this.z = attribute.array[ index + 2 ];
				this.w = attribute.array[ index + 3 ];
	
				return this;
	
			}
	
		};
	
		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */
	
		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {
	
			this.uuid = _Math.generateUUID();
	
			this.width = width;
			this.height = height;
	
			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;
	
			this.viewport = new Vector4( 0, 0, width, height );
	
			options = options || {};
	
			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;
	
			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	
		}
	
		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {
	
			isWebGLRenderTarget: true,
	
			setSize: function ( width, height ) {
	
				if ( this.width !== width || this.height !== height ) {
	
					this.width = width;
					this.height = height;
	
					this.dispose();
	
				}
	
				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.width = source.width;
				this.height = source.height;
	
				this.viewport.copy( source.viewport );
	
				this.texture = source.texture.clone();
	
				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com
		 */
	
		function WebGLRenderTargetCube( width, height, options ) {
	
			WebGLRenderTarget.call( this, width, height, options );
	
			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;
	
		}
	
		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
	
		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Quaternion( x, y, z, w ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;
	
		}
	
		Quaternion.prototype = {
	
			constructor: Quaternion,
	
			get x () {
	
				return this._x;
	
			},
	
			set x ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			},
	
			get y () {
	
				return this._y;
	
			},
	
			set y ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			},
	
			get z () {
	
				return this._z;
	
			},
	
			set z ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			},
	
			get w () {
	
				return this._w;
	
			},
	
			set w ( value ) {
	
				this._w = value;
				this.onChangeCallback();
	
			},
	
			set: function ( x, y, z, w ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._w );
	
			},
	
			copy: function ( quaternion ) {
	
				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromEuler: function ( euler, update ) {
	
				if ( (euler && euler.isEuler) === false ) {
	
					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m
	
				var c1 = Math.cos( euler._x / 2 );
				var c2 = Math.cos( euler._y / 2 );
				var c3 = Math.cos( euler._z / 2 );
				var s1 = Math.sin( euler._x / 2 );
				var s2 = Math.sin( euler._y / 2 );
				var s3 = Math.sin( euler._z / 2 );
	
				var order = euler.order;
	
				if ( order === 'XYZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'YXZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'ZXY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'ZYX' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'YZX' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'XZY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				}
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromAxisAngle: function ( axis, angle ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
				// assumes axis is normalized
	
				var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
					trace = m11 + m22 + m33,
					s;
	
				if ( trace > 0 ) {
	
					s = 0.5 / Math.sqrt( trace + 1.0 );
	
					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;
	
				} else if ( m11 > m22 && m11 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;
	
				} else if ( m22 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;
	
				} else {
	
					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromUnitVectors: function () {
	
				// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
				// assumes direction vectors vFrom and vTo are normalized
	
				var v1, r;
	
				var EPS = 0.000001;
	
				return function setFromUnitVectors( vFrom, vTo ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					r = vFrom.dot( vTo ) + 1;
	
					if ( r < EPS ) {
	
						r = 0;
	
						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
							v1.set( - vFrom.y, vFrom.x, 0 );
	
						} else {
	
							v1.set( 0, - vFrom.z, vFrom.y );
	
						}
	
					} else {
	
						v1.crossVectors( vFrom, vTo );
	
					}
	
					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;
	
					return this.normalize();
	
				};
	
			}(),
	
			inverse: function () {
	
				return this.conjugate().normalize();
	
			},
	
			conjugate: function () {
	
				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
			},
	
			lengthSq: function () {
	
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
			},
	
			normalize: function () {
	
				var l = this.length();
	
				if ( l === 0 ) {
	
					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;
	
				} else {
	
					l = 1 / l;
	
					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			multiply: function ( q, p ) {
	
				if ( p !== undefined ) {
	
					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );
	
				}
	
				return this.multiplyQuaternions( this, q );
	
			},
	
			premultiply: function ( q ) {
	
				return this.multiplyQuaternions( q, this );
	
			},
	
			multiplyQuaternions: function ( a, b ) {
	
				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			slerp: function ( qb, t ) {
	
				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );
	
				var x = this._x, y = this._y, z = this._z, w = this._w;
	
				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
				if ( cosHalfTheta < 0 ) {
	
					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;
	
					cosHalfTheta = - cosHalfTheta;
	
				} else {
	
					this.copy( qb );
	
				}
	
				if ( cosHalfTheta >= 1.0 ) {
	
					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;
	
					return this;
	
				}
	
				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
				if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );
	
					return this;
	
				}
	
				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			equals: function ( quaternion ) {
	
				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;
	
				return array;
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		};
	
		Object.assign( Quaternion, {
	
			slerp: function( qa, qb, qm, t ) {
	
				return qm.copy( qa ).slerp( qb, t );
	
			},
	
			slerpFlat: function(
					dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
				// fuzz-free, array-based Quaternion SLERP operation
	
				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],
	
					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];
	
				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
					var s = 1 - t,
	
						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;
	
					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {
	
						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );
	
						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;
	
					}
	
					var tDir = t * dir;
	
					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;
	
					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {
	
						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;
	
					}
	
				}
	
				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector3( x, y, z ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
	
		}
	
		Vector3.prototype = {
	
			constructor: Vector3,
	
			isVector3: true,
	
			set: function ( x, y, z ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
				
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
	
				return this;
	
			},
	
			multiply: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );
	
				}
	
				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
					this.z = 0;
	
				}
	
				return this;
	
			},
	
			multiplyVectors: function ( a, b ) {
	
				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;
	
				return this;
	
			},
	
			applyEuler: function () {
	
				var quaternion;
	
				return function applyEuler( euler ) {
	
					if ( (euler && euler.isEuler) === false ) {
	
						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
					}
	
					if ( quaternion === undefined ) quaternion = new Quaternion();
	
					return this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				};
	
			}(),
	
			applyAxisAngle: function () {
	
				var quaternion;
	
				return function applyAxisAngle( axis, angle ) {
	
					if ( quaternion === undefined ) quaternion = new Quaternion();
	
					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				};
	
			}(),
	
			applyMatrix3: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				// input: THREE.Matrix4 affine matrix
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
	
				return this;
	
			},
	
			applyProjection: function ( m ) {
	
				// input: THREE.Matrix4 projection matrix
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
				var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide
	
				this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
				this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
				this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;
	
				return this;
	
			},
	
			applyQuaternion: function ( q ) {
	
				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	
				// calculate quat * vector
	
				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;
	
				// calculate result * inverse quat
	
				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
				return this;
	
			},
	
			project: function () {
	
				var matrix;
	
				return function project( camera ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyProjection( matrix );
	
				};
	
			}(),
	
			unproject: function () {
	
				var matrix;
	
				return function unproject( camera ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyProjection( matrix );
	
				};
	
			}(),
	
			transformDirection: function ( m ) {
	
				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
				return this.normalize();
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector3();
						max = new Vector3();
	
					}
	
					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			cross: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );
	
				}
	
				var x = this.x, y = this.y, z = this.z;
	
				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;
	
				return this;
	
			},
	
			crossVectors: function ( a, b ) {
	
				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;
	
				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;
	
				return this;
	
			},
	
			projectOnVector: function ( vector ) {
	
				var scalar = vector.dot( this ) / vector.lengthSq();
	
				return this.copy( vector ).multiplyScalar( scalar );
	
			},
	
			projectOnPlane: function () {
	
				var v1;
	
				return function projectOnPlane( planeNormal ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					v1.copy( this ).projectOnVector( planeNormal );
	
					return this.sub( v1 );
	
				};
	
			}(),
	
			reflect: function () {
	
				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length
	
				var v1;
	
				return function reflect( normal ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
				};
	
			}(),
	
			angleTo: function ( v ) {
	
				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
				// clamp, to handle numerical problems
	
				return Math.acos( _Math.clamp( theta, - 1, 1 ) );
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	
				return dx * dx + dy * dy + dz * dz;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	
			},
	
			setFromSpherical: function( s ) {
	
				var sinPhiRadius = Math.sin( s.phi ) * s.radius;
	
				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );
	
				return this;
	
			},
	
			setFromMatrixPosition: function ( m ) {
	
				return this.setFromMatrixColumn( m, 3 );
	
			},
	
			setFromMatrixScale: function ( m ) {
	
				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();
	
				this.x = sx;
				this.y = sy;
				this.z = sz;
	
				return this;
	
			},
	
			setFromMatrixColumn: function ( m, index ) {
	
				if ( typeof m === 'number' ) {
	
					console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
					var temp = m;
					m = index;
					index = temp;
	
				}
	
				return this.fromArray( m.elements, index * 4 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
	
				return array;
	
			},
	
			fromAttribute: function ( attribute, index, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				index = index * attribute.itemSize + offset;
	
				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
				this.z = attribute.array[ index + 2 ];
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Matrix4() {
	
			this.elements = new Float32Array( [
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			] );
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Matrix4.prototype = {
	
			constructor: Matrix4,
	
			isMatrix4: true,
	
			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new Matrix4().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				this.elements.set( m.elements );
	
				return this;
	
			},
	
			copyPosition: function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];
	
				return this;
	
			},
	
			extractBasis: function ( xAxis, yAxis, zAxis ) {
	
				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );
	
				return this;
	
			},
	
			makeBasis: function ( xAxis, yAxis, zAxis ) {
	
				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);
	
				return this;
	
			},
	
			extractRotation: function () {
	
				var v1;
	
				return function extractRotation( m ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					var te = this.elements;
					var me = m.elements;
	
					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;
	
					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;
	
					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;
	
					return this;
	
				};
	
			}(),
	
			makeRotationFromEuler: function ( euler ) {
	
				if ( (euler && euler.isEuler) === false ) {
	
					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				var te = this.elements;
	
				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );
	
				if ( euler.order === 'XYZ' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;
	
					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;
	
					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YXZ' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;
	
					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;
	
					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZXY' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;
	
					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;
	
					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZYX' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;
	
					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;
	
					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YZX' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;
	
					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;
	
					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;
	
				} else if ( euler.order === 'XZY' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;
	
					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;
	
					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;
	
				}
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			makeRotationFromQuaternion: function ( q ) {
	
				var te = this.elements;
	
				var x = q.x, y = q.y, z = q.z, w = q.w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;
	
				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;
	
				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;
	
				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			lookAt: function () {
	
				var x, y, z;
	
				return function lookAt( eye, target, up ) {
	
					if ( x === undefined ) {
	
						x = new Vector3();
						y = new Vector3();
						z = new Vector3();
	
					}
	
					var te = this.elements;
	
					z.subVectors( eye, target ).normalize();
	
					if ( z.lengthSq() === 0 ) {
	
						z.z = 1;
	
					}
	
					x.crossVectors( up, z ).normalize();
	
					if ( x.lengthSq() === 0 ) {
	
						z.z += 0.0001;
						x.crossVectors( up, z ).normalize();
	
					}
	
					y.crossVectors( z, x );
	
	
					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
					return this;
	
				};
	
			}(),
	
			multiply: function ( m, n ) {
	
				if ( n !== undefined ) {
	
					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );
	
				}
	
				return this.multiplyMatrices( this, m );
	
			},
	
			premultiply: function ( m ) {
	
				return this.multiplyMatrices( m, this );
	
			},
	
			multiplyMatrices: function ( a, b ) {
	
				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;
	
				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
				return this;
	
			},
	
			multiplyToArray: function ( a, b, r ) {
	
				var te = this.elements;
	
				this.multiplyMatrices( a, b );
	
				r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
				r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
				r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
				r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
				return this;
	
			},
	
			applyToVector3Array: function () {
	
				var v1;
	
				return function applyToVector3Array( array, offset, length ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = array.length;
	
					for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
						v1.fromArray( array, j );
						v1.applyMatrix4( this );
						v1.toArray( array, j );
	
					}
	
					return array;
	
				};
	
			}(),
	
			applyToBuffer: function () {
	
				var v1;
	
				return function applyToBuffer( buffer, offset, length ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
					for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
						v1.x = buffer.getX( j );
						v1.y = buffer.getY( j );
						v1.z = buffer.getZ( j );
	
						v1.applyMatrix4( this );
	
						buffer.setXYZ( j, v1.x, v1.y, v1.z );
	
					}
	
					return buffer;
	
				};
	
			}(),
	
			determinant: function () {
	
				var te = this.elements;
	
				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)
	
				);
	
			},
	
			transpose: function () {
	
				var te = this.elements;
				var tmp;
	
				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
				return this;
	
			},
	
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
						"- just use .toArray instead." );
	
				return this.toArray( array, offset );
	
			},
	
			getPosition: function () {
	
				var v1;
	
				return function getPosition() {
	
					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	
					return v1.setFromMatrixColumn( this, 3 );
	
				};
	
			}(),
	
			setPosition: function ( v ) {
	
				var te = this.elements;
	
				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;
	
				return this;
	
			},
	
			getInverse: function ( m, throwOnDegenerate ) {
	
				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
	
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
				return this;
	
			},
	
			scale: function ( v ) {
	
				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;
	
				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
				return this;
	
			},
	
			getMaxScaleOnAxis: function () {
	
				var te = this.elements;
	
				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
			},
	
			makeTranslation: function ( x, y, z ) {
	
				this.set(
	
					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationX: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationY: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationZ: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationAxis: function ( axis, angle ) {
	
				// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;
	
				this.set(
	
					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1
	
				);
	
				 return this;
	
			},
	
			makeScale: function ( x, y, z ) {
	
				this.set(
	
					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			compose: function ( position, quaternion, scale ) {
	
				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );
	
				return this;
	
			},
	
			decompose: function () {
	
				var vector, matrix;
	
				return function decompose( position, quaternion, scale ) {
	
					if ( vector === undefined ) {
	
						vector = new Vector3();
						matrix = new Matrix4();
	
					}
	
					var te = this.elements;
	
					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) {
	
						sx = - sx;
	
					}
	
					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];
	
					// scale the rotation part
	
					matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;
	
					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;
	
					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;
	
					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;
	
					quaternion.setFromRotationMatrix( matrix );
	
					scale.x = sx;
					scale.y = sy;
					scale.z = sz;
	
					return this;
	
				};
	
			}(),
	
			makeFrustum: function ( left, right, bottom, top, near, far ) {
	
				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );
	
				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );
	
				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
				return this;
	
			},
	
			makePerspective: function ( fov, aspect, near, far ) {
	
				var ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );
				var ymin = - ymax;
				var xmin = ymin * aspect;
				var xmax = ymax * aspect;
	
				return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
			},
	
			makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );
	
				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;
	
				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
				return this;
	
			},
	
			equals: function ( matrix ) {
	
				var te = this.elements;
				var me = matrix.elements;
	
				for ( var i = 0; i < 16; i ++ ) {
	
					if ( te[ i ] !== me[ i ] ) return false;
	
				}
	
				return true;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for( var i = 0; i < 16; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];
	
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
	
				array[ offset + 8 ]  = te[ 8 ];
				array[ offset + 9 ]  = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];
	
				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];
	
				return array;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	
			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.flipY = false;
	
		}
	
		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;
	
		CubeTexture.prototype.isCubeTexture = true;
	
		Object.defineProperty( CubeTexture.prototype, 'images', {
	
			get: function () {
	
				return this.image;
	
			},
	
			set: function ( value ) {
	
				this.image = value;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */
	
		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();
	
		// --- Base for inner nodes (including the root) ---
	
		function UniformContainer() {
	
			this.seq = [];
			this.map = {};
	
		}
	
		// --- Utilities ---
	
		// Array Caches (provide typed arrays for temporary by size)
	
		var arrayCacheF32 = [];
		var arrayCacheI32 = [];
	
		// Flattening for arrays of vectors and matrices
	
		function flatten( array, nBlocks, blockSize ) {
	
			var firstElem = array[ 0 ];
	
			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983
	
			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];
	
			if ( r === undefined ) {
	
				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;
	
			}
	
			if ( nBlocks !== 0 ) {
	
				firstElem.toArray( r, 0 );
	
				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
	
					offset += blockSize;
					array[ i ].toArray( r, offset );
	
				}
	
			}
	
			return r;
	
		}
	
		// Texture unit allocation
	
		function allocTexUnits( renderer, n ) {
	
			var r = arrayCacheI32[ n ];
	
			if ( r === undefined ) {
	
				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;
	
			}
	
			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();
	
			return r;
	
		}
	
		// --- Setters ---
	
		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.
	
		// Single scalar
	
		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }
	
		// Single float vector (from flat array or THREE.VectorN)
	
		function setValue2fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );
	
		}
	
		function setValue3fv( gl, v ) {
	
			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );
	
		}
	
		function setValue4fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	
		}
	
		// Single matrix (from flat array or MatrixN)
	
		function setValue2fm( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue3fm( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue4fm( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, v.elements || v );
	
		}
	
		// Single texture (2D / Cube)
	
		function setValueT1( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );
	
		}
	
		function setValueT6( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );
	
		}
	
		// Integer / Boolean vectors or arrays thereof (always flat arrays)
	
		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }
	
		// Helper to pick the right setter for the singular case
	
		function getSingularSetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4
	
				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4
	
				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// Array of scalars
	
		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }
	
		// Array of vectors (flat or from THREE classes)
	
		function setValueV2a( gl, v ) {
	
			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );
	
		}
	
		function setValueV3a( gl, v ) {
	
			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );
	
		}
	
		function setValueV4a( gl, v ) {
	
			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );
	
		}
	
		// Array of matrices (flat or from THREE clases)
	
		function setValueM2a( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );
	
		}
	
		function setValueM3a( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );
	
		}
	
		function setValueM4a( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );
	
		}
	
		// Array of textures (2D / Cube)
	
		function setValueT1a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	
			}
	
		}
	
		function setValueT6a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	
			}
	
		}
	
		// Helper to pick the right setter for a pure (bottom-level) array
	
		function getPureArraySetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4
	
				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4
	
				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// --- Uniform Classes ---
	
		function SingleUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function PureArrayUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function StructuredUniform( id ) {
	
			this.id = id;
	
			UniformContainer.call( this ); // mix-in
	
		}
	
		StructuredUniform.prototype.setValue = function( gl, value ) {
	
			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.
	
			var seq = this.seq;
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );
	
			}
	
		};
	
		// --- Top-level ---
	
		// Parser - builds up the property tree from the path strings
	
		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	
		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.
	
		function addUniform( container, uniformObject ) {
	
			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;
	
		}
	
		function parseUniform( activeInfo, addr, container ) {
	
			var path = activeInfo.name,
				pathLength = path.length;
	
			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;
	
			for (; ;) {
	
				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,
	
					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];
	
				if ( idIsIndex ) id = id | 0; // convert to integer
	
				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix
	
					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );
	
					break;
	
				} else {
					// step into inner node / create it in case it doesn't exist
	
					var map = container.map,
						next = map[ id ];
	
					if ( next === undefined ) {
	
						next = new StructuredUniform( id );
						addUniform( container, next );
	
					}
	
					container = next;
	
				}
	
			}
	
		}
	
		// Root Container
	
		function WebGLUniforms( gl, program, renderer ) {
	
			UniformContainer.call( this );
	
			this.renderer = renderer;
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );
	
				parseUniform( info, addr, this );
	
			}
	
		}
	
		WebGLUniforms.prototype.setValue = function( gl, name, value ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, value, this.renderer );
	
		};
	
		WebGLUniforms.prototype.set = function( gl, object, name ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );
	
		};
	
		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {
	
			var v = object[ name ];
	
			if ( v !== undefined ) this.setValue( gl, name, v );
	
		};
	
	
		// Static interface
	
		WebGLUniforms.upload = function( gl, seq, values, renderer ) {
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ],
					v = values[ u.id ];
	
				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined
	
					u.setValue( gl, v.value, renderer );
	
				}
	
			}
	
		};
	
		WebGLUniforms.seqWithValue = function( seq, values ) {
	
			var r = [];
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				if ( u.id in values ) r.push( u );
	
			}
	
			return r;
	
		};
	
		/**
		 * Uniform Utilities
		 */
	
		var UniformsUtils = {
	
			merge: function ( uniforms ) {
	
				var merged = {};
	
				for ( var u = 0; u < uniforms.length; u ++ ) {
	
					var tmp = this.clone( uniforms[ u ] );
	
					for ( var p in tmp ) {
	
						merged[ p ] = tmp[ p ];
	
					}
	
				}
	
				return merged;
	
			},
	
			clone: function ( uniforms_src ) {
	
				var uniforms_dst = {};
	
				for ( var u in uniforms_src ) {
	
					uniforms_dst[ u ] = {};
	
					for ( var p in uniforms_src[ u ] ) {
	
						var parameter_src = uniforms_src[ u ][ p ];
	
						if ( parameter_src && ( parameter_src.isColor ||
							parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
							parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
							parameter_src.isTexture ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.clone();
	
						} else if ( Array.isArray( parameter_src ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.slice();
	
						} else {
	
							uniforms_dst[ u ][ p ] = parameter_src;
	
						}
	
					}
	
				}
	
				return uniforms_dst;
	
			}
	
		};
	
		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
	
		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
	
		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
	
		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
	
		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	
		var begin_vertex = "\nvec3 transformed = vec3( position );\n";
	
		var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
	
		var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
	
		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
	
		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
	
		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
	
		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
	
		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
	
		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
	
		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
	
		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	
		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
	
		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";
	
		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
	
		var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
	
		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
	
		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
	
		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
	
		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
	
		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
	
		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
	
		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
	
		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
	
		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
	
		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
	
		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
	
		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
	
		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	
		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
	
		var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
	
		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
	
		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
	
		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
	
		var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
	
		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
	
		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
	
		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
	
		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
	
		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
	
		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
	
		var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
	
		var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
	
		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
	
		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	
		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
	
		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
	
		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
	
		var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";
	
		var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
	
		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
	
		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
	
		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
	
		var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
	
		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
	
		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	
		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
	
		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
	
		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
	
		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
	
		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
	
		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";
	
		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
	
		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	
		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	
		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
	
		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
	
		var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
	
		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
	
		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
	
		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
	
		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
	
		var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
	
		var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
	
		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
	
		var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
	
		var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
	
		var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
	
		var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
	
		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";
	
		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";
	
		var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
	
		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";
	
		var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,
	
			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Color( r, g, b ) {
	
			if ( g === undefined && b === undefined ) {
	
				// r is THREE.Color, hex or string
				return this.set( r );
	
			}
	
			return this.setRGB( r, g, b );
	
		}
	
		Color.prototype = {
	
			constructor: Color,
	
			isColor: true,
	
			r: 1, g: 1, b: 1,
	
			set: function ( value ) {
	
				if ( (value && value.isColor) ) {
	
					this.copy( value );
	
				} else if ( typeof value === 'number' ) {
	
					this.setHex( value );
	
				} else if ( typeof value === 'string' ) {
	
					this.setStyle( value );
	
				}
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.r = scalar;
				this.g = scalar;
				this.b = scalar;
	
				return this;
	
			},
	
			setHex: function ( hex ) {
	
				hex = Math.floor( hex );
	
				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;
	
				return this;
	
			},
	
			setRGB: function ( r, g, b ) {
	
				this.r = r;
				this.g = g;
				this.b = b;
	
				return this;
	
			},
	
			setHSL: function () {
	
				function hue2rgb( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				}
	
				return function setHSL( h, s, l ) {
	
					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );
	
					if ( s === 0 ) {
	
						this.r = this.g = this.b = l;
	
					} else {
	
						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;
	
						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );
	
					}
	
					return this;
	
				};
	
			}(),
	
			setStyle: function ( style ) {
	
				function handleAlpha( string ) {
	
					if ( string === undefined ) return;
	
					if ( parseFloat( string ) < 1 ) {
	
						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
					}
	
				}
	
	
				var m;
	
				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
					// rgb / hsl
	
					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];
	
					switch ( name ) {
	
						case 'rgb':
						case 'rgba':
	
							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							break;
	
						case 'hsl':
						case 'hsla':
	
							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this.setHSL( h, s, l );
	
							}
	
							break;
	
					}
	
				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
					// hex color
	
					var hex = m[ 1 ];
					var size = hex.length;
	
					if ( size === 3 ) {
	
						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
						return this;
	
					} else if ( size === 6 ) {
	
						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
						return this;
	
					}
	
				}
	
				if ( style && style.length > 0 ) {
	
					// color keywords
					var hex = ColorKeywords[ style ];
	
					if ( hex !== undefined ) {
	
						// red
						this.setHex( hex );
	
					} else {
	
						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );
	
					}
	
				}
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.r, this.g, this.b );
	
			},
	
			copy: function ( color ) {
	
				this.r = color.r;
				this.g = color.g;
				this.b = color.b;
	
				return this;
	
			},
	
			copyGammaToLinear: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );
	
				return this;
	
			},
	
			copyLinearToGamma: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );
	
				return this;
	
			},
	
			convertGammaToLinear: function () {
	
				var r = this.r, g = this.g, b = this.b;
	
				this.r = r * r;
				this.g = g * g;
				this.b = b * b;
	
				return this;
	
			},
	
			convertLinearToGamma: function () {
	
				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );
	
				return this;
	
			},
	
			getHex: function () {
	
				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
			},
	
			getHexString: function () {
	
				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
			},
	
			getHSL: function ( optionalTarget ) {
	
				// h,s,l ranges are in 0.0 - 1.0
	
				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
				var r = this.r, g = this.g, b = this.b;
	
				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );
	
				var hue, saturation;
				var lightness = ( min + max ) / 2.0;
	
				if ( min === max ) {
	
					hue = 0;
					saturation = 0;
	
				} else {
	
					var delta = max - min;
	
					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
					switch ( max ) {
	
						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;
	
					}
	
					hue /= 6;
	
				}
	
				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;
	
				return hsl;
	
			},
	
			getStyle: function () {
	
				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
			},
	
			offsetHSL: function ( h, s, l ) {
	
				var hsl = this.getHSL();
	
				hsl.h += h; hsl.s += s; hsl.l += l;
	
				this.setHSL( hsl.h, hsl.s, hsl.l );
	
				return this;
	
			},
	
			add: function ( color ) {
	
				this.r += color.r;
				this.g += color.g;
				this.b += color.b;
	
				return this;
	
			},
	
			addColors: function ( color1, color2 ) {
	
				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.r += s;
				this.g += s;
				this.b += s;
	
				return this;
	
			},
	
			sub: function( color ) {
	
				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );
	
				return this;
	
			},
	
			multiply: function ( color ) {
	
				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				this.r *= s;
				this.g *= s;
				this.b *= s;
	
				return this;
	
			},
	
			lerp: function ( color, alpha ) {
	
				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;
	
				return this;
	
			},
	
			equals: function ( c ) {
	
				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;
	
				return array;
	
			},
	
			toJSON: function () {
	
				return this.getHex();
	
			}
	
		};
	
		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
		/**
		 * Uniforms library for shared webgl shaders
		 */
	
		var UniformsLib = {
	
			common: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
	
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },
	
				specularMap: { value: null },
				alphaMap: { value: null },
	
				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }
	
			},
	
			aomap: {
	
				aoMap: { value: null },
				aoMapIntensity: { value: 1 }
	
			},
	
			lightmap: {
	
				lightMap: { value: null },
				lightMapIntensity: { value: 1 }
	
			},
	
			emissivemap: {
	
				emissiveMap: { value: null }
	
			},
	
			bumpmap: {
	
				bumpMap: { value: null },
				bumpScale: { value: 1 }
	
			},
	
			normalmap: {
	
				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }
	
			},
	
			displacementmap: {
	
				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }
	
			},
	
			roughnessmap: {
	
				roughnessMap: { value: null }
	
			},
	
			metalnessmap: {
	
				metalnessMap: { value: null }
	
			},
	
			fog: {
	
				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }
	
			},
	
			lights: {
	
				ambientLightColor: { value: [] },
	
				directionalLights: { value: [], properties: {
					direction: {},
					color: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
	
				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },
	
				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
	
				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} }
	
			},
	
			points: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */
	
		var ShaderLib = {
	
			basic: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.fog
	
				] ),
	
				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag
	
			},
	
			lambert: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,
	
					{
						emissive : { value: new Color( 0x000000 ) }
					}
	
				] ),
	
				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag
	
			},
	
			phong: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.fog,
					UniformsLib.lights,
	
					{
						emissive : { value: new Color( 0x000000 ) },
						specular : { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
	
				] ),
	
				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag
	
			},
	
			standard: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,
	
					{
						emissive : { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity : { value: 1 }, // temporary
					}
	
				] ),
	
				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag
	
			},
	
			points: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.points,
					UniformsLib.fog
	
				] ),
	
				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag
	
			},
	
			dashed: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.common,
					UniformsLib.fog,
	
					{
						scale    : { value: 1 },
						dashSize : { value: 1 },
						totalSize: { value: 2 }
					}
	
				] ),
	
				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag
	
			},
	
			depth: {
	
				uniforms: UniformsUtils.merge( [
	
					UniformsLib.common,
					UniformsLib.displacementmap
	
				] ),
	
				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag
	
			},
	
			normal: {
	
				uniforms: {
	
					opacity : { value: 1.0 }
	
				},
	
				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			cube: {
	
				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},
	
				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			equirect: {
	
				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},
	
				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag
	
			},
	
			distanceRGBA: {
	
				uniforms: {
	
					lightPos: { value: new Vector3() }
	
				},
	
				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag
	
			}
	
		};
	
		ShaderLib.physical = {
	
			uniforms: UniformsUtils.merge( [
	
				ShaderLib.standard.uniforms,
	
				{
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}
	
			] ),
	
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Box2( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
	
		}
	
		Box2.prototype = {
	
			constructor: Box2,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector2();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			containsPoint: function ( point ) {
	
				if ( point.x < this.min.x || point.x > this.max.x ||
				     point.y < this.min.y || point.y > this.max.y ) {
	
					return false;
	
				}
	
				return true;
	
			},
	
			containsBox: function ( box ) {
	
				if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
					return true;
	
				}
	
				return false;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector2();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
	
				if ( box.max.x < this.min.x || box.min.x > this.max.x ||
				     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
					return false;
	
				}
	
				return true;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector2();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlarePlugin( renderer, flares ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;
	
			var tempTexture, occlusionTexture;
	
			function init() {
	
				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				// buffers
	
				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				// textures
	
				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();
	
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
				program = createProgram( shader );
	
				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};
	
				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};
	
			}
	
			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */
	
			this.render = function ( scene, camera, viewport ) {
	
				if ( flares.length === 0 ) return;
	
				var tempPosition = new Vector3();
	
				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;
	
				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );
	
				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );
	
				var validArea = new Box2();
	
				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms
	
				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				state.disable( gl.CULL_FACE );
				state.setDepthWrite( false );
	
				for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
					size = 16 / viewport.w;
					scale.set( size * invAspect, size );
	
					// calc object screen position
	
					var flare = flares[ i ];
	
					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyProjection( camera.projectionMatrix );
	
					// setup arrays for gl programs
	
					screenPosition.copy( tempPosition );
	
					// horizontal and vertical coordinate of the lower left corner of the pixels to copy
	
					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;
	
					// screen cull
	
					if ( validArea.containsPoint( screenPositionPixels ) === true ) {
	
						// save current RGB to temp texture
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// render pink quad
	
						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );
	
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// copy result to occlusionMap
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// restore graphics
	
						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );
	
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// update object positions
	
						flare.positionScreen.copy( screenPosition );
	
						if ( flare.customUpdateCallback ) {
	
							flare.customUpdateCallback( flare );
	
						} else {
	
							flare.updateLensFlares();
	
						}
	
						// render flares
	
						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );
	
						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
							var sprite = flare.lensFlares[ j ];
	
							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;
	
								size = sprite.size * sprite.scale / viewport.w;
	
								scale.x = size * invAspect;
								scale.y = size;
	
								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );
	
								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );
	
								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
							}
	
						}
	
					}
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.setDepthWrite( true );
	
				renderer.resetGLState();
	
			};
	
			function createProgram( shader ) {
	
				var program = gl.createProgram();
	
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
				var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );
	
				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
		}
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpritePlugin( renderer, sprites ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;
	
			var texture;
	
			// decompose matrixWorld
	
			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();
	
			function init() {
	
				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				program = createProgram();
	
				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};
	
				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),
	
					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),
	
					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};
	
				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;
	
				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );
	
				texture = new Texture( canvas );
				texture.needsUpdate = true;
	
			}
	
			this.render = function ( scene, camera ) {
	
				if ( sprites.length === 0 ) return;
	
				// setup gl
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );
	
				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;
	
				if ( fog ) {
	
					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
					if ( (fog && fog.isFog) ) {
	
						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );
	
						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;
	
					} else if ( (fog && fog.isFogExp2) ) {
	
						gl.uniform1f( uniforms.fogDensity, fog.density );
	
						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;
	
					}
	
				} else {
	
					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;
	
				}
	
	
				// update positions and sort
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
	
					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
				}
	
				sprites.sort( painterSortStable );
	
				// render all sprites
	
				var scale = [];
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
					var material = sprite.material;
	
					if ( material.visible === false ) continue;
	
					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;
	
					var fogType = 0;
	
					if ( scene.fog && material.fog ) {
	
						fogType = sceneFogType;
	
					}
	
					if ( oldFogType !== fogType ) {
	
						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;
	
					}
	
					if ( material.map !== null ) {
	
						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
					} else {
	
						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );
	
					}
	
					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );
	
					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					state.setDepthTest( material.depthTest );
					state.setDepthWrite( material.depthWrite );
	
					if ( material.map ) {
	
						renderer.setTexture2D( material.map, 0 );
	
					} else {
	
						renderer.setTexture2D( texture, 0 );
	
					}
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
	
				renderer.resetGLState();
	
			};
	
			function createProgram() {
	
				var program = gl.createProgram();
	
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
				gl.shaderSource( vertexShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',
	
					'attribute vec2 position;',
					'attribute vec2 uv;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vUV = uvOffset + uv * uvScale;',
	
						'vec2 alignedPosition = position * scale;',
	
						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
						'vec4 finalPosition;',
	
						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',
	
						'gl_Position = finalPosition;',
	
					'}'
	
				].join( '\n' ) );
	
				gl.shaderSource( fragmentShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',
	
					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vec4 texture = texture2D( map, vUV );',
	
						'if ( texture.a < alphaTest ) discard;',
	
						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
						'if ( fogType > 0 ) {',
	
							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',
	
							'if ( fogType == 1 ) {',
	
								'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
							'} else {',
	
								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
							'}',
	
							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
						'}',
	
					'}'
	
				].join( '\n' ) );
	
				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );
	
				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.renderOrder !== b.renderOrder ) {
	
					return a.renderOrder - b.renderOrder;
	
				} else if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return b.id - a.id;
	
				}
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Material() {
	
			Object.defineProperty( this, 'id', { value: MaterialIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Material';
	
			this.fog = true;
			this.lights = true;
	
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	
			this.opacity = 1;
			this.transparent = false;
	
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
	
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
	
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
	
			this.colorWrite = true;
	
			this.precision = null; // override the renderer's default precision for this material
	
			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
	
			this.alphaTest = 0;
			this.premultipliedAlpha = false;
	
			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
			this.visible = true;
	
			this._needsUpdate = true;
	
		}
	
		Material.prototype = {
	
			constructor: Material,
	
			isMaterial: true,
	
			get needsUpdate() {
	
				return this._needsUpdate;
	
			},
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.update();
				this._needsUpdate = value;
	
			},
	
			setValues: function ( values ) {
	
				if ( values === undefined ) return;
	
				for ( var key in values ) {
	
					var newValue = values[ key ];
	
					if ( newValue === undefined ) {
	
						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;
	
					}
	
					var currentValue = this[ key ];
	
					if ( currentValue === undefined ) {
	
						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;
	
					}
	
					if ( (currentValue && currentValue.isColor) ) {
	
						currentValue.set( newValue );
	
					} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {
	
						currentValue.copy( newValue );
	
					} else if ( key === 'overdraw' ) {
	
						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );
	
					} else {
	
						this[ key ] = newValue;
	
					}
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				var isRoot = meta === undefined;
	
				if ( isRoot ) {
	
					meta = {
						textures: {},
						images: {}
					};
	
				}
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};
	
				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;
	
				if ( this.name !== '' ) data.name = this.name;
	
				if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();
	
				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;
	
				if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
				if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;
	
				if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
				if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( (this.bumpMap && this.bumpMap.isTexture) ) {
	
					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;
	
				}
				if ( (this.normalMap && this.normalMap.isTexture) ) {
	
					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();
	
				}
				if ( (this.displacementMap && this.displacementMap.isTexture) ) {
	
					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;
	
				}
				if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
				if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
				if ( (this.envMap && this.envMap.isTexture) ) {
	
					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap
	
				}
	
				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
	
				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;
	
				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;
	
				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
	
				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;
	
				// TODO: Copied from Object3D.toJSON
	
				function extractFromCache( cache ) {
	
					var values = [];
	
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
	
					return values;
	
				}
	
				if ( isRoot ) {
	
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.name = source.name;
	
				this.fog = source.fog;
				this.lights = source.lights;
	
				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;
	
				this.opacity = source.opacity;
				this.transparent = source.transparent;
	
				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;
	
				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;
	
				this.colorWrite = source.colorWrite;
	
				this.precision = source.precision;
	
				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;
	
				this.alphaTest = source.alphaTest;
	
				this.premultipliedAlpha = source.premultipliedAlpha;
	
				this.overdraw = source.overdraw;
	
				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;
	
				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;
	
				if ( srcPlanes !== null ) {
	
					var n = srcPlanes.length;
					dstPlanes = new Array( n );
	
					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();
	
				}
	
				this.clippingPlanes = dstPlanes;
	
				return this;
	
			},
	
			update: function () {
	
				this.dispatchEvent( { type: 'update' } );
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( Material.prototype, EventDispatcher.prototype );
	
		var count$1 = 0;
		function MaterialIdCount() { return count$1++; }
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function ShaderMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'ShaderMaterial';
	
			this.defines = {};
			this.uniforms = {};
	
			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
			this.linewidth = 1;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes
	
			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals
	
			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};
	
			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};
	
			this.index0AttributeName = undefined;
	
			if ( parameters !== undefined ) {
	
				if ( parameters.attributes !== undefined ) {
	
					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
				}
	
				this.setValues( parameters );
	
			}
	
		}
	
		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;
	
		ShaderMaterial.prototype.isShaderMaterial = true;
	
		ShaderMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
	
			this.uniforms = UniformsUtils.clone( source.uniforms );
	
			this.defines = source.defines;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.lights = source.lights;
			this.clipping = source.clipping;
	
			this.skinning = source.skinning;
	
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			this.extensions = source.extensions;
	
			return this;
	
		};
	
		ShaderMaterial.prototype.toJSON = function ( meta ) {
	
			var data = Material.prototype.toJSON.call( this, meta );
	
			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
	
			return data;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */
	
		function MeshDepthMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshDepthMaterial';
	
			this.depthPacking = BasicDepthPacking;
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.map = null;
	
			this.alphaMap = null;
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	
		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
	
		MeshDepthMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.depthPacking = source.depthPacking;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			this.map = source.map;
	
			this.alphaMap = source.alphaMap;
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			return this;
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Box3( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
	
		}
	
		Box3.prototype = {
	
			constructor: Box3,
	
			isBox3: true,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromArray: function ( array ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector3();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			setFromObject: function () {
	
				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms
	
				var v1 = new Vector3();
	
				return function setFromObject( object ) {
	
					var scope = this;
	
					object.updateMatrixWorld( true );
	
					this.makeEmpty();
	
					object.traverse( function ( node ) {
	
						var geometry = node.geometry;
	
						if ( geometry !== undefined ) {
	
							if ( (geometry && geometry.isGeometry) ) {
	
								var vertices = geometry.vertices;
	
								for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );
	
									scope.expandByPoint( v1 );
	
								}
	
							} else if ( (geometry && geometry.isBufferGeometry) ) {
	
								var attribute = geometry.attributes.position;
	
								if ( attribute !== undefined ) {
	
									var array, offset, stride;
	
									if ( (attribute && attribute.isInterleavedBufferAttribute) ) {
	
										array = attribute.data.array;
										offset = attribute.offset;
										stride = attribute.data.stride;
	
									} else {
	
										array = attribute.array;
										offset = 0;
										stride = 3;
	
									}
	
									for ( var i = offset, il = array.length; i < il; i += stride ) {
	
										v1.fromArray( array, i );
										v1.applyMatrix4( node.matrixWorld );
	
										scope.expandByPoint( v1 );
	
									}
	
								}
	
							}
	
						}
	
					} );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			containsPoint: function ( point ) {
	
				if ( point.x < this.min.x || point.x > this.max.x ||
						 point.y < this.min.y || point.y > this.max.y ||
						 point.z < this.min.z || point.z > this.max.z ) {
	
					return false;
	
				}
	
				return true;
	
			},
	
			containsBox: function ( box ) {
	
				if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
					 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
					 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
					return true;
	
				}
	
				return false;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector3();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
	
				if ( box.max.x < this.min.x || box.min.x > this.max.x ||
						 box.max.y < this.min.y || box.min.y > this.max.y ||
						 box.max.z < this.min.z || box.min.z > this.max.z ) {
	
					return false;
	
				}
	
				return true;
	
			},
	
			intersectsSphere: ( function () {
	
				var closestPoint;
	
				return function intersectsSphere( sphere ) {
	
					if ( closestPoint === undefined ) closestPoint = new Vector3();
	
					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );
	
					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
				};
	
			} )(),
	
			intersectsPlane: function ( plane ) {
	
				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.
	
				var min, max;
	
				if ( plane.normal.x > 0 ) {
	
					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;
	
				} else {
	
					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;
	
				}
	
				if ( plane.normal.y > 0 ) {
	
					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;
	
				} else {
	
					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;
	
				}
	
				if ( plane.normal.z > 0 ) {
	
					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;
	
				} else {
	
					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;
	
				}
	
				return ( min <= plane.constant && max >= plane.constant );
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			getBoundingSphere: function () {
	
				var v1 = new Vector3();
	
				return function getBoundingSphere( optionalTarget ) {
	
					var result = optionalTarget || new Sphere();
	
					this.getCenter( result.center );
	
					result.radius = this.getSize( v1 ).length() * 0.5;
	
					return result;
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			applyMatrix4: function () {
	
				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];
	
				return function applyMatrix4( matrix ) {
	
					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;
	
					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
					this.setFromPoints( points );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Sphere( center, radius ) {
	
			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;
	
		}
	
		Sphere.prototype = {
	
			constructor: Sphere,
	
			set: function ( center, radius ) {
	
				this.center.copy( center );
				this.radius = radius;
	
				return this;
	
			},
	
			setFromPoints: function () {
	
				var box = new Box3();
	
				return function setFromPoints( points, optionalCenter ) {
	
					var center = this.center;
	
					if ( optionalCenter !== undefined ) {
	
						center.copy( optionalCenter );
	
					} else {
	
						box.setFromPoints( points ).getCenter( center );
	
					}
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = points.length; i < il; i ++ ) {
	
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
					}
	
					this.radius = Math.sqrt( maxRadiusSq );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( sphere ) {
	
				this.center.copy( sphere.center );
				this.radius = sphere.radius;
	
				return this;
	
			},
	
			empty: function () {
	
				return ( this.radius <= 0 );
	
			},
	
			containsPoint: function ( point ) {
	
				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return ( point.distanceTo( this.center ) - this.radius );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				var radiusSum = this.radius + sphere.radius;
	
				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsSphere( this );
	
			},
	
			intersectsPlane: function ( plane ) {
	
				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.
	
				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var deltaLengthSq = this.center.distanceToSquared( point );
	
				var result = optionalTarget || new Vector3();
	
				result.copy( point );
	
				if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );
	
				}
	
				return result;
	
			},
	
			getBoundingBox: function ( optionalTarget ) {
	
				var box = optionalTarget || new Box3();
	
				box.set( this.center, this.center );
				box.expandByScalar( this.radius );
	
				return box;
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.center.add( offset );
	
				return this;
	
			},
	
			equals: function ( sphere ) {
	
				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */
	
		function Matrix3() {
	
			this.elements = new Float32Array( [
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			] );
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Matrix3.prototype = {
	
			constructor: Matrix3,
	
			isMatrix3: true,
	
			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0,
					0, 1, 0,
					0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 3 ], me[ 6 ],
					me[ 1 ], me[ 4 ], me[ 7 ],
					me[ 2 ], me[ 5 ], me[ 8 ]
	
				);
	
				return this;
	
			},
	
			setFromMatrix4: function( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]
	
				);
	
				return this;
	
			},
	
			applyToVector3Array: function () {
	
				var v1;
	
				return function applyToVector3Array( array, offset, length ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = array.length;
	
					for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {
	
						v1.fromArray( array, j );
						v1.applyMatrix3( this );
						v1.toArray( array, j );
	
					}
	
					return array;
	
				};
	
			}(),
	
			applyToBuffer: function () {
	
				var v1;
	
				return function applyToBuffer( buffer, offset, length ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = buffer.length / buffer.itemSize;
	
					for ( var i = 0, j = offset; i < length; i ++, j ++ ) {
	
						v1.x = buffer.getX( j );
						v1.y = buffer.getY( j );
						v1.z = buffer.getZ( j );
	
						v1.applyMatrix3( this );
	
						buffer.setXYZ( j, v1.x, v1.y, v1.z );
	
					}
	
					return buffer;
	
				};
	
			}(),
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
				return this;
	
			},
	
			determinant: function () {
	
				var te = this.elements;
	
				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
			},
	
			getInverse: function ( matrix, throwOnDegenerate ) {
	
				if ( (matrix && matrix.isMatrix4) ) {
	
					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );
	
				}
	
				var me = matrix.elements,
					te = this.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,
	
					det = n11 * t11 + n21 * t12 + n31 * t13;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
				return this;
	
			},
	
			transpose: function () {
	
				var tmp, m = this.elements;
	
				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
				return this;
	
			},
	
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
						"- just use .toArray instead." );
	
				return this.toArray( array, offset );
	
			},
	
			getNormalMatrix: function ( matrix4 ) {
	
				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
			},
	
			transposeIntoArray: function ( r ) {
	
				var m = this.elements;
	
				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];
	
				return this;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for( var i = 0; i < 9; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
	
				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
	
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ]  = te[ 8 ];
	
				return array;
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Plane( normal, constant ) {
	
			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;
	
		}
	
		Plane.prototype = {
	
			constructor: Plane,
	
			set: function ( normal, constant ) {
	
				this.normal.copy( normal );
				this.constant = constant;
	
				return this;
	
			},
	
			setComponents: function ( x, y, z, w ) {
	
				this.normal.set( x, y, z );
				this.constant = w;
	
				return this;
	
			},
	
			setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
				return this;
	
			},
	
			setFromCoplanarPoints: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function setFromCoplanarPoints( a, b, c ) {
	
					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
					this.setFromNormalAndCoplanarPoint( normal, a );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( plane ) {
	
				this.normal.copy( plane.normal );
				this.constant = plane.constant;
	
				return this;
	
			},
	
			normalize: function () {
	
				// Note: will lead to a divide by zero if the plane is invalid.
	
				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;
	
				return this;
	
			},
	
			negate: function () {
	
				this.constant *= - 1;
				this.normal.negate();
	
				return this;
	
			},
	
			distanceToPoint: function ( point ) {
	
				return this.normal.dot( point ) + this.constant;
	
			},
	
			distanceToSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) - sphere.radius;
	
			},
	
			projectPoint: function ( point, optionalTarget ) {
	
				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
			},
	
			orthoPoint: function ( point, optionalTarget ) {
	
				var perpendicularMagnitude = this.distanceToPoint( point );
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
			},
	
			intersectLine: function () {
	
				var v1 = new Vector3();
	
				return function intersectLine( line, optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					var direction = line.delta( v1 );
	
					var denominator = this.normal.dot( direction );
	
					if ( denominator === 0 ) {
	
						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {
	
							return result.copy( line.start );
	
						}
	
						// Unsure if this is the correct method to handle this case.
						return undefined;
	
					}
	
					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
					if ( t < 0 || t > 1 ) {
	
						return undefined;
	
					}
	
					return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
				};
	
			}(),
	
			intersectsLine: function ( line ) {
	
				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );
	
				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsPlane( this );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				return sphere.intersectsPlane( this );
	
			},
	
			coplanarPoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );
	
			},
	
			applyMatrix4: function () {
	
				var v1 = new Vector3();
				var m1 = new Matrix3();
	
				return function applyMatrix4( matrix, optionalNormalMatrix ) {
	
					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
	
					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
	
					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.constant = this.constant - offset.dot( this.normal );
	
				return this;
	
			},
	
			equals: function ( plane ) {
	
				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */
	
		function Frustum( p0, p1, p2, p3, p4, p5 ) {
	
			this.planes = [
	
				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()
	
			];
	
		}
	
		Frustum.prototype = {
	
			constructor: Frustum,
	
			set: function ( p0, p1, p2, p3, p4, p5 ) {
	
				var planes = this.planes;
	
				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( frustum ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					planes[ i ].copy( frustum.planes[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromMatrix: function ( m ) {
	
				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
				return this;
	
			},
	
			intersectsObject: function () {
	
				var sphere = new Sphere();
	
				return function intersectsObject( object ) {
	
					var geometry = object.geometry;
	
					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSprite: function () {
	
				var sphere = new Sphere();
	
				return function intersectsSprite( sprite ) {
	
					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					var distance = planes[ i ].distanceToPoint( center );
	
					if ( distance < negRadius ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			},
	
			intersectsBox: function () {
	
				var p1 = new Vector3(),
					p2 = new Vector3();
	
				return function intersectsBox( box ) {
	
					var planes = this.planes;
	
					for ( var i = 0; i < 6 ; i ++ ) {
	
						var plane = planes[ i ];
	
						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );
	
						// if both outside plane, no intersection
	
						if ( d1 < 0 && d2 < 0 ) {
	
							return false;
	
						}
	
					}
	
					return true;
	
				};
	
			}(),
	
	
			containsPoint: function ( point ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {
	
			var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),
	
			_lightShadows = _lights.shadows,
	
			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),
	
			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),
	
			_renderList = [],
	
			_MorphingFlag = 1,
			_SkinningFlag = 2,
	
			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),
	
			_materialCache = {};
	
			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];
	
			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];
	
			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];
	
			// init
	
			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;
	
			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );
	
			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;
	
				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;
	
				_depthMaterials[ i ] = depthMaterial;
	
				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );
	
				_distanceMaterials[ i ] = distanceMaterial;
	
			}
	
			//
	
			var scope = this;
	
			this.enabled = false;
	
			this.autoUpdate = true;
			this.needsUpdate = false;
	
			this.type = PCFShadowMap;
	
			this.renderReverseSided = true;
			this.renderSingleSided = true;
	
			this.render = function ( scene, camera ) {
	
				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
				if ( _lightShadows.length === 0 ) return;
	
				// Set GL state for depth map.
				_state.clearColor( 1, 1, 1, 1 );
				_state.disable( _gl.BLEND );
				_state.setDepthTest( true );
				_state.setScissorTest( false );
	
				// render depth map
	
				var faceCount, isPointLight;
	
				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {
	
					var light = _lightShadows[ i ];
					var shadow = light.shadow;
	
					if ( shadow === undefined ) {
	
						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;
	
					}
	
					var shadowCamera = shadow.camera;
	
					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );
	
					if ( (light && light.isPointLight) ) {
	
						faceCount = 6;
						isPointLight = true;
	
						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;
	
						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction
	
						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;
	
					} else {
	
						faceCount = 1;
						isPointLight = false;
	
					}
	
					if ( shadow.map === null ) {
	
						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
	
						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
	
						shadowCamera.updateProjectionMatrix();
	
					}
	
					if ( (shadow && shadow.isSpotLightShadow) ) {
	
						shadow.update( light );
	
					}
	
					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;
	
					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );
	
					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();
	
					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not
	
					for ( var face = 0; face < faceCount; face ++ ) {
	
						if ( isPointLight ) {
	
							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );
	
							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );
	
						} else {
	
							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );
	
						}
	
						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
						// compute shadow matrix
	
						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);
	
						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
						// update camera matrices and frustum
	
						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );
	
						// set object matrices & frustum culling
	
						_renderList.length = 0;
	
						projectObject( scene, camera, shadowCamera );
	
						// render shadow map
						// render regular objects
	
						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;
	
							if ( (material && material.isMultiMaterial) ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
									}
	
								}
	
							} else {
	
								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
							}
	
						}
	
					}
	
				}
	
				// Restore GL state.
				var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );
	
				scope.needsUpdate = false;
	
			};
	
			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
				var geometry = object.geometry;
	
				var result = null;
	
				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;
	
				if ( isPointLight ) {
	
					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;
	
				}
	
				if ( ! customMaterial ) {
	
					var useMorphing = false;
	
					if ( material.morphTargets ) {
	
						if ( (geometry && geometry.isBufferGeometry) ) {
	
							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	
						} else if ( (geometry && geometry.isGeometry) ) {
	
							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	
						}
	
					}
	
					var useSkinning = object.isSkinnedMesh && material.skinning;
	
					var variantIndex = 0;
	
					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;
	
					result = materialVariants[ variantIndex ];
	
				} else {
	
					result = customMaterial;
	
				}
	
				if ( _renderer.localClippingEnabled &&
					 material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {
	
					// in this case we need a unique material instance reflecting the
					// appropriate state
	
					var keyA = result.uuid, keyB = material.uuid;
	
					var materialsForVariant = _materialCache[ keyA ];
	
					if ( materialsForVariant === undefined ) {
	
						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;
	
					}
	
					var cachedMaterial = materialsForVariant[ keyB ];
	
					if ( cachedMaterial === undefined ) {
	
						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;
	
					}
	
					result = cachedMaterial;
	
				}
	
				result.visible = material.visible;
				result.wireframe = material.wireframe;
	
				var side = material.side;
	
				if ( scope.renderSingleSided && side == DoubleSide ) {
	
					side = FrontSide;
	
				}
	
				if ( scope.renderReverseSided ) {
	
					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;
	
				}
	
				result.side = side;
	
				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;
	
				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;
	
				if ( isPointLight && result.uniforms.lightPos !== undefined ) {
	
					result.uniforms.lightPos.value.copy( lightPositionWorld );
	
				}
	
				return result;
	
			}
	
			function projectObject( object, camera, shadowCamera ) {
	
				if ( object.visible === false ) return;
	
				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;
	
				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
	
					if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
							_renderList.push( object );
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera, shadowCamera );
	
				}
	
			}
	
		}
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Ray( origin, direction ) {
	
			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();
	
		}
	
		Ray.prototype = {
	
			constructor: Ray,
	
			set: function ( origin, direction ) {
	
				this.origin.copy( origin );
				this.direction.copy( direction );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( ray ) {
	
				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );
	
				return this;
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
			},
	
			lookAt: function ( v ) {
	
				this.direction.copy( v ).sub( this.origin ).normalize();
	
				return this;
	
			},
	
			recast: function () {
	
				var v1 = new Vector3();
	
				return function recast( t ) {
	
					this.origin.copy( this.at( t, v1 ) );
	
					return this;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );
	
				if ( directionDistance < 0 ) {
	
					return result.copy( this.origin );
	
				}
	
				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return Math.sqrt( this.distanceSqToPoint( point ) );
	
			},
	
			distanceSqToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceSqToPoint( point ) {
	
					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
					// point behind the ray
	
					if ( directionDistance < 0 ) {
	
						return this.origin.distanceToSquared( point );
	
					}
	
					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
					return v1.distanceToSquared( point );
	
				};
	
			}(),
	
			distanceSqToSegment: function () {
	
				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();
	
				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment
	
					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );
	
					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;
	
					if ( det > 0 ) {
	
						// The ray and segment are not parallel.
	
						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;
	
						if ( s0 >= 0 ) {
	
							if ( s1 >= - extDet ) {
	
								if ( s1 <= extDet ) {
	
									// region 0
									// Minimum at interior points of ray and segment.
	
									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
								} else {
	
									// region 1
	
									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
								}
	
							} else {
	
								// region 5
	
								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							if ( s1 <= - extDet ) {
	
								// region 4
	
								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							} else if ( s1 <= extDet ) {
	
								// region 3
	
								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 2
	
								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						}
	
					} else {
	
						// Ray and segment are parallel.
	
						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					}
	
					if ( optionalPointOnRay ) {
	
						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
					}
	
					if ( optionalPointOnSegment ) {
	
						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
					}
	
					return sqrDist;
	
				};
	
			}(),
	
			intersectSphere: function () {
	
				var v1 = new Vector3();
	
				return function intersectSphere( sphere, optionalTarget ) {
	
					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;
	
					if ( d2 > radius2 ) return null;
	
					var thc = Math.sqrt( radius2 - d2 );
	
					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;
	
					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;
	
					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;
	
					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
			},
	
			distanceToPlane: function ( plane ) {
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
						return 0;
	
					}
	
					// Null is preferable to undefined since undefined means.... it is undefined
	
					return null;
	
				}
	
				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
				// Return if the ray never intersects the plane
	
				return t >= 0 ? t :  null;
	
			},
	
			intersectPlane: function ( plane, optionalTarget ) {
	
				var t = this.distanceToPlane( plane );
	
				if ( t === null ) {
	
					return null;
	
				}
	
				return this.at( t, optionalTarget );
	
			},
	
	
	
			intersectsPlane: function ( plane ) {
	
				// check if the ray lies on the plane first
	
				var distToPoint = plane.distanceToPoint( this.origin );
	
				if ( distToPoint === 0 ) {
	
					return true;
	
				}
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator * distToPoint < 0 ) {
	
					return true;
	
				}
	
				// ray origin is behind the plane (and is pointing behind it)
	
				return false;
	
			},
	
			intersectBox: function ( box, optionalTarget ) {
	
				var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;
	
				var origin = this.origin;
	
				if ( invdirx >= 0 ) {
	
					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;
	
				} else {
	
					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;
	
				}
	
				if ( invdiry >= 0 ) {
	
					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;
	
				} else {
	
					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;
	
				}
	
				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN
	
				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
				if ( invdirz >= 0 ) {
	
					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;
	
				} else {
	
					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;
	
				}
	
				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
				//return point closest to the ray (positive side)
	
				if ( tmax < 0 ) return null;
	
				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
			},
	
			intersectsBox: ( function () {
	
				var v = new Vector3();
	
				return function intersectsBox( box ) {
	
					return this.intersectBox( box, v ) !== null;
	
				};
	
			} )(),
	
			intersectTriangle: function () {
	
				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();
	
				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	
					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );
	
					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;
	
					if ( DdN > 0 ) {
	
						if ( backfaceCulling ) return null;
						sign = 1;
	
					} else if ( DdN < 0 ) {
	
						sign = - 1;
						DdN = - DdN;
	
					} else {
	
						return null;
	
					}
	
					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {
	
						return null;
	
					}
	
					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {
	
						return null;
	
					}
	
					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {
	
						return null;
	
					}
	
					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );
	
					// t < 0, no intersection
					if ( QdN < 0 ) {
	
						return null;
	
					}
	
					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );
	
				};
	
			}(),
	
			applyMatrix4: function ( matrix4 ) {
	
				this.direction.add( this.origin ).applyMatrix4( matrix4 );
				this.origin.applyMatrix4( matrix4 );
				this.direction.sub( this.origin );
				this.direction.normalize();
	
				return this;
	
			},
	
			equals: function ( ray ) {
	
				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Euler( x, y, z, order ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;
	
		}
	
		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
		Euler.DefaultOrder = 'XYZ';
	
		Euler.prototype = {
	
			constructor: Euler,
	
			isEuler: true,
	
			get x () {
	
				return this._x;
	
			},
	
			set x ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			},
	
			get y () {
	
				return this._y;
	
			},
	
			set y ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			},
	
			get z () {
	
				return this._z;
	
			},
	
			set z ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			},
	
			get order () {
	
				return this._order;
	
			},
	
			set order ( value ) {
	
				this._order = value;
				this.onChangeCallback();
	
			},
	
			set: function ( x, y, z, order ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._order );
	
			},
	
			copy: function ( euler ) {
	
				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m, order, update ) {
	
				var clamp = _Math.clamp;
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				order = order || this._order;
	
				if ( order === 'XYZ' ) {
	
					this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
					if ( Math.abs( m13 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );
	
					} else {
	
						this._x = Math.atan2( m32, m22 );
						this._z = 0;
	
					}
	
				} else if ( order === 'YXZ' ) {
	
					this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
					if ( Math.abs( m23 ) < 0.99999 ) {
	
						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );
	
					} else {
	
						this._y = Math.atan2( - m31, m11 );
						this._z = 0;
	
					}
	
				} else if ( order === 'ZXY' ) {
	
					this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
					if ( Math.abs( m32 ) < 0.99999 ) {
	
						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );
	
					} else {
	
						this._y = 0;
						this._z = Math.atan2( m21, m11 );
	
					}
	
				} else if ( order === 'ZYX' ) {
	
					this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
					if ( Math.abs( m31 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );
	
					} else {
	
						this._x = 0;
						this._z = Math.atan2( - m12, m22 );
	
					}
	
				} else if ( order === 'YZX' ) {
	
					this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
					if ( Math.abs( m21 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );
	
					} else {
	
						this._x = 0;
						this._y = Math.atan2( m13, m33 );
	
					}
	
				} else if ( order === 'XZY' ) {
	
					this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
					if ( Math.abs( m12 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );
	
					} else {
	
						this._x = Math.atan2( - m23, m33 );
						this._y = 0;
	
					}
	
				} else {
	
					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
				}
	
				this._order = order;
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromQuaternion: function () {
	
				var matrix;
	
				return function setFromQuaternion( q, order, update ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.makeRotationFromQuaternion( q );
	
					return this.setFromRotationMatrix( matrix, order, update );
	
				};
	
			}(),
	
			setFromVector3: function ( v, order ) {
	
				return this.set( v.x, v.y, v.z, order || this._order );
	
			},
	
			reorder: function () {
	
				// WARNING: this discards revolution information -bhouston
	
				var q = new Quaternion();
	
				return function reorder( newOrder ) {
	
					q.setFromEuler( this );
	
					return this.setFromQuaternion( q, newOrder );
	
				};
	
			}(),
	
			equals: function ( euler ) {
	
				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
			},
	
			fromArray: function ( array ) {
	
				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;
	
				return array;
	
			},
	
			toVector3: function ( optionalResult ) {
	
				if ( optionalResult ) {
	
					return optionalResult.set( this._x, this._y, this._z );
	
				} else {
	
					return new Vector3( this._x, this._y, this._z );
	
				}
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Layers() {
	
			this.mask = 1;
	
		}
	
		Layers.prototype = {
	
			constructor: Layers,
	
			set: function ( channel ) {
	
				this.mask = 1 << channel;
	
			},
	
			enable: function ( channel ) {
	
				this.mask |= 1 << channel;
	
			},
	
			toggle: function ( channel ) {
	
				this.mask ^= 1 << channel;
	
			},
	
			disable: function ( channel ) {
	
				this.mask &= ~ ( 1 << channel );
	
			},
	
			test: function ( layers ) {
	
				return ( this.mask & layers.mask ) !== 0;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */
	
		function Object3D() {
	
			Object.defineProperty( this, 'id', { value: Object3DIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Object3D';
	
			this.parent = null;
			this.children = [];
	
			this.up = Object3D.DefaultUp.clone();
	
			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );
	
			function onRotationChange() {
	
				quaternion.setFromEuler( rotation, false );
	
			}
	
			function onQuaternionChange() {
	
				rotation.setFromQuaternion( quaternion, undefined, false );
	
			}
	
			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );
	
			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );
	
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
	
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
	
			this.layers = new Layers();
			this.visible = true;
	
			this.castShadow = false;
			this.receiveShadow = false;
	
			this.frustumCulled = true;
			this.renderOrder = 0;
	
			this.userData = {};
	
			this.onBeforeRender = function(){}; 
			this.onAfterRender = function(){};
	
		}
	
		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;
	
		Object.assign( Object3D.prototype, EventDispatcher.prototype, {
	
			isObject3D: true,
	
			applyMatrix: function ( matrix ) {
	
				this.matrix.multiplyMatrices( matrix, this.matrix );
	
				this.matrix.decompose( this.position, this.quaternion, this.scale );
	
			},
	
			setRotationFromAxisAngle: function ( axis, angle ) {
	
				// assumes axis is normalized
	
				this.quaternion.setFromAxisAngle( axis, angle );
	
			},
	
			setRotationFromEuler: function ( euler ) {
	
				this.quaternion.setFromEuler( euler, true );
	
			},
	
			setRotationFromMatrix: function ( m ) {
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				this.quaternion.setFromRotationMatrix( m );
	
			},
	
			setRotationFromQuaternion: function ( q ) {
	
				// assumes q is normalized
	
				this.quaternion.copy( q );
	
			},
	
			rotateOnAxis: function () {
	
				// rotate object on axis in object space
				// axis is assumed to be normalized
	
				var q1 = new Quaternion();
	
				return function rotateOnAxis( axis, angle ) {
	
					q1.setFromAxisAngle( axis, angle );
	
					this.quaternion.multiply( q1 );
	
					return this;
	
				};
	
			}(),
	
			rotateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function rotateX( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function rotateY( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function rotateZ( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			translateOnAxis: function () {
	
				// translate object by distance along axis in object space
				// axis is assumed to be normalized
	
				var v1 = new Vector3();
	
				return function translateOnAxis( axis, distance ) {
	
					v1.copy( axis ).applyQuaternion( this.quaternion );
	
					this.position.add( v1.multiplyScalar( distance ) );
	
					return this;
	
				};
	
			}(),
	
			translateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function translateX( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function translateY( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function translateZ( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			localToWorld: function ( vector ) {
	
				return vector.applyMatrix4( this.matrixWorld );
	
			},
	
			worldToLocal: function () {
	
				var m1 = new Matrix4();
	
				return function worldToLocal( vector ) {
	
					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
				};
	
			}(),
	
			lookAt: function () {
	
				// This routine does not support objects with rotated and/or translated parent(s)
	
				var m1 = new Matrix4();
	
				return function lookAt( vector ) {
	
					m1.lookAt( vector, this.position, this.up );
	
					this.quaternion.setFromRotationMatrix( m1 );
	
				};
	
			}(),
	
			add: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.add( arguments[ i ] );
	
					}
	
					return this;
	
				}
	
				if ( object === this ) {
	
					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;
	
				}
	
				if ( (object && object.isObject3D) ) {
	
					if ( object.parent !== null ) {
	
						object.parent.remove( object );
	
					}
	
					object.parent = this;
					object.dispatchEvent( { type: 'added' } );
	
					this.children.push( object );
	
				} else {
	
					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
				}
	
				return this;
	
			},
	
			remove: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.remove( arguments[ i ] );
	
					}
	
				}
	
				var index = this.children.indexOf( object );
	
				if ( index !== - 1 ) {
	
					object.parent = null;
	
					object.dispatchEvent( { type: 'removed' } );
	
					this.children.splice( index, 1 );
	
				}
	
			},
	
			getObjectById: function ( id ) {
	
				return this.getObjectByProperty( 'id', id );
	
			},
	
			getObjectByName: function ( name ) {
	
				return this.getObjectByProperty( 'name', name );
	
			},
	
			getObjectByProperty: function ( name, value ) {
	
				if ( this[ name ] === value ) return this;
	
				for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );
	
					if ( object !== undefined ) {
	
						return object;
	
					}
	
				}
	
				return undefined;
	
			},
	
			getWorldPosition: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.updateMatrixWorld( true );
	
				return result.setFromMatrixPosition( this.matrixWorld );
	
			},
	
			getWorldQuaternion: function () {
	
				var position = new Vector3();
				var scale = new Vector3();
	
				return function getWorldQuaternion( optionalTarget ) {
	
					var result = optionalTarget || new Quaternion();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, result, scale );
	
					return result;
	
				};
	
			}(),
	
			getWorldRotation: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldRotation( optionalTarget ) {
	
					var result = optionalTarget || new Euler();
	
					this.getWorldQuaternion( quaternion );
	
					return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
				};
	
			}(),
	
			getWorldScale: function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
	
				return function getWorldScale( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, quaternion, result );
	
					return result;
	
				};
	
			}(),
	
			getWorldDirection: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldDirection( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.getWorldQuaternion( quaternion );
	
					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
				};
	
			}(),
	
			raycast: function () {},
	
			traverse: function ( callback ) {
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverse( callback );
	
				}
	
			},
	
			traverseVisible: function ( callback ) {
	
				if ( this.visible === false ) return;
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverseVisible( callback );
	
				}
	
			},
	
			traverseAncestors: function ( callback ) {
	
				var parent = this.parent;
	
				if ( parent !== null ) {
	
					callback( parent );
	
					parent.traverseAncestors( callback );
	
				}
	
			},
	
			updateMatrix: function () {
	
				this.matrix.compose( this.position, this.quaternion, this.scale );
	
				this.matrixWorldNeedsUpdate = true;
	
			},
	
			updateMatrixWorld: function ( force ) {
	
				if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
				if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
					if ( this.parent === null ) {
	
						this.matrixWorld.copy( this.matrix );
	
					} else {
	
						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
					}
	
					this.matrixWorldNeedsUpdate = false;
	
					force = true;
	
				}
	
				// update children
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].updateMatrixWorld( force );
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );
	
				var output = {};
	
				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {
	
					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};
	
					output.metadata = {
						version: 4.4,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};
	
				}
	
				// standard Object3D serialization
	
				var object = {};
	
				object.uuid = this.uuid;
				object.type = this.type;
	
				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;
	
				object.matrix = this.matrix.toArray();
	
				//
	
				if ( this.geometry !== undefined ) {
	
					if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
						meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
					}
	
					object.geometry = this.geometry.uuid;
	
				}
	
				if ( this.material !== undefined ) {
	
					if ( meta.materials[ this.material.uuid ] === undefined ) {
	
						meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
					}
	
					object.material = this.material.uuid;
	
				}
	
				//
	
				if ( this.children.length > 0 ) {
	
					object.children = [];
	
					for ( var i = 0; i < this.children.length; i ++ ) {
	
						object.children.push( this.children[ i ].toJSON( meta ).object );
	
					}
	
				}
	
				if ( isRootObject ) {
	
					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;
	
				}
	
				output.object = object;
	
				return output;
	
				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {
	
					var values = [];
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
					return values;
	
				}
	
			},
	
			clone: function ( recursive ) {
	
				return new this.constructor().copy( this, recursive );
	
			},
	
			copy: function ( source, recursive ) {
	
				if ( recursive === undefined ) recursive = true;
	
				this.name = source.name;
	
				this.up.copy( source.up );
	
				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );
	
				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );
	
				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
				this.visible = source.visible;
	
				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;
	
				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;
	
				this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
				if ( recursive === true ) {
	
					for ( var i = 0; i < source.children.length; i ++ ) {
	
						var child = source.children[ i ];
						this.add( child.clone() );
	
					}
	
				}
	
				return this;
	
			}
	
		} );
	
		var count$2 = 0;
		function Object3DIdCount() { return count$2++; }
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Line3( start, end ) {
	
			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();
	
		}
	
		Line3.prototype = {
	
			constructor: Line3,
	
			set: function ( start, end ) {
	
				this.start.copy( start );
				this.end.copy( end );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( line ) {
	
				this.start.copy( line.start );
				this.end.copy( line.end );
	
				return this;
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
			},
	
			delta: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );
	
			},
	
			distanceSq: function () {
	
				return this.start.distanceToSquared( this.end );
	
			},
	
			distance: function () {
	
				return this.start.distanceTo( this.end );
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			closestPointToPointParameter: function () {
	
				var startP = new Vector3();
				var startEnd = new Vector3();
	
				return function closestPointToPointParameter( point, clampToLine ) {
	
					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );
	
					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );
	
					var t = startEnd_startP / startEnd2;
	
					if ( clampToLine ) {
	
						t = _Math.clamp( t, 0, 1 );
	
					}
	
					return t;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
				var t = this.closestPointToPointParameter( point, clampToLine );
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );
	
				return this;
	
			},
	
			equals: function ( line ) {
	
				return line.start.equals( this.start ) && line.end.equals( this.end );
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Triangle( a, b, c ) {
	
			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();
	
		}
	
		Triangle.normal = function () {
	
			var v0 = new Vector3();
	
			return function normal( a, b, c, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );
	
				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {
	
					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
				}
	
				return result.set( 0, 0, 0 );
	
			};
	
		}();
	
		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		Triangle.barycoordFromPoint = function () {
	
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {
	
				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );
	
				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );
	
				var denom = ( dot00 * dot11 - dot01 * dot01 );
	
				var result = optionalTarget || new Vector3();
	
				// collinear or singular triangle
				if ( denom === 0 ) {
	
					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );
	
				}
	
				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );
	
			};
	
		}();
	
		Triangle.containsPoint = function () {
	
			var v1 = new Vector3();
	
			return function containsPoint( point, a, b, c ) {
	
				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
			};
	
		}();
	
		Triangle.prototype = {
	
			constructor: Triangle,
	
			set: function ( a, b, c ) {
	
				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );
	
				return this;
	
			},
	
			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( triangle ) {
	
				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );
	
				return this;
	
			},
	
			area: function () {
	
				var v0 = new Vector3();
				var v1 = new Vector3();
	
				return function area() {
	
					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );
	
					return v0.cross( v1 ).length() * 0.5;
	
				};
	
			}(),
	
			midpoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
			},
	
			normal: function ( optionalTarget ) {
	
				return Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
			},
	
			plane: function ( optionalTarget ) {
	
				var result = optionalTarget || new Plane();
	
				return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
			},
	
			barycoordFromPoint: function ( point, optionalTarget ) {
	
				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
			},
	
			containsPoint: function ( point ) {
	
				return Triangle.containsPoint( point, this.a, this.b, this.c );
	
			},
	
			closestPointToPoint: function () {
	
				var plane, edgeList, projectedPoint, closestPoint;
	
				return function closestPointToPoint( point, optionalTarget ) {
	
					if ( plane === undefined ) {
	
						plane = new Plane();
						edgeList = [ new Line3(), new Line3(), new Line3() ];
						projectedPoint = new Vector3();
						closestPoint = new Vector3();
	
					}
	
					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;
	
					// project the point onto the plane of the triangle
	
					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );
	
					// check if the projection lies within the triangle
	
					if( this.containsPoint( projectedPoint ) === true ) {
	
						// if so, this is the closest point
	
						result.copy( projectedPoint );
	
					} else {
	
						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	
						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );
	
						for( var i = 0; i < edgeList.length; i ++ ) {
	
							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );
	
							var distance = projectedPoint.distanceToSquared( closestPoint );
	
							if( distance < minDistance ) {
	
								minDistance = distance;
	
								result.copy( closestPoint );
	
							}
	
						}
	
					}
	
					return result;
	
				};
	
			}(),
	
			equals: function ( triangle ) {
	
				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Face3( a, b, c, normal, color, materialIndex ) {
	
			this.a = a;
			this.b = b;
			this.c = c;
	
			this.normal = (normal && normal.isVector3) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
			this.color = (color && color.isColor) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];
	
			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		}
	
		Face3.prototype = {
	
			constructor: Face3,
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.a = source.a;
				this.b = source.b;
				this.c = source.c;
	
				this.normal.copy( source.normal );
				this.color.copy( source.color );
	
				this.materialIndex = source.materialIndex;
	
				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
				}
	
				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
					this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
				}
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */
	
		function MeshBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshBasicMaterial';
	
			this.color = new Color( 0xffffff ); // emissive
	
			this.map = null;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	
		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
	
		MeshBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferAttribute( array, itemSize, normalized ) {
	
			if ( Array.isArray( array ) ) {
	
				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
			}
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.version = 0;
	
		}
	
		BufferAttribute.prototype = {
	
			constructor: BufferAttribute,
	
			isBufferAttribute: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;
	
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.itemSize;
				index2 *= attribute.itemSize;
	
				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			copyArray: function ( array ) {
	
				this.array.set( array );
	
				return this;
	
			},
	
			copyColorsArray: function ( colors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
					var color = colors[ i ];
	
					if ( color === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();
	
					}
	
					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;
	
				}
	
				return this;
	
			},
	
			copyIndicesArray: function ( indices ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					var index = indices[ i ];
	
					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;
	
				}
	
				return this;
	
			},
	
			copyVector2sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
	
				}
	
				return this;
	
			},
	
			copyVector3sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
	
				}
	
				return this;
	
			},
	
			copyVector4sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.array[ index * this.itemSize ];
	
			},
	
			setX: function ( index, x ) {
	
				this.array[ index * this.itemSize ] = x;
	
				return this;
	
			},
	
			getY: function ( index ) {
	
				return this.array[ index * this.itemSize + 1 ];
	
			},
	
			setY: function ( index, y ) {
	
				this.array[ index * this.itemSize + 1 ] = y;
	
				return this;
	
			},
	
			getZ: function ( index ) {
	
				return this.array[ index * this.itemSize + 2 ];
	
			},
	
			setZ: function ( index, z ) {
	
				this.array[ index * this.itemSize + 2 ] = z;
	
				return this;
	
			},
	
			getW: function ( index ) {
	
				return this.array[ index * this.itemSize + 3 ];
	
			},
	
			setW: function ( index, w ) {
	
				this.array[ index * this.itemSize + 3 ] = w;
	
				return this;
	
			},
	
			setXY: function ( index, x, y ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			}
	
		};
	
		//
	
		function Int8Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Int8Array( array ), itemSize );
	
		}
	
		function Uint8Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Uint8Array( array ), itemSize );
	
		}
	
		function Uint8ClampedAttribute( array, itemSize ) {
	
			return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );
	
		}
	
		function Int16Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Int16Array( array ), itemSize );
	
		}
	
		function Uint16Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Uint16Array( array ), itemSize );
	
		}
	
		function Int32Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Int32Array( array ), itemSize );
	
		}
	
		function Uint32Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Uint32Array( array ), itemSize );
	
		}
	
		function Float32Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Float32Array( array ), itemSize );
	
		}
	
		function Float64Attribute( array, itemSize ) {
	
			return new BufferAttribute( new Float64Array( array ), itemSize );
	
		}
	
		// Deprecated
	
		function DynamicBufferAttribute( array, itemSize ) {
	
			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */
	
		function Geometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Geometry';
	
			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];
	
			this.morphTargets = [];
			this.morphNormals = [];
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Object.assign( Geometry.prototype, EventDispatcher.prototype, {
	
			isGeometry: true,
	
			applyMatrix: function ( matrix ) {
	
				var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );
	
				}
	
				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
					}
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1;
	
				return function rotateX( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1;
	
				return function rotateY( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1;
	
				return function rotateZ( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1;
	
				return function translate( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1;
	
				return function scale( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj;
	
				return function lookAt( vector ) {
	
					if ( obj === undefined ) obj = new Object3D();
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			fromBufferGeometry: function ( geometry ) {
	
				var scope = this;
	
				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;
	
				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];
	
				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
					if ( normals !== undefined ) {
	
						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
					}
	
					if ( colors !== undefined ) {
	
						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
					}
	
					if ( uvs !== undefined ) {
	
						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
					}
	
				}
	
				function addFace( a, b, c, materialIndex ) {
	
					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
	
					scope.faces.push( face );
	
					if ( uvs !== undefined ) {
	
						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
					}
	
				}
	
				if ( indices !== undefined ) {
	
					var groups = geometry.groups;
	
					if ( groups.length > 0 ) {
	
						for ( var i = 0; i < groups.length; i ++ ) {
	
							var group = groups[ i ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );
	
							}
	
						}
	
					} else {
	
						for ( var i = 0; i < indices.length; i += 3 ) {
	
							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
						addFace( i, i + 1, i + 2 );
	
					}
	
				}
	
				this.computeFaceNormals();
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				return this;
	
			},
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			normalize: function () {
	
				this.computeBoundingSphere();
	
				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;
	
				var s = radius === 0 ? 1 : 1.0 / radius;
	
				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);
	
				this.applyMatrix( matrix );
	
				return this;
	
			},
	
			computeFaceNormals: function () {
	
				var cb = new Vector3(), ab = new Vector3();
	
				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					var face = this.faces[ f ];
	
					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					cb.normalize();
	
					face.normal.copy( cb );
	
				}
	
			},
	
			computeVertexNormals: function ( areaWeighted ) {
	
				if ( areaWeighted === undefined ) areaWeighted = true;
	
				var v, vl, f, fl, face, vertices;
	
				vertices = new Array( this.vertices.length );
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ] = new Vector3();
	
				}
	
				if ( areaWeighted ) {
	
					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm
	
					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];
	
						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );
	
						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );
	
					}
	
				} else {
	
					this.computeFaceNormals();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );
	
					}
	
				}
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ].normalize();
	
				}
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
					} else {
	
						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeFlatVertexNormals: function () {
	
				var f, fl, face;
	
				this.computeFaceNormals();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );
	
					} else {
	
						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeMorphNormals: function () {
	
				var i, il, f, fl, face;
	
				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( ! face.__originalFaceNormal ) {
	
						face.__originalFaceNormal = face.normal.clone();
	
					} else {
	
						face.__originalFaceNormal.copy( face.normal );
	
					}
	
					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
						if ( ! face.__originalVertexNormals[ i ] ) {
	
							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
						} else {
	
							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
						}
	
					}
	
				}
	
				// use temp geometry to compute face and vertex normals for each morph
	
				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;
	
				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
					// create on first access
	
					if ( ! this.morphNormals[ i ] ) {
	
						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];
	
						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
						var faceNormal, vertexNormals;
	
						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
	
							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );
	
						}
	
					}
	
					var morphNormals = this.morphNormals[ i ];
	
					// set vertices to morph target
	
					tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
					// compute morph normals
	
					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();
	
					// store morph normals
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];
	
						faceNormal.copy( face.normal );
	
						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
					}
	
				}
	
				// restore original normals
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;
	
				}
	
			},
	
			computeTangents: function () {
	
				console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
			},
	
			computeLineDistances: function () {
	
				var d = 0;
				var vertices = this.vertices;
	
				for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
					if ( i > 0 ) {
	
						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
					}
	
					this.lineDistances[ i ] = d;
	
				}
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				this.boundingBox.setFromPoints( this.vertices );
	
			},
	
			computeBoundingSphere: function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new Sphere();
	
				}
	
				this.boundingSphere.setFromPoints( this.vertices );
	
			},
	
			merge: function ( geometry, matrix, materialIndexOffset ) {
	
				if ( (geometry && geometry.isGeometry) === false ) {
	
					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;
	
				}
	
				var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;
	
				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
				if ( matrix !== undefined ) {
	
					normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				}
	
				// vertices
	
				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
					var vertex = vertices2[ i ];
	
					var vertexCopy = vertex.clone();
	
					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
					vertices1.push( vertexCopy );
	
				}
	
				// colors
	
				for ( var i = 0, il = colors2.length; i < il; i ++ ) {
	
					colors1.push( colors2[ i ].clone() );
	
				}
	
				// faces
	
				for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
					var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;
	
					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );
	
					if ( normalMatrix !== undefined ) {
	
						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
						normal = faceVertexNormals[ j ].clone();
	
						if ( normalMatrix !== undefined ) {
	
							normal.applyMatrix3( normalMatrix ).normalize();
	
						}
	
						faceCopy.vertexNormals.push( normal );
	
					}
	
					faceCopy.color.copy( face.color );
	
					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );
	
					}
	
					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
					faces1.push( faceCopy );
	
				}
	
				// uvs
	
				for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
					var uv = uvs2[ i ], uvCopy = [];
	
					if ( uv === undefined ) {
	
						continue;
	
					}
	
					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
						uvCopy.push( uv[ j ].clone() );
	
					}
	
					uvs1.push( uvCopy );
	
				}
	
			},
	
			mergeMesh: function ( mesh ) {
	
				if ( (mesh && mesh.isMesh) === false ) {
	
					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;
	
				}
	
				mesh.matrixAutoUpdate && mesh.updateMatrix();
	
				this.merge( mesh.geometry, mesh.matrix );
	
			},
	
			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */
	
			mergeVertices: function () {
	
				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];
	
				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;
	
				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
					if ( verticesMap[ key ] === undefined ) {
	
						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;
	
					} else {
	
						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];
	
					}
	
				}
	
	
				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];
	
				for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
					face = this.faces[ i ];
	
					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];
	
					indices = [ face.a, face.b, face.c ];
	
					var dupIndex = - 1;
	
					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {
	
						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
							dupIndex = n;
							faceIndicesToRemove.push( i );
							break;
	
						}
	
					}
	
				}
	
				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
					var idx = faceIndicesToRemove[ i ];
	
					this.faces.splice( idx, 1 );
	
					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
						this.faceVertexUvs[ j ].splice( idx, 1 );
	
					}
	
				}
	
				// Use unique set of vertices
	
				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;
	
			},
	
			sortFacesByMaterialIndex: function () {
	
				var faces = this.faces;
				var length = faces.length;
	
				// tag faces
	
				for ( var i = 0; i < length; i ++ ) {
	
					faces[ i ]._id = i;
	
				}
	
				// sort faces
	
				function materialIndexSort( a, b ) {
	
					return a.materialIndex - b.materialIndex;
	
				}
	
				faces.sort( materialIndexSort );
	
				// sort uvs
	
				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];
	
				var newUvs1, newUvs2;
	
				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
				for ( var i = 0; i < length; i ++ ) {
	
					var id = faces[ i ]._id;
	
					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
				}
	
				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};
	
				// standard Geometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				var vertices = [];
	
				for ( var i = 0; i < this.vertices.length; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};
	
				for ( var i = 0; i < this.faces.length; i ++ ) {
	
					var face = this.faces[ i ];
	
					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;
	
					var faceType = 0;
	
					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );
	
					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );
	
					if ( hasFaceVertexUv ) {
	
						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);
	
					}
	
					if ( hasFaceNormal ) {
	
						faces.push( getNormalIndex( face.normal ) );
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						var vertexNormals = face.vertexNormals;
	
						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);
	
					}
	
					if ( hasFaceColor ) {
	
						faces.push( getColorIndex( face.color ) );
	
					}
	
					if ( hasFaceVertexColor ) {
	
						var vertexColors = face.vertexColors;
	
						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);
	
					}
	
				}
	
				function setBit( value, position, enabled ) {
	
					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
				}
	
				function getNormalIndex( normal ) {
	
					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
					if ( normalsHash[ hash ] !== undefined ) {
	
						return normalsHash[ hash ];
	
					}
	
					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );
	
					return normalsHash[ hash ];
	
				}
	
				function getColorIndex( color ) {
	
					var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
					if ( colorsHash[ hash ] !== undefined ) {
	
						return colorsHash[ hash ];
	
					}
	
					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );
	
					return colorsHash[ hash ];
	
				}
	
				function getUvIndex( uv ) {
	
					var hash = uv.x.toString() + uv.y.toString();
	
					if ( uvsHash[ hash ] !== undefined ) {
	
						return uvsHash[ hash ];
	
					}
	
					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );
	
					return uvsHash[ hash ];
	
				}
	
				data.data = {};
	
				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				// Handle primitives
	
				var parameters = this.parameters;
	
				if ( parameters !== undefined ) {
	
					var values = [];
	
					for ( var key in parameters ) {
	
						values.push( parameters[ key ] );
	
					}
	
					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;
	
				}
	
				return new this.constructor().copy( this );
				*/
	
				return new Geometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.vertices = [];
				this.faces = [];
				this.faceVertexUvs = [ [] ];
				this.colors = [];
	
				var vertices = source.vertices;
	
				for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
					this.vertices.push( vertices[ i ].clone() );
	
				}
	
				var colors = source.colors;
	
				for ( var i = 0, il = colors.length; i < il; i ++ ) {
	
					this.colors.push( colors[ i ].clone() );
	
				}
	
				var faces = source.faces;
	
				for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
					this.faces.push( faces[ i ].clone() );
	
				}
	
				for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
					var faceVertexUvs = source.faceVertexUvs[ i ];
	
					if ( this.faceVertexUvs[ i ] === undefined ) {
	
						this.faceVertexUvs[ i ] = [];
	
					}
	
					for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
						var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
						for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {
	
							var uv = uvs[ k ];
	
							uvsCopy.push( uv.clone() );
	
						}
	
						this.faceVertexUvs[ i ].push( uvsCopy );
	
					}
	
				}
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		var count$3 = 0;
		function GeometryIdCount() { return count$3++; }
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectGeometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'DirectGeometry';
	
			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];
	
			this.groups = [];
	
			this.morphTargets = {};
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			// this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {
	
			computeBoundingBox: Geometry.prototype.computeBoundingBox,
			computeBoundingSphere: Geometry.prototype.computeBoundingSphere,
	
			computeFaceNormals: function () {
	
				console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
	
			},
	
			computeVertexNormals: function () {
	
				console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
	
			},
	
			computeGroups: function ( geometry ) {
	
				var group;
				var groups = [];
				var materialIndex;
	
				var faces = geometry.faces;
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					// materials
	
					if ( face.materialIndex !== materialIndex ) {
	
						materialIndex = face.materialIndex;
	
						if ( group !== undefined ) {
	
							group.count = ( i * 3 ) - group.start;
							groups.push( group );
	
						}
	
						group = {
							start: i * 3,
							materialIndex: materialIndex
						};
	
					}
	
				}
	
				if ( group !== undefined ) {
	
					group.count = ( i * 3 ) - group.start;
					groups.push( group );
	
				}
	
				this.groups = groups;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;
	
				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
				// morphs
	
				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;
	
				var morphTargetsPosition;
	
				if ( morphTargetsLength > 0 ) {
	
					morphTargetsPosition = [];
	
					for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
						morphTargetsPosition[ i ] = [];
	
					}
	
					this.morphTargets.position = morphTargetsPosition;
	
				}
	
				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;
	
				var morphTargetsNormal;
	
				if ( morphNormalsLength > 0 ) {
	
					morphTargetsNormal = [];
	
					for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
						morphTargetsNormal[ i ] = [];
	
					}
	
					this.morphTargets.normal = morphTargetsNormal;
	
				}
	
				// skins
	
				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;
	
				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;
	
				//
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
					} else {
	
						var normal = face.normal;
	
						this.normals.push( normal, normal, normal );
	
					}
	
					var vertexColors = face.vertexColors;
	
					if ( vertexColors.length === 3 ) {
	
						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
					} else {
	
						var color = face.color;
	
						this.colors.push( color, color, color );
	
					}
	
					if ( hasFaceVertexUv === true ) {
	
						var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					if ( hasFaceVertexUv2 === true ) {
	
						var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					// morphs
	
					for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
						var morphTarget = morphTargets[ j ].vertices;
	
						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
					}
	
					for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
						var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
					}
	
					// skins
	
					if ( hasSkinIndices ) {
	
						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
					}
	
					if ( hasSkinWeights ) {
	
						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
					}
	
				}
	
				this.computeGroups( geometry );
	
				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'BufferGeometry';
	
			this.index = null;
			this.attributes = {};
	
			this.morphAttributes = {};
	
			this.groups = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			this.drawRange = { start: 0, count: Infinity };
	
		}
	
		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {
	
			isBufferGeometry: true,
	
			getIndex: function () {
	
				return this.index;
	
			},
	
			setIndex: function ( index ) {
	
				this.index = index;
	
			},
	
			addAttribute: function ( name, attribute ) {
	
				if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {
	
					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
					return;
	
				}
	
				if ( name === 'index' ) {
	
					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );
	
					return;
	
				}
	
				this.attributes[ name ] = attribute;
	
				return this;
	
			},
	
			getAttribute: function ( name ) {
	
				return this.attributes[ name ];
	
			},
	
			removeAttribute: function ( name ) {
	
				delete this.attributes[ name ];
	
				return this;
	
			},
	
			addGroup: function ( start, count, materialIndex ) {
	
				this.groups.push( {
	
					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0
	
				} );
	
			},
	
			clearGroups: function () {
	
				this.groups = [];
	
			},
	
			setDrawRange: function ( start, count ) {
	
				this.drawRange.start = start;
				this.drawRange.count = count;
	
			},
	
			applyMatrix: function ( matrix ) {
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					matrix.applyToVector3Array( position.array );
					position.needsUpdate = true;
	
				}
	
				var normal = this.attributes.normal;
	
				if ( normal !== undefined ) {
	
					var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
					normalMatrix.applyToVector3Array( normal.array );
					normal.needsUpdate = true;
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1;
	
				return function rotateX( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1;
	
				return function rotateY( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1;
	
				return function rotateZ( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1;
	
				return function translate( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1;
	
				return function scale( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj;
	
				return function lookAt( vector ) {
	
					if ( obj === undefined ) obj = new Object3D();
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			setFromObject: function ( object ) {
	
				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
				var geometry = object.geometry;
	
				if ( (object && object.isPoints) || (object && object.isLine) ) {
	
					var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32Attribute( geometry.colors.length * 3, 3 );
	
					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
						var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );
	
						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
					}
	
					if ( geometry.boundingSphere !== null ) {
	
						this.boundingSphere = geometry.boundingSphere.clone();
	
					}
	
					if ( geometry.boundingBox !== null ) {
	
						this.boundingBox = geometry.boundingBox.clone();
	
					}
	
				} else if ( (object && object.isMesh) ) {
	
					if ( (geometry && geometry.isGeometry) ) {
	
						this.fromGeometry( geometry );
	
					}
	
				}
	
				return this;
	
			},
	
			updateFromObject: function ( object ) {
	
				var geometry = object.geometry;
	
				if ( (object && object.isMesh) ) {
	
					var direct = geometry.__directGeometry;
	
					if ( geometry.elementsNeedUpdate === true ) {
	
						direct = undefined;
						geometry.elementsNeedUpdate = false;
	
					}
	
					if ( direct === undefined ) {
	
						return this.fromGeometry( geometry );
	
					}
	
					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;
	
					geometry = direct;
	
				}
	
				var attribute;
	
				if ( geometry.verticesNeedUpdate === true ) {
	
					attribute = this.attributes.position;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;
	
					}
	
					geometry.verticesNeedUpdate = false;
	
				}
	
				if ( geometry.normalsNeedUpdate === true ) {
	
					attribute = this.attributes.normal;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;
	
					}
	
					geometry.normalsNeedUpdate = false;
	
				}
	
				if ( geometry.colorsNeedUpdate === true ) {
	
					attribute = this.attributes.color;
	
					if ( attribute !== undefined ) {
	
						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;
	
					}
	
					geometry.colorsNeedUpdate = false;
	
				}
	
				if ( geometry.uvsNeedUpdate ) {
	
					attribute = this.attributes.uv;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;
	
					}
	
					geometry.uvsNeedUpdate = false;
	
				}
	
				if ( geometry.lineDistancesNeedUpdate ) {
	
					attribute = this.attributes.lineDistance;
	
					if ( attribute !== undefined ) {
	
						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;
	
					}
	
					geometry.lineDistancesNeedUpdate = false;
	
				}
	
				if ( geometry.groupsNeedUpdate ) {
	
					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;
	
					geometry.groupsNeedUpdate = false;
	
				}
	
				return this;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
	
				return this.fromDirectGeometry( geometry.__directGeometry );
	
			},
	
			fromDirectGeometry: function ( geometry ) {
	
				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
				if ( geometry.normals.length > 0 ) {
	
					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
				}
	
				if ( geometry.colors.length > 0 ) {
	
					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
				}
	
				if ( geometry.uvs.length > 0 ) {
	
					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
				}
	
				if ( geometry.uvs2.length > 0 ) {
	
					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
				}
	
				if ( geometry.indices.length > 0 ) {
	
					var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
				}
	
				// groups
	
				this.groups = geometry.groups;
	
				// morphs
	
				for ( var name in geometry.morphTargets ) {
	
					var array = [];
					var morphTargets = geometry.morphTargets[ name ];
	
					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
						var morphTarget = morphTargets[ i ];
	
						var attribute = new Float32Attribute( morphTarget.length * 3, 3 );
	
						array.push( attribute.copyVector3sArray( morphTarget ) );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// skinning
	
				if ( geometry.skinIndices.length > 0 ) {
	
					var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
				}
	
				if ( geometry.skinWeights.length > 0 ) {
	
					var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
				}
	
				//
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				return this;
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				var positions = this.attributes.position.array;
	
				if ( positions !== undefined ) {
	
					this.boundingBox.setFromArray( positions );
	
				} else {
	
					this.boundingBox.makeEmpty();
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			},
	
			computeBoundingSphere: function () {
	
				var box = new Box3();
				var vector = new Vector3();
	
				return function computeBoundingSphere() {
	
					if ( this.boundingSphere === null ) {
	
						this.boundingSphere = new Sphere();
	
					}
	
					var positions = this.attributes.position;
	
					if ( positions ) {
	
						var array = positions.array;
						var center = this.boundingSphere.center;
	
						box.setFromArray( array );
						box.getCenter( center );
	
						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
						var maxRadiusSq = 0;
	
						for ( var i = 0, il = array.length; i < il; i += 3 ) {
	
							vector.fromArray( array, i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
						}
	
						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
						if ( isNaN( this.boundingSphere.radius ) ) {
	
							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
						}
	
					}
	
				};
	
			}(),
	
			computeFaceNormals: function () {
	
				// backwards compatibility
	
			},
	
			computeVertexNormals: function () {
	
				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;
	
				if ( attributes.position ) {
	
					var positions = attributes.position.array;
	
					if ( attributes.normal === undefined ) {
	
						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
					} else {
	
						// reset existing normals to zero
	
						var array = attributes.normal.array;
	
						for ( var i = 0, il = array.length; i < il; i ++ ) {
	
							array[ i ] = 0;
	
						}
	
					}
	
					var normals = attributes.normal.array;
	
					var vA, vB, vC,
	
					pA = new Vector3(),
					pB = new Vector3(),
					pC = new Vector3(),
	
					cb = new Vector3(),
					ab = new Vector3();
	
					// indexed elements
	
					if ( index ) {
	
						var indices = index.array;
	
						if ( groups.length === 0 ) {
	
							this.addGroup( 0, indices.length );
	
						}
	
						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
							var group = groups[ j ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var i = start, il = start + count; i < il; i += 3 ) {
	
								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;
	
								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );
	
								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );
	
								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;
	
								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;
	
								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;
	
							}
	
						}
	
					} else {
	
						// non-indexed elements (unconnected triangle soup)
	
						for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;
	
							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;
	
							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;
	
						}
	
					}
	
					this.normalizeNormals();
	
					attributes.normal.needsUpdate = true;
	
				}
	
			},
	
			merge: function ( geometry, offset ) {
	
				if ( (geometry && geometry.isBufferGeometry) === false ) {
	
					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;
	
				}
	
				if ( offset === undefined ) offset = 0;
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					if ( geometry.attributes[ key ] === undefined ) continue;
	
					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;
	
					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;
	
					var attributeSize = attribute2.itemSize;
	
					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
						attributeArray1[ j ] = attributeArray2[ i ];
	
					}
	
				}
	
				return this;
	
			},
	
			normalizeNormals: function () {
	
				var normals = this.attributes.normal.array;
	
				var x, y, z, n;
	
				for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
					x = normals[ i ];
					y = normals[ i + 1 ];
					z = normals[ i + 2 ];
	
					n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
					normals[ i ] *= n;
					normals[ i + 1 ] *= n;
					normals[ i + 2 ] *= n;
	
				}
	
			},
	
			toNonIndexed: function () {
	
				if ( this.index === null ) {
	
					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;
	
				}
	
				var geometry2 = new BufferGeometry();
	
				var indices = this.index.array;
				var attributes = this.attributes;
	
				for ( var name in attributes ) {
	
					var attribute = attributes[ name ];
	
					var array = attribute.array;
					var itemSize = attribute.itemSize;
	
					var array2 = new array.constructor( indices.length * itemSize );
	
					var index = 0, index2 = 0;
	
					for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
						index = indices[ i ] * itemSize;
	
						for ( var j = 0; j < itemSize; j ++ ) {
	
							array2[ index2 ++ ] = array[ index ++ ];
	
						}
	
					}
	
					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
	
				}
	
				return geometry2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};
	
				// standard BufferGeometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				data.data = { attributes: {} };
	
				var index = this.index;
	
				if ( index !== null ) {
	
					var array = Array.prototype.slice.call( index.array );
	
					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};
	
				}
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
	
					var array = Array.prototype.slice.call( attribute.array );
	
					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};
	
				}
	
				var groups = this.groups;
	
				if ( groups.length > 0 ) {
	
					data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
				}
	
				var boundingSphere = this.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				// Handle primitives
	
				var parameters = this.parameters;
	
				if ( parameters !== undefined ) {
	
					var values = [];
	
					for ( var key in parameters ) {
	
						values.push( parameters[ key ] );
	
					}
	
					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;
	
				}
	
				return new this.constructor().copy( this );
				*/
	
				return new BufferGeometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var index = source.index;
	
				if ( index !== null ) {
	
					this.setIndex( index.clone() );
	
				}
	
				var attributes = source.attributes;
	
				for ( var name in attributes ) {
	
					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );
	
				}
	
				var groups = source.groups;
	
				for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		BufferGeometry.MaxIndex = 65535;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */
	
		function Mesh( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Mesh';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
			this.drawMode = TrianglesDrawMode;
	
			this.updateMorphTargets();
	
		}
	
		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Mesh,
	
			isMesh: true,
	
			setDrawMode: function ( value ) {
	
				this.drawMode = value;
	
			},
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.drawMode = source.drawMode;
	
				return this;
	
			},
	
			updateMorphTargets: function () {
	
				var morphTargets = this.geometry.morphTargets;
	
				if ( morphTargets !== undefined && morphTargets.length > 0 ) {
	
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
	
					for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {
	
						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ morphTargets[ m ].name ] = m;
	
					}
	
				}
	
			},
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();
	
				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				var barycoord = new Vector3();
	
				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();
	
				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );
	
					uv1.add( uv2 ).add( uv3 );
	
					return uv1.clone();
	
				}
	
				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
					var intersect;
					var material = object.material;
	
					if ( material.side === BackSide ) {
	
						intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
					} else {
	
						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
	
					}
	
					if ( intersect === null ) return null;
	
					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};
	
				}
	
				function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {
	
					vA.fromArray( positions, a * 3 );
					vB.fromArray( positions, b * 3 );
					vC.fromArray( positions, c * 3 );
	
					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uvs ) {
	
							uvA.fromArray( uvs, a * 2 );
							uvB.fromArray( uvs, b * 2 );
							uvC.fromArray( uvs, c * 2 );
	
							intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );
	
						}
	
						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;
	
					}
	
					return intersection;
	
				}
	
				return function raycast( raycaster, intersects ) {
	
					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;
	
					if ( material === undefined ) return;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					// Check boundingBox before continuing
	
					if ( geometry.boundingBox !== null ) {
	
						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
					}
	
					var uvs, intersection;
	
					if ( (geometry && geometry.isBufferGeometry) ) {
	
						var a, b, c;
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( attributes.uv !== undefined ) {
	
							uvs = attributes.uv.array;
	
						}
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, l = indices.length; i < l; i += 3 ) {
	
								a = indices[ i ];
								b = indices[ i + 1 ];
								c = indices[ i + 2 ];
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
								if ( intersection ) {
	
									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						} else {
	
	
							for ( var i = 0, l = positions.length; i < l; i += 9 ) {
	
								a = i / 3;
								b = a + 1;
								c = a + 2;
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );
	
								if ( intersection ) {
	
									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						}
	
					} else if ( (geometry && geometry.isGeometry) ) {
	
						var fvA, fvB, fvC;
						var isFaceMaterial = (material && material.isMultiMaterial);
						var materials = isFaceMaterial === true ? material.materials : null;
	
						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
							var face = faces[ f ];
							var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
							if ( faceMaterial === undefined ) continue;
	
							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];
	
							if ( faceMaterial.morphTargets === true ) {
	
								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;
	
								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );
	
								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
									var influence = morphInfluences[ t ];
	
									if ( influence === 0 ) continue;
	
									var targets = morphTargets[ t ].vertices;
	
									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
								}
	
								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );
	
								fvA = vA;
								fvB = vB;
								fvC = vC;
	
							}
	
							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
							if ( intersection ) {
	
								if ( uvs ) {
	
									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );
	
									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
								}
	
								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );
	
							}
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'BoxBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			var scope = this;
	
			// segments
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;
	
			// these are used to calculate buffer length
			var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
			var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );
	
			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );
	
			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;
			var numberOfVertices = 0;
	
			// group variables
			var groupStart = 0;
	
			// build each side of the box geometry
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz
	
			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );
	
			// helper functions
	
			function calculateVertexCount( w, h, d ) {
	
				var vertices = 0;
	
				// calculate the amount of vertices for each side (plane)
				vertices += (w + 1) * (h + 1) * 2; // xy
				vertices += (w + 1) * (d + 1) * 2; // xz
				vertices += (d + 1) * (h + 1) * 2; // zy
	
				return vertices;
	
			}
	
			function calculateIndexCount( w, h, d ) {
	
				var index = 0;
	
				// calculate the amount of squares for each side
				index += w * h * 2; // xy
				index += w * d * 2; // xz
				index += d * h * 2; // zy
	
				return index * 6; // two triangles per square => six vertices per square
	
			}
	
			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
	
				var segmentWidth	= width / gridX;
				var segmentHeight = height / gridY;
	
				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;
	
				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;
	
				var vertexCounter = 0;
				var groupCount = 0;
	
				var vector = new Vector3();
	
				// generate vertices, normals and uvs
	
				for ( var iy = 0; iy < gridY1; iy ++ ) {
	
					var y = iy * segmentHeight - heightHalf;
	
					for ( var ix = 0; ix < gridX1; ix ++ ) {
	
						var x = ix * segmentWidth - widthHalf;
	
						// set values to correct vector component
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;
	
						// now apply vector to vertex buffer
						vertices[ vertexBufferOffset ] = vector.x;
						vertices[ vertexBufferOffset + 1 ] = vector.y;
						vertices[ vertexBufferOffset + 2 ] = vector.z;
	
						// set values to correct vector component
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;
	
						// now apply vector to normal buffer
						normals[ vertexBufferOffset ] = vector.x;
						normals[ vertexBufferOffset + 1 ] = vector.y;
						normals[ vertexBufferOffset + 2 ] = vector.z;
	
						// uvs
						uvs[ uvBufferOffset ] = ix / gridX;
						uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );
	
						// update offsets and counters
						vertexBufferOffset += 3;
						uvBufferOffset += 2;
						vertexCounter += 1;
	
					}
	
				}
	
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment
	
				for ( iy = 0; iy < gridY; iy ++ ) {
	
					for ( ix = 0; ix < gridX; ix ++ ) {
	
						// indices
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
	
						// face one
						indices[ indexBufferOffset ] = a;
						indices[ indexBufferOffset + 1 ] = b;
						indices[ indexBufferOffset + 2 ] = d;
	
						// face two
						indices[ indexBufferOffset + 3 ] = b;
						indices[ indexBufferOffset + 4 ] = c;
						indices[ indexBufferOffset + 5 ] = d;
	
						// update offsets and counters
						indexBufferOffset += 6;
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, materialIndex );
	
				// calculate new start value for groups
				groupStart += groupCount;
	
				// update total number of vertices
				numberOfVertices += vertexCounter;
	
			}
	
		}
	
		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */
	
		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PlaneBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			var width_half = width / 2;
			var height_half = height / 2;
	
			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;
	
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
	
			var segment_width = width / gridX;
			var segment_height = height / gridY;
	
			var vertices = new Float32Array( gridX1 * gridY1 * 3 );
			var normals = new Float32Array( gridX1 * gridY1 * 3 );
			var uvs = new Float32Array( gridX1 * gridY1 * 2 );
	
			var offset = 0;
			var offset2 = 0;
	
			for ( var iy = 0; iy < gridY1; iy ++ ) {
	
				var y = iy * segment_height - height_half;
	
				for ( var ix = 0; ix < gridX1; ix ++ ) {
	
					var x = ix * segment_width - width_half;
	
					vertices[ offset ] = x;
					vertices[ offset + 1 ] = - y;
	
					normals[ offset + 2 ] = 1;
	
					uvs[ offset2 ] = ix / gridX;
					uvs[ offset2 + 1 ] = 1 - ( iy / gridY );
	
					offset += 3;
					offset2 += 2;
	
				}
	
			}
	
			offset = 0;
	
			var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );
	
			for ( var iy = 0; iy < gridY; iy ++ ) {
	
				for ( var ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					indices[ offset ] = a;
					indices[ offset + 1 ] = b;
					indices[ offset + 2 ] = d;
	
					indices[ offset + 3 ] = b;
					indices[ offset + 4 ] = c;
					indices[ offset + 5 ] = d;
	
					offset += 6;
	
				}
	
			}
	
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );
	
		}
	
		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function Camera() {
	
			Object3D.call( this );
	
			this.type = 'Camera';
	
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
	
		}
	
		Camera.prototype = Object.create( Object3D.prototype );
		Camera.prototype.constructor = Camera;
	
		Camera.prototype.isCamera = true;
	
		Camera.prototype.getWorldDirection = function () {
	
			var quaternion = new Quaternion();
	
			return function getWorldDirection( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
			};
	
		}();
	
		Camera.prototype.lookAt = function () {
	
			// This routine does not support cameras with rotated and/or translated parent(s)
	
			var m1 = new Matrix4();
	
			return function lookAt( vector ) {
	
				m1.lookAt( this.position, vector, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}();
	
		Camera.prototype.clone = function () {
	
			return new this.constructor().copy( this );
	
		};
	
		Camera.prototype.copy = function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */
	
		function PerspectiveCamera( fov, aspect, near, far ) {
	
			Camera.call( this );
	
			this.type = 'PerspectiveCamera';
	
			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;
	
			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;
	
			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;
	
			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
	
			this.updateProjectionMatrix();
	
		}
	
		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: PerspectiveCamera,
	
			isPerspectiveCamera: true,
	
			copy: function ( source ) {
	
				Camera.prototype.copy.call( this, source );
	
				this.fov = source.fov;
				this.zoom = source.zoom;
	
				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;
	
				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;
	
				return this;
	
			},
	
			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {
	
				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	
				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();
	
			},
	
			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {
	
				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
	
				return 0.5 * this.getFilmHeight() / vExtentSlope;
	
			},
	
			getEffectiveFOV: function () {
	
				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	
			},
	
			getFilmWidth: function () {
	
				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );
	
			},
	
			getFilmHeight: function () {
	
				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );
	
			},
	
			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
				this.aspect = fullWidth / fullHeight;
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;
	
				if ( view !== null ) {
	
					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;
	
					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;
	
				}
	
				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
	
				this.projectionMatrix.makeFrustum(
						left, left + width, top - height, top, near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.fov = this.fov;
				data.object.zoom = this.zoom;
	
				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;
	
				data.object.aspect = this.aspect;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */
	
		function OrthographicCamera( left, right, top, bottom, near, far ) {
	
			Camera.call( this );
	
			this.type = 'OrthographicCamera';
	
			this.zoom = 1;
			this.view = null;
	
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
	
			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;
	
			this.updateProjectionMatrix();
	
		}
	
		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: OrthographicCamera,
	
			isOrthographicCamera: true,
	
			copy: function ( source ) {
	
				Camera.prototype.copy.call( this, source );
	
				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;
	
				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				return this;
	
			},
	
			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;
	
				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;
	
				if ( this.view !== null ) {
	
					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;
	
					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );
	
				}
	
				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			var type, size;
	
			function setIndex( index ) {
	
				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
					type = gl.UNSIGNED_INT;
					size = 4;
	
				} else {
	
					type = gl.UNSIGNED_SHORT;
					size = 2;
	
				}
	
			}
	
			function render( start, count ) {
	
				gl.drawElements( mode, count, type, start * size );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry, start, count ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			return {
	
				setMode: setMode,
				setIndex: setIndex,
				render: render,
				renderInstances: renderInstances
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			function render( start, count ) {
	
				gl.drawArrays( mode, start, count );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				var position = geometry.attributes.position;
	
				var count = 0;
	
				if ( (position && position.isInterleavedBufferAttribute) ) {
	
					count = position.data.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				} else {
	
					count = position.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				}
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			return {
				setMode: setMode,
				render: render,
				renderInstances: renderInstances
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLLights() {
	
			var lights = {};
	
			return {
	
				get: function ( light ) {
	
					if ( lights[ light.id ] !== undefined ) {
	
						return lights[ light.id ];
	
					}
	
					var uniforms;
	
					switch ( light.type ) {
	
						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color(),
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;
	
					}
	
					lights[ light.id ] = uniforms;
	
					return uniforms;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var programIdCount = 0;
	
		function getEncodingComponents( encoding ) {
	
			switch ( encoding ) {
	
				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );
	
			}
	
		}
	
		function getTexelDecodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";
	
		}
	
		function getTexelEncodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";
	
		}
	
		function getToneMappingFunction( functionName, toneMapping ) {
	
			var toneMappingName;
	
			switch ( toneMapping ) {
	
				case LinearToneMapping:
					toneMappingName = "Linear";
					break;
	
				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;
	
				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;
	
				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;
	
				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );
	
			}
	
			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
	
		}
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function parseIncludes( string ) {
	
			var pattern = /#include +<([\w\d.]+)>/g;
	
			function replace( match, include ) {
	
				var replace = ShaderChunk[ include ];
	
				if ( replace === undefined ) {
	
					throw new Error( 'Can not resolve #include <' + include + '>' );
	
				}
	
				return parseIncludes( replace );
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;
	
					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material.isRawShaderMaterial ) {
	
				prefixVertex = [
	
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			} else {
	
				prefixVertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
	
					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',
	
					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',
	
					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );
	
			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( ! material.isShaderMaterial ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms =
							new WebGLUniforms( gl, program, renderer );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLPrograms( renderer, capabilities ) {
	
			var programs = [];
	
			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};
	
			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
			];
	
	
			function allocateBones( object ) {
	
				if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
					return 1024;
	
				} else {
	
					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)
	
					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
					var maxBones = nVertexMatrices;
	
					if ( object !== undefined && (object && object.isSkinnedMesh) ) {
	
						maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
						if ( maxBones < object.skeleton.bones.length ) {
	
							console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
						}
	
					}
	
					return maxBones;
	
				}
	
			}
	
			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
	
				var encoding;
	
				if ( ! map ) {
	
					encoding = LinearEncoding;
	
				} else if ( (map && map.isTexture) ) {
	
					encoding = map.encoding;
	
				} else if ( (map && map.isWebGLRenderTarget) ) {
	
					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;
	
				}
	
				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {
	
					encoding = GammaEncoding;
	
				}
	
				return encoding;
	
			}
	
			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {
	
				var shaderID = shaderIDs[ material.type ];
	
				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)
	
				var maxBones = allocateBones( object );
				var precision = renderer.getPrecision();
	
				if ( material.precision !== null ) {
	
					precision = capabilities.getMaxPrecision( material.precision );
	
					if ( precision !== material.precision ) {
	
						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
					}
	
				}
	
				var currentRenderTarget = renderer.getCurrentRenderTarget();
	
				var parameters = {
	
					shaderID: shaderID,
	
					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !! material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,
	
					combine: material.combine,
	
					vertexColors: material.vertexColors,
	
					fog: !! fog,
					useFog: material.fog,
					fogExp: (fog && fog.isFogExp2),
	
					flatShading: material.shading === FlatShading,
	
					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
					skinning: material.skinning,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,
	
					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numHemiLights: lights.hemi.length,
	
					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,
	
					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,
	
					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,
	
					premultipliedAlpha: material.premultipliedAlpha,
	
					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,
	
					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
	
				};
	
				return parameters;
	
			};
	
			this.getProgramCode = function ( material, parameters ) {
	
				var array = [];
	
				if ( parameters.shaderID ) {
	
					array.push( parameters.shaderID );
	
				} else {
	
					array.push( material.fragmentShader );
					array.push( material.vertexShader );
	
				}
	
				if ( material.defines !== undefined ) {
	
					for ( var name in material.defines ) {
	
						array.push( name );
						array.push( material.defines[ name ] );
	
					}
	
				}
	
				for ( var i = 0; i < parameterNames.length; i ++ ) {
	
					array.push( parameters[ parameterNames[ i ] ] );
	
				}
	
				return array.join();
	
			};
	
			this.acquireProgram = function ( material, parameters, code ) {
	
				var program;
	
				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
					var programInfo = programs[ p ];
	
					if ( programInfo.code === code ) {
	
						program = programInfo;
						++ program.usedTimes;
	
						break;
	
					}
	
				}
	
				if ( program === undefined ) {
	
					program = new WebGLProgram( renderer, code, material, parameters );
					programs.push( program );
	
				}
	
				return program;
	
			};
	
			this.releaseProgram = function( program ) {
	
				if ( -- program.usedTimes === 0 ) {
	
					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();
	
					// Free WebGL resources
					program.destroy();
	
				}
	
			};
	
			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLGeometries( gl, properties, info ) {
	
			var geometries = {};
	
			function onGeometryDispose( event ) {
	
				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];
	
				if ( buffergeometry.index !== null ) {
	
					deleteAttribute( buffergeometry.index );
	
				}
	
				deleteAttributes( buffergeometry.attributes );
	
				geometry.removeEventListener( 'dispose', onGeometryDispose );
	
				delete geometries[ geometry.id ];
	
				// TODO
	
				var property = properties.get( geometry );
	
				if ( property.wireframe ) {
	
					deleteAttribute( property.wireframe );
	
				}
	
				properties.delete( geometry );
	
				var bufferproperty = properties.get( buffergeometry );
	
				if ( bufferproperty.wireframe ) {
	
					deleteAttribute( bufferproperty.wireframe );
	
				}
	
				properties.delete( buffergeometry );
	
				//
	
				info.memory.geometries --;
	
			}
	
			function getAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data ).__webglBuffer;
	
				}
	
				return properties.get( attribute ).__webglBuffer;
	
			}
	
			function deleteAttribute( attribute ) {
	
				var buffer = getAttributeBuffer( attribute );
	
				if ( buffer !== undefined ) {
	
					gl.deleteBuffer( buffer );
					removeAttributeBuffer( attribute );
	
				}
	
			}
	
			function deleteAttributes( attributes ) {
	
				for ( var name in attributes ) {
	
					deleteAttribute( attributes[ name ] );
	
				}
	
			}
	
			function removeAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					properties.delete( attribute.data );
	
				} else {
	
					properties.delete( attribute );
	
				}
	
			}
	
			return {
	
				get: function ( object ) {
	
					var geometry = object.geometry;
	
					if ( geometries[ geometry.id ] !== undefined ) {
	
						return geometries[ geometry.id ];
	
					}
	
					geometry.addEventListener( 'dispose', onGeometryDispose );
	
					var buffergeometry;
	
					if ( geometry.isBufferGeometry ) {
	
						buffergeometry = geometry;
	
					} else if ( geometry.isGeometry ) {
	
						if ( geometry._bufferGeometry === undefined ) {
	
							geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
	
						}
	
						buffergeometry = geometry._bufferGeometry;
	
					}
	
					geometries[ geometry.id ] = buffergeometry;
	
					info.memory.geometries ++;
	
					return buffergeometry;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLObjects( gl, properties, info ) {
	
			var geometries = new WebGLGeometries( gl, properties, info );
	
			//
	
			function update( object ) {
	
				// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
				var geometry = geometries.get( object );
	
				if ( object.geometry.isGeometry ) {
	
					geometry.updateFromObject( object );
	
				}
	
				var index = geometry.index;
				var attributes = geometry.attributes;
	
				if ( index !== null ) {
	
					updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
				}
	
				for ( var name in attributes ) {
	
					updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
				}
	
				// morph targets
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var name in morphAttributes ) {
	
					var array = morphAttributes[ name ];
	
					for ( var i = 0, l = array.length; i < l; i ++ ) {
	
						updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
					}
	
				}
	
				return geometry;
	
			}
	
			function updateAttribute( attribute, bufferType ) {
	
				var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;
	
				var attributeProperties = properties.get( data );
	
				if ( attributeProperties.__webglBuffer === undefined ) {
	
					createBuffer( attributeProperties, data, bufferType );
	
				} else if ( attributeProperties.version !== data.version ) {
	
					updateBuffer( attributeProperties, data, bufferType );
	
				}
	
			}
	
			function createBuffer( attributeProperties, data, bufferType ) {
	
				attributeProperties.__webglBuffer = gl.createBuffer();
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
				var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
				gl.bufferData( bufferType, data.array, usage );
	
				attributeProperties.version = data.version;
	
			}
	
			function updateBuffer( attributeProperties, data, bufferType ) {
	
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
				if ( data.dynamic === false ) {
	
					gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );
	
				} else if ( data.updateRange.count === - 1 ) {
	
					// Not using update ranges
	
					gl.bufferSubData( bufferType, 0, data.array );
	
				} else if ( data.updateRange.count === 0 ) {
	
					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
				} else {
	
					gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
									  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
					data.updateRange.count = 0; // reset range
	
				}
	
				attributeProperties.version = data.version;
	
			}
	
			function getAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data ).__webglBuffer;
	
				}
	
				return properties.get( attribute ).__webglBuffer;
	
			}
	
			function getWireframeAttribute( geometry ) {
	
				var property = properties.get( geometry );
	
				if ( property.wireframe !== undefined ) {
	
					return property.wireframe;
	
				}
	
				var indices = [];
	
				var index = geometry.index;
				var attributes = geometry.attributes;
				var position = attributes.position;
	
				// console.time( 'wireframe' );
	
				if ( index !== null ) {
	
					var edges = {};
					var array = index.array;
	
					for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				} else {
	
					var array = attributes.position.array;
	
					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
						var a = i + 0;
						var b = i + 1;
						var c = i + 2;
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				}
	
				// console.timeEnd( 'wireframe' );
	
				var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
				var attribute = new BufferAttribute( new TypeArray( indices ), 1 );
	
				updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
				property.wireframe = attribute;
	
				return attribute;
	
			}
	
			return {
	
				getAttributeBuffer: getAttributeBuffer,
				getWireframeAttribute: getWireframeAttribute,
	
				update: update
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {
	
			var _infoMemory = info.memory;
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );
	
			//
	
			function clampToMaxSize( image, maxSize ) {
	
				if ( image.width > maxSize || image.height > maxSize ) {
	
					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.
	
					var scale = maxSize / Math.max( image.width, image.height );
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function isPowerOfTwo( image ) {
	
				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );
	
			}
	
			function makePowerOfTwo( image ) {
	
				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function textureNeedsPowerOfTwo( texture ) {
	
				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;
	
				return false;
	
			}
	
			// Fallback filters for non-power-of-2 textures
	
			function filterFallback( f ) {
	
				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
	
					return _gl.NEAREST;
	
				}
	
				return _gl.LINEAR;
	
			}
	
			//
	
			function onTextureDispose( event ) {
	
				var texture = event.target;
	
				texture.removeEventListener( 'dispose', onTextureDispose );
	
				deallocateTexture( texture );
	
				_infoMemory.textures --;
	
	
			}
	
			function onRenderTargetDispose( event ) {
	
				var renderTarget = event.target;
	
				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
				deallocateRenderTarget( renderTarget );
	
				_infoMemory.textures --;
	
			}
	
			//
	
			function deallocateTexture( texture ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
					// cube texture
	
					_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
				} else {
	
					// 2D texture
	
					if ( textureProperties.__webglInit === undefined ) return;
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				// remove all webgl properties
				properties.delete( texture );
	
			}
	
			function deallocateRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				if ( ! renderTarget ) return;
	
				if ( textureProperties.__webglTexture !== undefined ) {
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				if ( renderTarget.depthTexture ) {
	
					renderTarget.depthTexture.dispose();
	
				}
	
				if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {
	
					for ( var i = 0; i < 6; i ++ ) {
	
						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
					}
	
				} else {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
				}
	
				properties.delete( renderTarget.texture );
				properties.delete( renderTarget );
	
			}
	
			//
	
	
	
			function setTexture2D( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					var image = texture.image;
	
					if ( image === undefined ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
	
					} else if ( image.complete === false ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
	
					} else {
	
						uploadTexture( textureProperties, texture, slot );
						return;
	
					}
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			}
	
			function setTextureCube( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image.length === 6 ) {
	
					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
						if ( ! textureProperties.__image__webglTextureCube ) {
	
							texture.addEventListener( 'dispose', onTextureDispose );
	
							textureProperties.__image__webglTextureCube = _gl.createTexture();
	
							_infoMemory.textures ++;
	
						}
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
						var isCompressed = (texture && texture.isCompressedTexture);
						var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);
	
						var cubeImage = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed && ! isDataTexture ) {
	
								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
							} else {
	
								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
							}
	
						}
	
						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );
	
						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed ) {
	
								if ( isDataTexture ) {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
								}
	
							} else {
	
								var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
									mipmap = mipmaps[ j ];
	
									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
										} else {
	
											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );
	
										}
	
									} else {
	
										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
									}
	
								}
	
							}
	
						}
	
						if ( texture.generateMipmaps && isPowerOfTwoImage ) {
	
							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
						}
	
						textureProperties.__version = texture.version;
	
						if ( texture.onUpdate ) texture.onUpdate( texture );
	
					} else {
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					}
	
				}
	
			}
	
			function setTextureCubeDynamic( texture, slot ) {
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
			}
	
			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {
	
				var extension;
	
				if ( isPowerOfTwoImage ) {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
				} else {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
					}
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
					}
	
				}
	
				extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension ) {
	
					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
					}
	
				}
	
			}
	
			function uploadTexture( textureProperties, texture, slot ) {
	
				if ( textureProperties.__webglInit === undefined ) {
	
					textureProperties.__webglInit = true;
	
					texture.addEventListener( 'dispose', onTextureDispose );
	
					textureProperties.__webglTexture = _gl.createTexture();
	
					_infoMemory.textures ++;
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
					image = makePowerOfTwo( image );
	
				}
	
				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );
	
				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
				var mipmap, mipmaps = texture.mipmaps;
	
				if ( (texture && texture.isDepthTexture) ) {
	
					// populate depth texture with dummy data
	
					var internalFormat = _gl.DEPTH_COMPONENT;
	
					if ( texture.type === FloatType ) {
	
						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;
	
					} else if ( _isWebGL2 ) {
	
						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;
	
					}
	
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {
	
						internalFormat = _gl.DEPTH_STENCIL;
	
					}
	
					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );
	
				} else if ( (texture && texture.isDataTexture) ) {
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
					}
	
				} else if ( (texture && texture.isCompressedTexture) ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
	
						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
							} else {
	
								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
							}
	
						} else {
	
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
					}
	
				} else {
	
					// regular Texture (image, video, canvas)
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
					}
	
				}
	
				if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				textureProperties.__version = texture.version;
	
				if ( texture.onUpdate ) texture.onUpdate( texture );
	
			}
	
			// Render targets
	
			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
	
				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else {
	
					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
			}
	
			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {
	
				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
				if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {
	
					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
	
				}
	
				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}
	
				setTexture2D( renderTarget.depthTexture, 0 );
	
				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
	
				if ( renderTarget.depthTexture.format === DepthFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else {
	
					throw new Error('Unknown depthTexture format')
	
				}
	
			}
	
			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
	
				if ( renderTarget.depthTexture ) {
	
					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');
	
					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
	
				} else {
	
					if ( isCube ) {
	
						renderTargetProperties.__webglDepthbuffer = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
						}
	
					} else {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
					}
	
				}
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
	
				// Setup framebuffer
	
				if ( isCube ) {
	
					renderTargetProperties.__webglFramebuffer = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
					}
	
				} else {
	
					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
				}
	
				// Setup color buffer
	
				if ( isCube ) {
	
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
					}
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				// Setup depth and stencil buffers
	
				if ( renderTarget.depthBuffer ) {
	
					setupDepthRenderbuffer( renderTarget );
	
				}
	
			}
	
			function updateRenderTargetMipmap( renderTarget ) {
	
				var texture = renderTarget.texture;
	
				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== NearestFilter &&
						texture.minFilter !== LinearFilter ) {
	
					var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;
	
					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );
	
				}
	
			}
	
			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	
		}
	
		/**
		 * @author fordacious / fordacious.github.io
		 */
	
		function WebGLProperties() {
	
			var properties = {};
	
			return {
	
				get: function ( object ) {
	
					var uuid = object.uuid;
					var map = properties[ uuid ];
	
					if ( map === undefined ) {
	
						map = {};
						properties[ uuid ] = map;
	
					}
	
					return map;
	
				},
	
				delete: function ( object ) {
	
					delete properties[ object.uuid ];
	
				},
	
				clear: function () {
	
					properties = {};
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLState( gl, extensions, paramThreeToGL ) {
	
			function ColorBuffer() {
	
				var locked = false;
	
				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();
	
				return {
	
					setMask: function ( colorMask ) {
	
						if ( currentColorMask !== colorMask && ! locked ) {
	
							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( r, g, b, a ) {
	
						color.set( r, g, b, a );
	
						if ( currentColorClear.equals( color ) === false ) {
	
							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );
	
					}
	
				};
	
			}
	
			function DepthBuffer() {
	
				var locked = false;
	
				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;
	
				return {
	
					setTest: function ( depthTest ) {
	
						if ( depthTest ) {
	
							enable( gl.DEPTH_TEST );
	
						} else {
	
							disable( gl.DEPTH_TEST );
	
						}
	
					},
	
					setMask: function ( depthMask ) {
	
						if ( currentDepthMask !== depthMask && ! locked ) {
	
							gl.depthMask( depthMask );
							currentDepthMask = depthMask;
	
						}
	
					},
	
					setFunc: function ( depthFunc ) {
	
						if ( currentDepthFunc !== depthFunc ) {
	
							if ( depthFunc ) {
	
								switch ( depthFunc ) {
	
									case NeverDepth:
	
										gl.depthFunc( gl.NEVER );
										break;
	
									case AlwaysDepth:
	
										gl.depthFunc( gl.ALWAYS );
										break;
	
									case LessDepth:
	
										gl.depthFunc( gl.LESS );
										break;
	
									case LessEqualDepth:
	
										gl.depthFunc( gl.LEQUAL );
										break;
	
									case EqualDepth:
	
										gl.depthFunc( gl.EQUAL );
										break;
	
									case GreaterEqualDepth:
	
										gl.depthFunc( gl.GEQUAL );
										break;
	
									case GreaterDepth:
	
										gl.depthFunc( gl.GREATER );
										break;
	
									case NotEqualDepth:
	
										gl.depthFunc( gl.NOTEQUAL );
										break;
	
									default:
	
										gl.depthFunc( gl.LEQUAL );
	
								}
	
							} else {
	
								gl.depthFunc( gl.LEQUAL );
	
							}
	
							currentDepthFunc = depthFunc;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( depth ) {
	
						if ( currentDepthClear !== depth ) {
	
							gl.clearDepth( depth );
							currentDepthClear = depth;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;
	
					}
	
				};
	
			}
	
			function StencilBuffer() {
	
				var locked = false;
	
				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail  = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;
	
				return {
	
					setTest: function ( stencilTest ) {
	
						if ( stencilTest ) {
	
							enable( gl.STENCIL_TEST );
	
						} else {
	
							disable( gl.STENCIL_TEST );
	
						}
	
					},
	
					setMask: function ( stencilMask ) {
	
						if ( currentStencilMask !== stencilMask && ! locked ) {
	
							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;
	
						}
	
					},
	
					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
	
						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {
	
							gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );
	
							currentStencilFunc = stencilFunc;
							currentStencilRef  = stencilRef;
							currentStencilFuncMask = stencilMask;
	
						}
	
					},
	
					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
	
						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {
	
							gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );
	
							currentStencilFail  = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( stencil ) {
	
						if ( currentStencilClear !== stencil ) {
	
							gl.clearStencil( stencil );
							currentStencilClear = stencil;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;
	
					}
	
				};
	
			}
	
			//
	
			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();
	
			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );
	
			var capabilities = {};
	
			var compressedTextureFormats = null;
	
			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;
	
			var currentFlipSided = null;
			var currentCullFace = null;
	
			var currentLineWidth = null;
	
			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;
	
			var currentScissorTest = null;
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
			var currentTextureSlot = null;
			var currentBoundTextures = {};
	
			var currentScissor = new Vector4();
			var currentViewport = new Vector4();
	
			function createTexture( type, target, count ) {
	
				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();
	
				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
	
				for ( var i = 0; i < count; i ++ ) {
	
					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
	
				}
	
				return texture;
	
			}
	
			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	
			//
	
			function init() {
	
				clearColor( 0, 0, 0, 1 );
				clearDepth( 1 );
				clearStencil( 0 );
	
				enable( gl.DEPTH_TEST );
				setDepthFunc( LessEqualDepth );
	
				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );
	
				enable( gl.BLEND );
				setBlending( NormalBlending );
	
			}
	
			function initAttributes() {
	
				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
					newAttributes[ i ] = 0;
	
				}
	
			}
	
			function enableAttribute( attribute ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== 0 ) {
	
					var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;
	
				}
	
			}
	
			function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;
	
				}
	
			}
	
			function disableUnusedAttributes() {
	
				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
	
					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
			}
	
			function enable( id ) {
	
				if ( capabilities[ id ] !== true ) {
	
					gl.enable( id );
					capabilities[ id ] = true;
	
				}
	
			}
	
			function disable( id ) {
	
				if ( capabilities[ id ] !== false ) {
	
					gl.disable( id );
					capabilities[ id ] = false;
	
				}
	
			}
	
			function getCompressedTextureFormats() {
	
				if ( compressedTextureFormats === null ) {
	
					compressedTextureFormats = [];
	
					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {
	
						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
						for ( var i = 0; i < formats.length; i ++ ) {
	
							compressedTextureFormats.push( formats[ i ] );
	
						}
	
					}
	
				}
	
				return compressedTextureFormats;
	
			}
	
			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
	
				if ( blending !== NoBlending ) {
	
					enable( gl.BLEND );
	
				} else {
	
					disable( gl.BLEND );
	
				}
	
				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
	
					if ( blending === AdditiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
						}
	
					} else if ( blending === SubtractiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
						}
	
					} else if ( blending === MultiplyBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
						}
	
					} else {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						}
	
					}
	
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
	
				}
	
				if ( blending === CustomBlending ) {
	
					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;
	
					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;
	
					}
	
					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;
	
					}
	
				} else {
	
					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
	
				}
	
			}
	
			// TODO Deprecate
	
			function setColorWrite( colorWrite ) {
	
				colorBuffer.setMask( colorWrite );
	
			}
	
			function setDepthTest( depthTest ) {
	
				depthBuffer.setTest( depthTest );
	
			}
	
			function setDepthWrite( depthWrite ) {
	
				depthBuffer.setMask( depthWrite );
	
			}
	
			function setDepthFunc( depthFunc ) {
	
				depthBuffer.setFunc( depthFunc );
	
			}
	
			function setStencilTest( stencilTest ) {
	
				stencilBuffer.setTest( stencilTest );
	
			}
	
			function setStencilWrite( stencilWrite ) {
	
				stencilBuffer.setMask( stencilWrite );
	
			}
	
			function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {
	
				stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );
	
			}
	
			function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {
	
				stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );
	
			}
	
			//
	
			function setFlipSided( flipSided ) {
	
				if ( currentFlipSided !== flipSided ) {
	
					if ( flipSided ) {
	
						gl.frontFace( gl.CW );
	
					} else {
	
						gl.frontFace( gl.CCW );
	
					}
	
					currentFlipSided = flipSided;
	
				}
	
			}
	
			function setCullFace( cullFace ) {
	
				if ( cullFace !== CullFaceNone ) {
	
					enable( gl.CULL_FACE );
	
					if ( cullFace !== currentCullFace ) {
	
						if ( cullFace === CullFaceBack ) {
	
							gl.cullFace( gl.BACK );
	
						} else if ( cullFace === CullFaceFront ) {
	
							gl.cullFace( gl.FRONT );
	
						} else {
	
							gl.cullFace( gl.FRONT_AND_BACK );
	
						}
	
					}
	
				} else {
	
					disable( gl.CULL_FACE );
	
				}
	
				currentCullFace = cullFace;
	
			}
	
			function setLineWidth( width ) {
	
				if ( width !== currentLineWidth ) {
	
					gl.lineWidth( width );
	
					currentLineWidth = width;
	
				}
	
			}
	
			function setPolygonOffset( polygonOffset, factor, units ) {
	
				if ( polygonOffset ) {
	
					enable( gl.POLYGON_OFFSET_FILL );
	
					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
	
						gl.polygonOffset( factor, units );
	
						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;
	
					}
	
				} else {
	
					disable( gl.POLYGON_OFFSET_FILL );
	
				}
	
			}
	
			function getScissorTest() {
	
				return currentScissorTest;
	
			}
	
			function setScissorTest( scissorTest ) {
	
				currentScissorTest = scissorTest;
	
				if ( scissorTest ) {
	
					enable( gl.SCISSOR_TEST );
	
				} else {
	
					disable( gl.SCISSOR_TEST );
	
				}
	
			}
	
			// texture
	
			function activeTexture( webglSlot ) {
	
				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
				if ( currentTextureSlot !== webglSlot ) {
	
					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;
	
				}
	
			}
	
			function bindTexture( webglType, webglTexture ) {
	
				if ( currentTextureSlot === null ) {
	
					activeTexture();
	
				}
	
				var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
				if ( boundTexture === undefined ) {
	
					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
				}
	
				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
	
					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;
	
				}
	
			}
	
			function compressedTexImage2D() {
	
				try {
	
					gl.compressedTexImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( error );
	
				}
	
			}
	
			function texImage2D() {
	
				try {
	
					gl.texImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( error );
	
				}
	
			}
	
			// TODO Deprecate
	
			function clearColor( r, g, b, a ) {
	
				colorBuffer.setClear( r, g, b, a );
	
			}
	
			function clearDepth( depth ) {
	
				depthBuffer.setClear( depth );
	
			}
	
			function clearStencil( stencil ) {
	
				stencilBuffer.setClear( stencil );
	
			}
	
			//
	
			function scissor( scissor ) {
	
				if ( currentScissor.equals( scissor ) === false ) {
	
					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );
	
				}
	
			}
	
			function viewport( viewport ) {
	
				if ( currentViewport.equals( viewport ) === false ) {
	
					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );
	
				}
	
			}
	
			//
	
			function reset() {
	
				for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
					if ( enabledAttributes[ i ] === 1 ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
				capabilities = {};
	
				compressedTextureFormats = null;
	
				currentTextureSlot = null;
				currentBoundTextures = {};
	
				currentBlending = null;
	
				currentFlipSided = null;
				currentCullFace = null;
	
				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();
	
			}
	
			return {
	
				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},
	
				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,
	
				setBlending: setBlending,
	
				setColorWrite: setColorWrite,
				setDepthTest: setDepthTest,
				setDepthWrite: setDepthWrite,
				setDepthFunc: setDepthFunc,
				setStencilTest: setStencilTest,
				setStencilWrite: setStencilWrite,
				setStencilFunc: setStencilFunc,
				setStencilOp: setStencilOp,
	
				setFlipSided: setFlipSided,
				setCullFace: setCullFace,
	
				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,
	
				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,
	
				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,
	
				clearColor: clearColor,
				clearDepth: clearDepth,
				clearStencil: clearStencil,
	
				scissor: scissor,
				viewport: viewport,
	
				reset: reset
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLCapabilities( gl, extensions, parameters ) {
	
			var maxAnisotropy;
	
			function getMaxAnisotropy() {
	
				if ( maxAnisotropy !== undefined ) return maxAnisotropy;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					maxAnisotropy = 0;
	
				}
	
				return maxAnisotropy;
	
			}
	
			function getMaxPrecision( precision ) {
	
				if ( precision === 'highp' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
						return 'highp';
	
					}
	
					precision = 'mediump';
	
				}
	
				if ( precision === 'mediump' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
						return 'mediump';
	
					}
	
				}
	
				return 'lowp';
	
			}
	
			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );
	
			if ( maxPrecision !== precision ) {
	
				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;
	
			}
	
			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;
	
			return {
	
				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,
	
				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
	
				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,
	
				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,
	
				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLExtensions( gl ) {
	
			var extensions = {};
	
			return {
	
				get: function ( name ) {
	
					if ( extensions[ name ] !== undefined ) {
	
						return extensions[ name ];
	
					}
	
					var extension;
	
					switch ( name ) {
	
						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;
	
						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;
	
						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;
	
						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;
	
						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;
	
						default:
							extension = gl.getExtension( name );
	
					}
	
					if ( extension === null ) {
	
						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
					}
	
					extensions[ name ] = extension;
	
					return extension;
	
				}
	
			};
	
		}
	
		/**
		 * @author tschw
		 */
	
		function WebGLClipping() {
	
			var scope = this,
	
				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,
	
				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),
	
				uniform = { value: null, needsUpdate: false };
	
			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;
	
			this.init = function( planes, enableLocalClipping, camera ) {
	
				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;
	
				localClippingEnabled = enableLocalClipping;
	
				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;
	
				return enabled;
	
			};
	
			this.beginShadows = function() {
	
				renderingShadows = true;
				projectPlanes( null );
	
			};
	
			this.endShadows = function() {
	
				renderingShadows = false;
				resetGlobalState();
	
			};
	
			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
	
				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping
	
					if ( renderingShadows ) {
						// there's no global clipping
	
						projectPlanes( null );
	
					} else {
	
						resetGlobalState();
					}
	
				} else {
	
					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,
	
						dstArray = cache.clippingState || null;
	
					uniform.value = dstArray; // ensure unique state
	
					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
	
					for ( var i = 0; i !== lGlobal; ++ i ) {
	
						dstArray[ i ] = globalState[ i ];
	
					}
	
					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;
	
				}
	
	
			};
	
			function resetGlobalState() {
	
				if ( uniform.value !== globalState ) {
	
					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;
	
				}
	
				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;
	
			}
	
			function projectPlanes( planes, camera, dstOffset, skipTransform ) {
	
				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;
	
				if ( nPlanes !== 0 ) {
	
					dstArray = uniform.value;
	
					if ( skipTransform !== true || dstArray === null ) {
	
						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;
	
						viewNormalMatrix.getNormalMatrix( viewMatrix );
	
						if ( dstArray === null || dstArray.length < flatSize ) {
	
							dstArray = new Float32Array( flatSize );
	
						}
	
						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {
	
							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );
	
							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;
	
						}
	
					}
	
					uniform.value = dstArray;
					uniform.needsUpdate = true;
	
				}
	
				scope.numPlanes = nPlanes;
				
				return dstArray;
	
			}
	
		}
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */
	
		function WebGLRenderer( parameters ) {
	
			console.log( 'THREE.WebGLRenderer', REVISION );
	
			parameters = parameters || {};
	
			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,
	
			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
			var lights = [];
	
			var opaqueObjects = [];
			var opaqueObjectsLastIndex = - 1;
			var transparentObjects = [];
			var transparentObjectsLastIndex = - 1;
	
			var morphInfluences = new Float32Array( 8 );
	
			var sprites = [];
			var lensFlares = [];
	
			// public properties
	
			this.domElement = _canvas;
			this.context = null;
	
			// clearing
	
			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;
	
			// scene graph
	
			this.sortObjects = true;
	
			// user-defined clipping
	
			this.clippingPlanes = [];
			this.localClippingEnabled = false;
	
			// physically based shading
	
			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;
	
			// physical lights
	
			this.physicallyCorrectLights = false;
	
			// tone mapping
	
			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;
	
			// morphs
	
			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;
	
			// internal properties
	
			var _this = this,
	
			// internal state cache
	
			_currentProgram = null,
			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',
			_currentCamera = null,
	
			_currentScissor = new Vector4(),
			_currentScissorTest = null,
	
			_currentViewport = new Vector4(),
	
			//
	
			_usedTextureUnits = 0,
	
			//
	
			_clearColor = new Color( 0x000000 ),
			_clearAlpha = 0,
	
			_width = _canvas.width,
			_height = _canvas.height,
	
			_pixelRatio = 1,
	
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,
	
			_viewport = new Vector4( 0, 0, _width, _height ),
	
			// frustum
	
			_frustum = new Frustum(),
	
			// clipping
	
			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,
	
			_sphere = new Sphere(),
	
			// camera matrices cache
	
			_projScreenMatrix = new Matrix4(),
	
			_vector3 = new Vector3(),
	
			// light arrays cache
	
			_lights = {
	
				hash: '',
	
				ambient: [ 0, 0, 0 ],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
	
				shadows: []
	
			},
	
			// info
	
			_infoRender = {
	
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0
	
			};
	
			this.info = {
	
				render: _infoRender,
				memory: {
	
					geometries: 0,
					textures: 0
	
				},
				programs: null
	
			};
	
	
			// initialize
	
			var _gl;
	
			try {
	
				var attributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};
	
				_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
				if ( _gl === null ) {
	
					if ( _canvas.getContext( 'webgl' ) !== null ) {
	
						throw 'Error creating WebGL context with your selected attributes.';
	
					} else {
	
						throw 'Error creating WebGL context.';
	
					}
	
				}
	
				// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	
				if ( _gl.getShaderPrecisionFormat === undefined ) {
	
					_gl.getShaderPrecisionFormat = function () {
	
						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	
					};
	
				}
	
				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLRenderer: ' + error );
	
			}
	
			var extensions = new WebGLExtensions( _gl );
	
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extensions.get( 'OES_element_index_uint' ) ) {
	
				BufferGeometry.MaxIndex = 4294967296;
	
			}
	
			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );
	
			var state = new WebGLState( _gl, extensions, paramThreeToGL );
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
			var objects = new WebGLObjects( _gl, properties, this.info );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();
	
			this.info.programs = programCache.programs;
	
			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
			//
	
			var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
			var backgroundCamera2 = new PerspectiveCamera();
			var backgroundPlaneMesh = new Mesh(
				new PlaneBufferGeometry( 2, 2 ),
				new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
			);
			var backgroundBoxShader = ShaderLib[ 'cube' ];
			var backgroundBoxMesh = new Mesh(
				new BoxBufferGeometry( 5, 5, 5 ),
				new ShaderMaterial( {
					uniforms: backgroundBoxShader.uniforms,
					vertexShader: backgroundBoxShader.vertexShader,
					fragmentShader: backgroundBoxShader.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				} )
			);
	
			//
	
			function getTargetPixelRatio() {
	
				return _currentRenderTarget === null ? _pixelRatio : 1;
	
			}
	
			function glClearColor( r, g, b, a ) {
	
				if ( _premultipliedAlpha === true ) {
	
					r *= a; g *= a; b *= a;
	
				}
	
				state.clearColor( r, g, b, a );
	
			}
	
			function setDefaultGLState() {
	
				state.init();
	
				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
			}
	
			function resetGLState() {
	
				_currentProgram = null;
				_currentCamera = null;
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
	
				state.reset();
	
			}
	
			setDefaultGLState();
	
			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.state = state;
	
			// shadow map
	
			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );
	
			this.shadowMap = shadowMap;
	
	
			// Plugins
	
			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );
	
			// API
	
			this.getContext = function () {
	
				return _gl;
	
			};
	
			this.getContextAttributes = function () {
	
				return _gl.getContextAttributes();
	
			};
	
			this.forceContextLoss = function () {
	
				extensions.get( 'WEBGL_lose_context' ).loseContext();
	
			};
	
			this.getMaxAnisotropy = function () {
	
				return capabilities.getMaxAnisotropy();
	
			};
	
			this.getPrecision = function () {
	
				return capabilities.precision;
	
			};
	
			this.getPixelRatio = function () {
	
				return _pixelRatio;
	
			};
	
			this.setPixelRatio = function ( value ) {
	
				if ( value === undefined ) return;
	
				_pixelRatio = value;
	
				this.setSize( _viewport.z, _viewport.w, false );
	
			};
	
			this.getSize = function () {
	
				return {
					width: _width,
					height: _height
				};
	
			};
	
			this.setSize = function ( width, height, updateStyle ) {
	
				_width = width;
				_height = height;
	
				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;
	
				if ( updateStyle !== false ) {
	
					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';
	
				}
	
				this.setViewport( 0, 0, width, height );
	
			};
	
			this.setViewport = function ( x, y, width, height ) {
	
				state.viewport( _viewport.set( x, y, width, height ) );
	
			};
	
			this.setScissor = function ( x, y, width, height ) {
	
				state.scissor( _scissor.set( x, y, width, height ) );
	
			};
	
			this.setScissorTest = function ( boolean ) {
	
				state.setScissorTest( _scissorTest = boolean );
	
			};
	
			// Clearing
	
			this.getClearColor = function () {
	
				return _clearColor;
	
			};
	
			this.setClearColor = function ( color, alpha ) {
	
				_clearColor.set( color );
	
				_clearAlpha = alpha !== undefined ? alpha : 1;
	
				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
			};
	
			this.getClearAlpha = function () {
	
				return _clearAlpha;
	
			};
	
			this.setClearAlpha = function ( alpha ) {
	
				_clearAlpha = alpha;
	
				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
			};
	
			this.clear = function ( color, depth, stencil ) {
	
				var bits = 0;
	
				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
				_gl.clear( bits );
	
			};
	
			this.clearColor = function () {
	
				this.clear( true, false, false );
	
			};
	
			this.clearDepth = function () {
	
				this.clear( false, true, false );
	
			};
	
			this.clearStencil = function () {
	
				this.clear( false, false, true );
	
			};
	
			this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );
	
			};
	
			// Reset
	
			this.resetGLState = resetGLState;
	
			this.dispose = function() {
	
				transparentObjects = [];
				transparentObjectsLastIndex = -1;
				opaqueObjects = [];
				opaqueObjectsLastIndex = -1;
	
				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
			};
	
			// Events
	
			function onContextLost( event ) {
	
				event.preventDefault();
	
				resetGLState();
				setDefaultGLState();
	
				properties.clear();
	
			}
	
			function onMaterialDispose( event ) {
	
				var material = event.target;
	
				material.removeEventListener( 'dispose', onMaterialDispose );
	
				deallocateMaterial( material );
	
			}
	
			// Buffer deallocation
	
			function deallocateMaterial( material ) {
	
				releaseMaterialProgramReference( material );
	
				properties.delete( material );
	
			}
	
	
			function releaseMaterialProgramReference( material ) {
	
				var programInfo = properties.get( material ).program;
	
				material.program = undefined;
	
				if ( programInfo !== undefined ) {
	
					programCache.releaseProgram( programInfo );
	
				}
	
			}
	
			// Buffer rendering
	
			this.renderBufferImmediate = function ( object, program, material ) {
	
				state.initAttributes();
	
				var buffers = properties.get( object );
	
				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
				var attributes = program.getAttributes();
	
				if ( object.hasPositions ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasNormals ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
					if ( ! material.isMeshPhongMaterial &&
					     ! material.isMeshStandardMaterial &&
					       material.shading === FlatShading ) {
	
						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
							var array = object.normalArray;
	
							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;
	
							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;
	
							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;
	
						}
	
					}
	
					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.normal );
	
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasUvs && material.map ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.uv );
	
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasColors && material.vertexColors !== NoColors ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.color );
	
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				state.disableUnusedAttributes();
	
				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
				object.count = 0;
	
			};
	
			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
				setMaterial( material );
	
				var program = setProgram( camera, fog, material, object );
	
				var updateBuffers = false;
				var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
				if ( geometryProgram !== _currentGeometryProgram ) {
	
					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;
	
				}
	
				// morph targets
	
				var morphTargetInfluences = object.morphTargetInfluences;
	
				if ( morphTargetInfluences !== undefined ) {
	
					var activeInfluences = [];
	
					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );
	
					}
	
					activeInfluences.sort( absNumericalSort );
	
					if ( activeInfluences.length > 8 ) {
	
						activeInfluences.length = 8;
	
					}
	
					var morphAttributes = geometry.morphAttributes;
	
					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];
	
						if ( influence[ 0 ] !== 0 ) {
	
							var index = influence[ 1 ];
	
							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
						} else {
	
							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
						}
	
					}
	
					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {
	
						morphInfluences[ i ] = 0.0;
	
					}
	
					program.getUniforms().setValue(
							_gl, 'morphTargetInfluences', morphInfluences );
	
					updateBuffers = true;
	
				}
	
				//
	
				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;
	
				if ( material.wireframe === true ) {
	
					index = objects.getWireframeAttribute( geometry );
					rangeFactor = 2;
	
				}
	
				var renderer;
	
				if ( index !== null ) {
	
					renderer = indexedBufferRenderer;
					renderer.setIndex( index );
	
				} else {
	
					renderer = bufferRenderer;
	
				}
	
				if ( updateBuffers ) {
	
					setupVertexAttributes( material, program, geometry );
	
					if ( index !== null ) {
	
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
					}
	
				}
	
				//
	
				var dataCount = 0;
	
				if ( index !== null ) {
	
					dataCount = index.count;
	
				} else if ( position !== undefined ) {
	
					dataCount = position.count;
	
				}
	
				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;
	
				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	
				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
				if ( drawCount === 0 ) return;
	
				//
	
				if ( object.isMesh ) {
	
					if ( material.wireframe === true ) {
	
						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );
	
					} else {
	
						switch ( object.drawMode ) {
	
							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;
	
							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;
	
							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;
	
						}
	
					}
	
	
				} else if ( object.isLine ) {
	
					var lineWidth = material.linewidth;
	
					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
					state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
					if ( object.isLineSegments ) {
	
						renderer.setMode( _gl.LINES );
	
					} else {
	
						renderer.setMode( _gl.LINE_STRIP );
	
					}
	
				} else if ( object.isPoints ) {
	
					renderer.setMode( _gl.POINTS );
	
				}
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					if ( geometry.maxInstancedCount > 0 ) {
	
						renderer.renderInstances( geometry, drawStart, drawCount );
	
					}
	
				} else {
	
					renderer.render( drawStart, drawCount );
	
				}
	
			};
	
			function setupVertexAttributes( material, program, geometry, startIndex ) {
	
				var extension;
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					if ( extension === null ) {
	
						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;
	
					}
	
				}
	
				if ( startIndex === undefined ) startIndex = 0;
	
				state.initAttributes();
	
				var geometryAttributes = geometry.attributes;
	
				var programAttributes = program.getAttributes();
	
				var materialDefaultAttributeValues = material.defaultAttributeValues;
	
				for ( var name in programAttributes ) {
	
					var programAttribute = programAttributes[ name ];
	
					if ( programAttribute >= 0 ) {
	
						var geometryAttribute = geometryAttributes[ name ];
	
						if ( geometryAttribute !== undefined ) {
	
							var type = _gl.FLOAT;
							var array = geometryAttribute.array;
							var normalized = geometryAttribute.normalized;
	
							if ( array instanceof Float32Array ) {
	
								type = _gl.FLOAT;
	
							} else if ( array instanceof Float64Array ) {
	
								console.warn( "Unsupported data buffer format: Float64Array" );
	
							} else if ( array instanceof Uint16Array ) {
	
								type = _gl.UNSIGNED_SHORT;
	
							} else if ( array instanceof Int16Array ) {
	
								type = _gl.SHORT;
	
							} else if ( array instanceof Uint32Array ) {
	
								type = _gl.UNSIGNED_INT;
	
							} else if ( array instanceof Int32Array ) {
	
								type = _gl.INT;
	
							} else if ( array instanceof Int8Array ) {
	
								type = _gl.BYTE;
	
							} else if ( array instanceof Uint8Array ) {
	
								type = _gl.UNSIGNED_BYTE;
	
							}
	
							var size = geometryAttribute.itemSize;
							var buffer = objects.getAttributeBuffer( geometryAttribute );
	
							if ( geometryAttribute.isInterleavedBufferAttribute ) {
	
								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;
	
								if ( data && data.isInstancedInterleavedBuffer ) {
	
									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );
	
							} else {
	
								if ( geometryAttribute.isInstancedBufferAttribute ) {
	
									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );
	
							}
	
						} else if ( materialDefaultAttributeValues !== undefined ) {
	
							var value = materialDefaultAttributeValues[ name ];
	
							if ( value !== undefined ) {
	
								switch ( value.length ) {
	
									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;
	
									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;
	
									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;
	
									default:
										_gl.vertexAttrib1fv( programAttribute, value );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				state.disableUnusedAttributes();
	
			}
	
			// Sorting
	
			function absNumericalSort( a, b ) {
	
				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.object.renderOrder !== b.object.renderOrder ) {
	
					return a.object.renderOrder - b.object.renderOrder;
	
				} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {
	
					return a.material.program.id - b.material.program.id;
	
				} else if ( a.material.id !== b.material.id ) {
	
					return a.material.id - b.material.id;
	
				} else if ( a.z !== b.z ) {
	
					return a.z - b.z;
	
				} else {
	
					return a.id - b.id;
	
				}
	
			}
	
			function reversePainterSortStable( a, b ) {
	
				if ( a.object.renderOrder !== b.object.renderOrder ) {
	
					return a.object.renderOrder - b.object.renderOrder;
	
				} if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return a.id - b.id;
	
				}
	
			}
	
			// Rendering
	
			this.render = function ( scene, camera, renderTarget, forceClear ) {
	
				if ( camera !== undefined && camera.isCamera !== true ) {
	
					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;
	
				}
	
				// reset caching for this frame
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;
	
				// update scene graph
	
				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
				// update camera matrices and frustum
	
				if ( camera.parent === null ) camera.updateMatrixWorld();
	
				camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				lights.length = 0;
	
				opaqueObjectsLastIndex = - 1;
				transparentObjectsLastIndex = - 1;
	
				sprites.length = 0;
				lensFlares.length = 0;
	
				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
	
				projectObject( scene, camera );
	
				opaqueObjects.length = opaqueObjectsLastIndex + 1;
				transparentObjects.length = transparentObjectsLastIndex + 1;
	
				if ( _this.sortObjects === true ) {
	
					opaqueObjects.sort( painterSortStable );
					transparentObjects.sort( reversePainterSortStable );
	
				}
	
				//
	
				if ( _clippingEnabled ) _clipping.beginShadows();
	
				setupShadows( lights );
	
				shadowMap.render( scene, camera );
	
				setupLights( lights, camera );
	
				if ( _clippingEnabled ) _clipping.endShadows();
	
				//
	
				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;
	
				if ( renderTarget === undefined ) {
	
					renderTarget = null;
	
				}
	
				this.setRenderTarget( renderTarget );
	
				//
	
				var background = scene.background;
	
				if ( background === null ) {
	
					glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
				} else if ( background && background.isColor ) {
	
					glClearColor( background.r, background.g, background.b, 1 );
					forceClear = true;
	
				}
	
				if ( this.autoClear || forceClear ) {
	
					this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
				}
	
				if ( background && background.isCubeTexture ) {
	
					backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );
	
					backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
					backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );
	
					backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
					backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );
	
					objects.update( backgroundBoxMesh );
	
					_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );
	
				} else if ( background && background.isTexture ) {
	
					backgroundPlaneMesh.material.map = background;
	
					objects.update( backgroundPlaneMesh );
	
					_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );
	
				}
	
				//
	
				if ( scene.overrideMaterial ) {
	
					var overrideMaterial = scene.overrideMaterial;
	
					renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					renderObjects( transparentObjects, scene, camera, overrideMaterial );
	
				} else {
	
					// opaque pass (front-to-back order)
	
					state.setBlending( NoBlending );
					renderObjects( opaqueObjects, scene, camera );
	
					// transparent pass (back-to-front order)
	
					renderObjects( transparentObjects, scene, camera );
	
				}
	
				// custom render plugins (post pass)
	
				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );
	
				// Generate mipmap if we're using any kind of mipmap filtering
	
				if ( renderTarget ) {
	
					textures.updateRenderTargetMipmap( renderTarget );
	
				}
	
				// Ensure depth buffer writing is enabled so it can be cleared on next render
	
				state.setDepthTest( true );
				state.setDepthWrite( true );
				state.setColorWrite( true );
	
				// _gl.finish();
	
			};
	
			function pushRenderItem( object, geometry, material, z, group ) {
	
				var array, index;
	
				// allocate the next position in the appropriate array
	
				if ( material.transparent ) {
	
					array = transparentObjects;
					index = ++ transparentObjectsLastIndex;
	
				} else {
	
					array = opaqueObjects;
					index = ++ opaqueObjectsLastIndex;
	
				}
	
				// recycle existing render item or grow the array
	
				var renderItem = array[ index ];
	
				if ( renderItem !== undefined ) {
	
					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.z = _vector3.z;
					renderItem.group = group;
	
				} else {
	
					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						z: _vector3.z,
						group: group
					};
	
					// assert( index === array.length );
					array.push( renderItem );
	
				}
	
			}
	
			// TODO Duplicated code (Frustum)
	
			function isObjectViewable( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				_sphere.copy( geometry.boundingSphere ).
					applyMatrix4( object.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSpriteViewable( sprite ) {
	
				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSphereViewable( sphere ) {
	
				if ( ! _frustum.intersectsSphere( sphere ) ) return false;
	
				var numPlanes = _clipping.numPlanes;
	
				if ( numPlanes === 0 ) return true;
	
				var planes = _this.clippingPlanes,
	
					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;
	
				do {
	
					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
	
				} while ( ++ i !== numPlanes );
	
				return true;
	
			}
	
			function projectObject( object, camera ) {
	
				if ( object.visible === false ) return;
	
				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;
	
				if ( visible ) {
	
					if ( object.isLight ) {
	
						lights.push( object );
	
					} else if ( object.isSprite ) {
	
						if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {
	
							sprites.push( object );
	
						}
	
					} else if ( object.isLensFlare ) {
	
						lensFlares.push( object );
	
					} else if ( object.isImmediateRenderObject ) {
	
						if ( _this.sortObjects === true ) {
	
							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );
	
						}
	
						pushRenderItem( object, null, object.material, _vector3.z, null );
	
					} else if ( object.isMesh || object.isLine || object.isPoints ) {
	
						if ( object.isSkinnedMesh ) {
	
							object.skeleton.update();
	
						}
	
						if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {
	
							var material = object.material;
	
							if ( material.visible === true ) {
	
								if ( _this.sortObjects === true ) {
	
									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyProjection( _projScreenMatrix );
	
								}
	
								var geometry = objects.update( object );
	
								if ( material.isMultiMaterial ) {
	
									var groups = geometry.groups;
									var materials = material.materials;
	
									for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
										var group = groups[ i ];
										var groupMaterial = materials[ group.materialIndex ];
	
										if ( groupMaterial.visible === true ) {
	
											pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
										}
	
									}
	
								} else {
	
									pushRenderItem( object, geometry, material, _vector3.z, null );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera );
	
				}
	
			}
	
			function renderObjects( renderList, scene, camera, overrideMaterial ) {
	
				for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
					var renderItem = renderList[ i ];
	
					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;
	
					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
					object.onBeforeRender( _this, scene, camera, geometry, material, group );
	
					if ( object.isImmediateRenderObject ) {
	
						setMaterial( material );
	
						var program = setProgram( camera, scene.fog, material, object );
	
						_currentGeometryProgram = '';
	
						object.render( function ( object ) {
	
							_this.renderBufferImmediate( object, program, material );
	
						} );
	
					} else {
	
						_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
	
					}
	
					object.onAfterRender( _this, scene, camera, geometry, material, group );
	
	
				}
	
			}
	
			function initMaterial( material, fog, object ) {
	
				var materialProperties = properties.get( material );
	
				var parameters = programCache.getParameters(
						material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );
	
				var code = programCache.getProgramCode( material, parameters );
	
				var program = materialProperties.program;
				var programChange = true;
	
				if ( program === undefined ) {
	
					// new material
					material.addEventListener( 'dispose', onMaterialDispose );
	
				} else if ( program.code !== code ) {
	
					// changed glsl or parameters
					releaseMaterialProgramReference( material );
	
				} else if ( parameters.shaderID !== undefined ) {
	
					// same glsl and uniform list
					return;
	
				} else {
	
					// only rebuild uniform list
					programChange = false;
	
				}
	
				if ( programChange ) {
	
					if ( parameters.shaderID ) {
	
						var shader = ShaderLib[ parameters.shaderID ];
	
						materialProperties.__webglShader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};
	
					} else {
	
						materialProperties.__webglShader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};
	
					}
	
					material.__webglShader = materialProperties.__webglShader;
	
					program = programCache.acquireProgram( material, parameters, code );
	
					materialProperties.program = program;
					material.program = program;
	
				}
	
				var attributes = program.getAttributes();
	
				if ( material.morphTargets ) {
	
					material.numSupportedMorphTargets = 0;
	
					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
						if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
							material.numSupportedMorphTargets ++;
	
						}
	
					}
	
				}
	
				if ( material.morphNormals ) {
	
					material.numSupportedMorphNormals = 0;
	
					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
						if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
							material.numSupportedMorphNormals ++;
	
						}
	
					}
	
				}
	
				var uniforms = materialProperties.__webglShader.uniforms;
	
				if ( ! material.isShaderMaterial &&
				     ! material.isRawShaderMaterial ||
				       material.clipping === true ) {
	
					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;
	
				}
	
				materialProperties.fog = fog;
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				if ( material.lights ) {
	
					// wire up the material to this renderer's lighting state
	
					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;
	
					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
	
				}
	
				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
							WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
	
				materialProperties.uniformsList = uniformsList;
	
			}
	
			function setMaterial( material ) {
	
				material.side === DoubleSide
					? state.disable( _gl.CULL_FACE )
					: state.enable( _gl.CULL_FACE );
	
				state.setFlipSided( material.side === BackSide );
	
				material.transparent === true
					? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: state.setBlending( NoBlending );
	
				state.setDepthFunc( material.depthFunc );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
				state.setColorWrite( material.colorWrite );
				state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
			}
	
			function setProgram( camera, fog, material, object ) {
	
				_usedTextureUnits = 0;
	
				var materialProperties = properties.get( material );
	
				if ( _clippingEnabled ) {
	
					if ( _localClippingEnabled || camera !== _currentCamera ) {
	
						var useCache =
								camera === _currentCamera &&
								material.id === _currentMaterialId;
	
						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
								material.clippingPlanes, material.clipIntersection, material.clipShadows,
								camera, materialProperties, useCache );
	
					}
	
				}
	
				if ( material.needsUpdate === false ) {
	
					if ( materialProperties.program === undefined ) {
	
						material.needsUpdate = true;
	
					} else if ( material.fog && materialProperties.fog !== fog ) {
	
						material.needsUpdate = true;
	
					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {
	
						material.needsUpdate = true;
	
					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes || 
		 				  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {
	
						material.needsUpdate = true;
	
					}
	
				}
	
				if ( material.needsUpdate ) {
	
					initMaterial( material, fog, object );
					material.needsUpdate = false;
	
				}
	
				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;
	
				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.__webglShader.uniforms;
	
				if ( program.id !== _currentProgram ) {
	
					_gl.useProgram( program.program );
					_currentProgram = program.id;
	
					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;
	
				}
	
				if ( material.id !== _currentMaterialId ) {
	
					_currentMaterialId = material.id;
	
					refreshMaterial = true;
	
				}
	
				if ( refreshProgram || camera !== _currentCamera ) {
	
					p_uniforms.set( _gl, camera, 'projectionMatrix' );
	
					if ( capabilities.logarithmicDepthBuffer ) {
	
						p_uniforms.setValue( _gl, 'logDepthBufFC',
								2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
					}
	
	
					if ( camera !== _currentCamera ) {
	
						_currentCamera = camera;
	
						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:
	
						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done
	
					}
	
					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)
	
					if ( material.isShaderMaterial ||
					     material.isMeshPhongMaterial ||
					     material.isMeshStandardMaterial ||
					     material.envMap ) {
	
						var uCamPos = p_uniforms.map.cameraPosition;
	
						if ( uCamPos !== undefined ) {
	
							uCamPos.setValue( _gl,
									_vector3.setFromMatrixPosition( camera.matrixWorld ) );
	
						}
	
					}
	
					if ( material.isMeshPhongMaterial ||
					     material.isMeshLambertMaterial ||
					     material.isMeshBasicMaterial ||
					     material.isMeshStandardMaterial ||
					     material.isShaderMaterial ||
					     material.skinning ) {
	
						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
	
					}
	
					p_uniforms.set( _gl, _this, 'toneMappingExposure' );
					p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );
	
				}
	
				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen
	
				if ( material.skinning ) {
	
					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
	
					var skeleton = object.skeleton;
	
					if ( skeleton ) {
	
						if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {
	
							p_uniforms.set( _gl, skeleton, 'boneTexture' );
							p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
							p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );
	
						} else {
	
							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
	
						}
	
					}
	
				}
	
				if ( refreshMaterial ) {
	
					if ( material.lights ) {
	
						// the current material requires lighting info
	
						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required
	
						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
					}
	
					// refresh uniforms common to several materials
	
					if ( fog && material.fog ) {
	
						refreshUniformsFog( m_uniforms, fog );
	
					}
	
					if ( material.isMeshBasicMaterial ||
					     material.isMeshLambertMaterial ||
					     material.isMeshPhongMaterial ||
					     material.isMeshStandardMaterial ||
					     material.isMeshDepthMaterial ) {
	
						refreshUniformsCommon( m_uniforms, material );
	
					}
	
					// refresh single material specific uniforms
	
					if ( material.isLineBasicMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
	
					} else if ( material.isLineDashedMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );
	
					} else if ( material.isPointsMaterial ) {
	
						refreshUniformsPoints( m_uniforms, material );
	
					} else if ( material.isMeshLambertMaterial ) {
	
						refreshUniformsLambert( m_uniforms, material );
	
					} else if ( material.isMeshPhongMaterial ) {
	
						refreshUniformsPhong( m_uniforms, material );
	
					} else if ( material.isMeshPhysicalMaterial ) {
	
						refreshUniformsPhysical( m_uniforms, material );
	
					} else if ( material.isMeshStandardMaterial ) {
	
						refreshUniformsStandard( m_uniforms, material );
	
					} else if ( material.isMeshDepthMaterial ) {
	
						if ( material.displacementMap ) {
	
							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;
	
						}
	
					} else if ( material.isMeshNormalMaterial ) {
	
						m_uniforms.opacity.value = material.opacity;
	
					}
	
					WebGLUniforms.upload(
							_gl, materialProperties.uniformsList, m_uniforms, _this );
	
				}
	
	
				// common matrices
	
				p_uniforms.set( _gl, object, 'modelViewMatrix' );
				p_uniforms.set( _gl, object, 'normalMatrix' );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
	
				return program;
	
			}
	
			// Uniforms (refresh uniforms objects)
	
			function refreshUniformsCommon( uniforms, material ) {
	
				uniforms.opacity.value = material.opacity;
	
				uniforms.diffuse.value = material.color;
	
				if ( material.emissive ) {
	
					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
				}
	
				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;
	
				if ( material.aoMap ) {
	
					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
				}
	
				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map
	
				var uvScaleMap;
	
				if ( material.map ) {
	
					uvScaleMap = material.map;
	
				} else if ( material.specularMap ) {
	
					uvScaleMap = material.specularMap;
	
				} else if ( material.displacementMap ) {
	
					uvScaleMap = material.displacementMap;
	
				} else if ( material.normalMap ) {
	
					uvScaleMap = material.normalMap;
	
				} else if ( material.bumpMap ) {
	
					uvScaleMap = material.bumpMap;
	
				} else if ( material.roughnessMap ) {
	
					uvScaleMap = material.roughnessMap;
	
				} else if ( material.metalnessMap ) {
	
					uvScaleMap = material.metalnessMap;
	
				} else if ( material.alphaMap ) {
	
					uvScaleMap = material.alphaMap;
	
				} else if ( material.emissiveMap ) {
	
					uvScaleMap = material.emissiveMap;
	
				}
	
				if ( uvScaleMap !== undefined ) {
	
					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {
	
						uvScaleMap = uvScaleMap.texture;
	
					}
	
					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
				uniforms.envMap.value = material.envMap;
	
				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;
	
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;
	
			}
	
			function refreshUniformsLine( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
	
			}
	
			function refreshUniformsDash( uniforms, material ) {
	
				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;
	
			}
	
			function refreshUniformsPoints( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;
	
				uniforms.map.value = material.map;
	
				if ( material.map !== null ) {
	
					var offset = material.map.offset;
					var repeat = material.map.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
			}
	
			function refreshUniformsFog( uniforms, fog ) {
	
				uniforms.fogColor.value = fog.color;
	
				if ( fog.isFog ) {
	
					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;
	
				} else if ( fog.isFogExp2 ) {
	
					uniforms.fogDensity.value = fog.density;
	
				}
	
			}
	
			function refreshUniformsLambert( uniforms, material ) {
	
				if ( material.lightMap ) {
	
					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
				}
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
			}
	
			function refreshUniformsPhong( uniforms, material ) {
	
				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
				if ( material.lightMap ) {
	
					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
				}
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			function refreshUniformsStandard( uniforms, material ) {
	
				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;
	
				if ( material.roughnessMap ) {
	
					uniforms.roughnessMap.value = material.roughnessMap;
	
				}
	
				if ( material.metalnessMap ) {
	
					uniforms.metalnessMap.value = material.metalnessMap;
	
				}
	
				if ( material.lightMap ) {
	
					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
				}
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
				if ( material.envMap ) {
	
					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;
	
				}
	
			}
	
			function refreshUniformsPhysical( uniforms, material ) {
	
				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	
				refreshUniformsStandard( uniforms, material );
	
			}
	
			// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
			function markUniformsLightsNeedsUpdate( uniforms, value ) {
	
				uniforms.ambientLightColor.needsUpdate = value;
	
				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;
	
			}
	
			// Lighting
	
			function setupShadows( lights ) {
	
				var lightShadowsLength = 0;
	
				for ( var i = 0, l = lights.length; i < l; i ++ ) {
	
					var light = lights[ i ];
	
					if ( light.castShadow ) {
	
						_lights.shadows[ lightShadowsLength ++ ] = light;
	
					}
	
				}
	
				_lights.shadows.length = lightShadowsLength;
	
			}
	
			function setupLights( lights, camera ) {
	
				var l, ll, light,
				r = 0, g = 0, b = 0,
				color,
				intensity,
				distance,
				shadowMap,
	
				viewMatrix = camera.matrixWorldInverse,
	
				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				hemiLength = 0;
	
				for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
					light = lights[ l ];
	
					color = light.color;
					intensity = light.intensity;
					distance = light.distance;
	
					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
	
					if ( light.isAmbientLight ) {
	
						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;
	
					} else if ( light.isDirectionalLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ++ ] = uniforms;
	
					} else if ( light.isSpotLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ++ ] = uniforms;
	
					} else if ( light.isPointLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.pointShadowMap[ pointLength ] = shadowMap;
	
						if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {
	
							_lights.pointShadowMatrix[ pointLength ] = new Matrix4();
	
						}
	
						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
						_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
						_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );
	
						_lights.point[ pointLength ++ ] = uniforms;
	
					} else if ( light.isHemisphereLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();
	
						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
						_lights.hemi[ hemiLength ++ ] = uniforms;
	
					}
	
				}
	
				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;
	
				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;
	
				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;
	
			}
	
			// GL state setting
	
			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );
	
			};
	
			// Textures
	
			function allocTextureUnit() {
	
				var textureUnit = _usedTextureUnits;
	
				if ( textureUnit >= capabilities.maxTextures ) {
	
					console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
				}
	
				_usedTextureUnits += 1;
	
				return textureUnit;
	
			}
	
			this.allocTextureUnit = allocTextureUnit;
	
			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function() {
	
				var warned = false;
	
				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {
	
					if ( texture && texture.isWebGLRenderTarget ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTexture = ( function() {
	
				var warned = false;
	
				return function setTexture( texture, slot ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTextureCube = ( function() {
	
				var warned = false;
	
				return function setTextureCube( texture, slot ) {
	
					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
						// CompressedTexture can have Array in image :/
	
						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );
	
					} else {
	
						// assumed: texture property of THREE.WebGLRenderTargetCube
	
						textures.setTextureCubeDynamic( texture, slot );
	
					}
	
				};
	
			}() );
	
			this.getCurrentRenderTarget = function() {
	
				return _currentRenderTarget;
	
			};
	
			this.setRenderTarget = function ( renderTarget ) {
	
				_currentRenderTarget = renderTarget;
	
				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
					textures.setupRenderTarget( renderTarget );
	
				}
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;
	
				if ( renderTarget ) {
	
					var renderTargetProperties = properties.get( renderTarget );
	
					if ( isCube ) {
	
						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
					} else {
	
						framebuffer = renderTargetProperties.__webglFramebuffer;
	
					}
	
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;
	
					_currentViewport.copy( renderTarget.viewport );
	
				} else {
	
					framebuffer = null;
	
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;
	
					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
				}
	
				if ( _currentFramebuffer !== framebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;
	
				}
	
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );
	
				state.viewport( _currentViewport );
	
				if ( isCube ) {
	
					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
	
				}
	
			};
	
			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
				if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {
	
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;
	
				}
	
				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
				if ( framebuffer ) {
	
					var restore = false;
	
					if ( framebuffer !== _currentFramebuffer ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
						restore = true;
	
					}
	
					try {
	
						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;
	
						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;
	
						}
	
						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;
	
						}
	
						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	
							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
	
								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );
	
							}
	
						} else {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
						}
	
					} finally {
	
						if ( restore ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
						}
	
					}
	
				}
	
			};
	
			// Map three.js constants to WebGL constants
	
			function paramThreeToGL( p ) {
	
				var extension;
	
				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;
	
				if ( p === HalfFloatType ) {
	
					extension = extensions.get( 'OES_texture_half_float' );
	
					if ( extension !== null ) return extension.HALF_FLOAT_OES;
	
				}
	
				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;
	
				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
					}
	
				}
	
				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					 p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
					}
	
				}
	
				if ( p === RGB_ETC1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
				}
	
				if ( p === MinEquation || p === MaxEquation ) {
	
					extension = extensions.get( 'EXT_blend_minmax' );
	
					if ( extension !== null ) {
	
						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;
	
					}
	
				}
	
				if ( p === UnsignedInt248Type ) {
	
					extension = extensions.get( 'WEBGL_depth_texture' );
	
					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
	
				}
	
				return 0;
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function FogExp2 ( color, density ) {
	
			this.name = '';
	
			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;
	
		}
	
		FogExp2.prototype.isFogExp2 = true;
	
		FogExp2.prototype.clone = function () {
	
			return new FogExp2( this.color.getHex(), this.density );
	
		};
	
		FogExp2.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Fog ( color, near, far ) {
	
			this.name = '';
	
			this.color = new Color( color );
	
			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;
	
		}
	
		Fog.prototype.isFog = true;
	
		Fog.prototype.clone = function () {
	
			return new Fog( this.color.getHex(), this.near, this.far );
	
		};
	
		Fog.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Scene () {
	
			Object3D.call( this );
	
			this.type = 'Scene';
	
			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;
	
			this.autoUpdate = true; // checked by the renderer
	
		}
	
		Scene.prototype = Object.create( Object3D.prototype );
	
		Scene.prototype.constructor = Scene;
	
		Scene.prototype.copy = function ( source, recursive ) {
	
			Object3D.prototype.copy.call( this, source, recursive );
	
			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
	
			return this;
	
		};
	
		Scene.prototype.toJSON = function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
	
			return data;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlare( texture, size, distance, blending, color ) {
	
			Object3D.call( this );
	
			this.lensFlares = [];
	
			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;
	
			if ( texture !== undefined ) {
	
				this.add( texture, size, distance, blending, color );
	
			}
	
		}
	
		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LensFlare,
	
			isLensFlare: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;
	
				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
					this.lensFlares.push( source.lensFlares[ i ] );
	
				}
	
				return this;
	
			},
	
			add: function ( texture, size, distance, blending, color, opacity ) {
	
				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;
	
				distance = Math.min( distance, Math.max( 0, distance ) );
	
				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );
	
			},
	
			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */
	
			updateLensFlares: function () {
	
				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;
	
				for ( f = 0; f < fl; f ++ ) {
	
					flare = this.lensFlares[ f ];
	
					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;
	
					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */
	
		function SpriteMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'SpriteMaterial';
	
			this.color = new Color( 0xffffff );
			this.map = null;
	
			this.rotation = 0;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;
	
		SpriteMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.map = source.map;
	
			this.rotation = source.rotation;
	
			return this;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Sprite( material ) {
	
			Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();
	
		}
	
		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Sprite,
	
			isSprite: true,
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
					var guessSizeSq = this.scale.x * this.scale.y / 4;
	
					if ( distanceSq > guessSizeSq ) {
	
						return;
	
					}
	
					intersects.push( {
	
						distance: Math.sqrt( distanceSq ),
						point: this.position,
						face: null,
						object: this
	
					} );
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LOD() {
	
			Object3D.call( this );
	
			this.type = 'LOD';
	
			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );
	
		}
	
	
		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LOD,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source, false );
	
				var levels = source.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					this.addLevel( level.object.clone(), level.distance );
	
				}
	
				return this;
	
			},
	
			addLevel: function ( object, distance ) {
	
				if ( distance === undefined ) distance = 0;
	
				distance = Math.abs( distance );
	
				var levels = this.levels;
	
				for ( var l = 0; l < levels.length; l ++ ) {
	
					if ( distance < levels[ l ].distance ) {
	
						break;
	
					}
	
				}
	
				levels.splice( l, 0, { distance: distance, object: object } );
	
				this.add( object );
	
			},
	
			getObjectForDistance: function ( distance ) {
	
				var levels = this.levels;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance < levels[ i ].distance ) {
	
						break;
	
					}
	
				}
	
				return levels[ i - 1 ].object;
	
			},
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
					this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
				};
	
			}() ),
	
			update: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function update( camera ) {
	
					var levels = this.levels;
	
					if ( levels.length > 1 ) {
	
						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );
	
						var distance = v1.distanceTo( v2 );
	
						levels[ 0 ].object.visible = true;
	
						for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
							if ( distance >= levels[ i ].distance ) {
	
								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;
	
							} else {
	
								break;
	
							}
	
						}
	
						for ( ; i < l; i ++ ) {
	
							levels[ i ].object.visible = false;
	
						}
	
					}
	
				};
	
			}(),
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.levels = [];
	
				var levels = this.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );
	
				}
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { data: data, width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.generateMipmaps  = false;
			this.flipY = false;
			this.unpackAlignment = 1;
	
		}
	
		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;
	
		DataTexture.prototype.isDataTexture = true;
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */
	
		function Skeleton( bones, boneInverses, useVertexTexture ) {
	
			this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
			this.identityMatrix = new Matrix4();
	
			// copy the bone array
	
			bones = bones || [];
	
			this.bones = bones.slice( 0 );
	
			// create a bone texture or an array of floats
	
			if ( this.useVertexTexture ) {
	
				// layout (1 matrix = 4 pixels)
				//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
				//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
				//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
				//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
	
				var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
				size = _Math.nextPowerOfTwo( Math.ceil( size ) );
				size = Math.max( size, 4 );
	
				this.boneTextureWidth = size;
				this.boneTextureHeight = size;
	
				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );
	
			} else {
	
				this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
			}
	
			// use the supplied bone inverses or calculate the inverses
	
			if ( boneInverses === undefined ) {
	
				this.calculateInverses();
	
			} else {
	
				if ( this.bones.length === boneInverses.length ) {
	
					this.boneInverses = boneInverses.slice( 0 );
	
				} else {
	
					console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
					this.boneInverses = [];
	
					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
						this.boneInverses.push( new Matrix4() );
	
					}
	
				}
	
			}
	
		}
	
		Object.assign( Skeleton.prototype, {
	
			calculateInverses: function () {
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					var inverse = new Matrix4();
	
					if ( this.bones[ b ] ) {
	
						inverse.getInverse( this.bones[ b ].matrixWorld );
	
					}
	
					this.boneInverses.push( inverse );
	
				}
	
			},
	
			pose: function () {
	
				var bone;
	
				// recover the bind-time world matrices
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					bone = this.bones[ b ];
	
					if ( bone ) {
	
						bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
					}
	
				}
	
				// compute the local matrices, positions, rotations and scales
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					bone = this.bones[ b ];
	
					if ( bone ) {
	
						if ( (bone.parent && bone.parent.isBone) ) {
	
							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );
	
						} else {
	
							bone.matrix.copy( bone.matrixWorld );
	
						}
	
						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
					}
	
				}
	
			},
	
			update: ( function () {
	
				var offsetMatrix = new Matrix4();
	
				return function update() {
	
					// flatten bone matrices to array
	
					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
						// compute the offset between the current and the original transform
	
						var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
						offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
						offsetMatrix.toArray( this.boneMatrices, b * 16 );
	
					}
	
					if ( this.useVertexTexture ) {
	
						this.boneTexture.needsUpdate = true;
	
					}
	
				};
	
			} )(),
	
			clone: function () {
	
				return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function Bone( skin ) {
	
			Object3D.call( this );
	
			this.type = 'Bone';
	
			this.skin = skin;
	
		}
	
		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Bone,
	
			isBone: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.skin = source.skin;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function SkinnedMesh( geometry, material, useVertexTexture ) {
	
			Mesh.call( this, geometry, material );
	
			this.type = 'SkinnedMesh';
	
			this.bindMode = "attached";
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
	
			// init bones
	
			// TODO: remove bone creation as there is no reason (other than
			// convenience) for THREE.SkinnedMesh to do this.
	
			var bones = [];
	
			if ( this.geometry && this.geometry.bones !== undefined ) {
	
				var bone, gbone;
	
				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
					gbone = this.geometry.bones[ b ];
	
					bone = new Bone( this );
					bones.push( bone );
	
					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
				}
	
				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
					gbone = this.geometry.bones[ b ];
	
					if ( gbone.parent !== - 1 && gbone.parent !== null &&
							bones[ gbone.parent ] !== undefined ) {
	
						bones[ gbone.parent ].add( bones[ b ] );
	
					} else {
	
						this.add( bones[ b ] );
	
					}
	
				}
	
			}
	
			this.normalizeSkinWeights();
	
			this.updateMatrixWorld( true );
			this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
		}
	
	
		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
	
			constructor: SkinnedMesh,
	
			isSkinnedMesh: true,
	
			bind: function( skeleton, bindMatrix ) {
	
				this.skeleton = skeleton;
	
				if ( bindMatrix === undefined ) {
	
					this.updateMatrixWorld( true );
	
					this.skeleton.calculateInverses();
	
					bindMatrix = this.matrixWorld;
	
				}
	
				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );
	
			},
	
			pose: function () {
	
				this.skeleton.pose();
	
			},
	
			normalizeSkinWeights: function () {
	
				if ( (this.geometry && this.geometry.isGeometry) ) {
	
					for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
						var sw = this.geometry.skinWeights[ i ];
	
						var scale = 1.0 / sw.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							sw.multiplyScalar( scale );
	
						} else {
	
							sw.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
					}
	
				} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {
	
					var vec = new Vector4();
	
					var skinWeight = this.geometry.attributes.skinWeight;
	
					for ( var i = 0; i < skinWeight.count; i ++ ) {
	
						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );
	
						var scale = 1.0 / vec.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							vec.multiplyScalar( scale );
	
						} else {
	
							vec.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
					}
	
				}
	
			},
	
			updateMatrixWorld: function( force ) {
	
				Mesh.prototype.updateMatrixWorld.call( this, true );
	
				if ( this.bindMode === "attached" ) {
	
					this.bindMatrixInverse.getInverse( this.matrixWorld );
	
				} else if ( this.bindMode === "detached" ) {
	
					this.bindMatrixInverse.getInverse( this.bindMatrix );
	
				} else {
	
					console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
				}
	
			},
	
			clone: function() {
	
				return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */
	
		function LineBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineBasicMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	
		LineBasicMaterial.prototype.isLineBasicMaterial = true;
	
		LineBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Line( geometry, material, mode ) {
	
			if ( mode === 1 ) {
	
				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );
	
			}
	
			Object3D.call( this );
	
			this.type = 'Line';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Line,
	
			isLine: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;
	
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;
	
					if ( (geometry && geometry.isBufferGeometry) ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
								var a = indices[ i ];
								var b = indices[ i + 1 ];
	
								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						}
	
					} else if ( (geometry && geometry.isGeometry) ) {
	
						var vertices = geometry.vertices;
						var nbVertices = vertices.length;
	
						for ( var i = 0; i < nbVertices - 1; i += step ) {
	
							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LineSegments( geometry, material ) {
	
			Line.call( this, geometry, material );
	
			this.type = 'LineSegments';
	
		}
	
		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
	
			constructor: LineSegments,
	
			isLineSegments: true
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */
	
		function PointsMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'PointsMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.map = null;
	
			this.size = 1;
			this.sizeAttenuation = true;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;
	
		PointsMaterial.prototype.isPointsMaterial = true;
	
		PointsMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Points( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Points';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Points,
	
			isPoints: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();
	
					function testPoint( point, index ) {
	
						var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
						if ( rayPointDistanceSq < localThresholdSq ) {
	
							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );
	
							var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
							if ( distance < raycaster.near || distance > raycaster.far ) return;
	
							intersects.push( {
	
								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object
	
							} );
	
						}
	
					}
	
					if ( (geometry && geometry.isBufferGeometry) ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
								var a = indices[ i ];
	
								position.fromArray( positions, a * 3 );
	
								testPoint( position, a );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
								position.fromArray( positions, i * 3 );
	
								testPoint( position, i );
	
							}
	
						}
	
					} else {
	
						var vertices = geometry.vertices;
	
						for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
							testPoint( vertices[ i ], i );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Group() {
	
			Object3D.call( this );
	
			this.type = 'Group';
	
		}
	
		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Group
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.generateMipmaps = false;
	
			var scope = this;
	
			function update() {
	
				requestAnimationFrame( update );
	
				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
	
					scope.needsUpdate = true;
	
				}
	
			}
	
			update();
	
		}
	
		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			this.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			this.generateMipmaps = false;
	
		}
	
		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;
	
		CompressedTexture.prototype.isCompressedTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.needsUpdate = true;
	
		}
	
		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;
	
		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */
	
		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
	
			format = format !== undefined ? format : DepthFormat;
	
			if ( format !== DepthFormat && format !== DepthStencilFormat ) {
	
				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )
	
			}
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.image = { width: width, height: height };
	
			this.type = type !== undefined ? type : UnsignedShortType;
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.flipY = false;
			this.generateMipmaps	= false;
	
		}
	
		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WireframeGeometry( geometry ) {
	
			BufferGeometry.call( this );
	
			var edge = [ 0, 0 ], hash = {};
	
			function sortFunction( a, b ) {
	
				return a - b;
	
			}
	
			var keys = [ 'a', 'b', 'c' ];
	
			if ( (geometry && geometry.isGeometry) ) {
	
				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var numEdges = 0;
	
				// allocate maximal size
				var edges = new Uint32Array( 6 * faces.length );
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( var j = 0; j < 3; j ++ ) {
	
						edge[ 0 ] = face[ keys[ j ] ];
						edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
						edge.sort( sortFunction );
	
						var key = edge.toString();
	
						if ( hash[ key ] === undefined ) {
	
							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;
	
						}
	
					}
	
				}
	
				var coords = new Float32Array( numEdges * 2 * 3 );
	
				for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
					for ( var j = 0; j < 2; j ++ ) {
	
						var vertex = vertices[ edges [ 2 * i + j ] ];
	
						var index = 6 * i + 3 * j;
						coords[ index + 0 ] = vertex.x;
						coords[ index + 1 ] = vertex.y;
						coords[ index + 2 ] = vertex.z;
	
					}
	
				}
	
				this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );
	
			} else if ( (geometry && geometry.isBufferGeometry) ) {
	
				if ( geometry.index !== null ) {
	
					// Indexed BufferGeometry
	
					var indices = geometry.index.array;
					var vertices = geometry.attributes.position;
					var groups = geometry.groups;
					var numEdges = 0;
	
					if ( groups.length === 0 ) {
	
						geometry.addGroup( 0, indices.length );
	
					}
	
					// allocate maximal size
					var edges = new Uint32Array( 2 * indices.length );
	
					for ( var o = 0, ol = groups.length; o < ol; ++ o ) {
	
						var group = groups[ o ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var i = start, il = start + count; i < il; i += 3 ) {
	
							for ( var j = 0; j < 3; j ++ ) {
	
								edge[ 0 ] = indices[ i + j ];
								edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
								edge.sort( sortFunction );
	
								var key = edge.toString();
	
								if ( hash[ key ] === undefined ) {
	
									edges[ 2 * numEdges ] = edge[ 0 ];
									edges[ 2 * numEdges + 1 ] = edge[ 1 ];
									hash[ key ] = true;
									numEdges ++;
	
								}
	
							}
	
						}
	
					}
	
					var coords = new Float32Array( numEdges * 2 * 3 );
	
					for ( var i = 0, l = numEdges; i < l; i ++ ) {
	
						for ( var j = 0; j < 2; j ++ ) {
	
							var index = 6 * i + 3 * j;
							var index2 = edges[ 2 * i + j ];
	
							coords[ index + 0 ] = vertices.getX( index2 );
							coords[ index + 1 ] = vertices.getY( index2 );
							coords[ index + 2 ] = vertices.getZ( index2 );
	
						}
	
					}
	
					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );
	
				} else {
	
					// non-indexed BufferGeometry
	
					var vertices = geometry.attributes.position.array;
					var numEdges = vertices.length / 3;
					var numTris = numEdges / 3;
	
					var coords = new Float32Array( numEdges * 2 * 3 );
	
					for ( var i = 0, l = numTris; i < l; i ++ ) {
	
						for ( var j = 0; j < 3; j ++ ) {
	
							var index = 18 * i + 6 * j;
	
							var index1 = 9 * i + 3 * j;
							coords[ index + 0 ] = vertices[ index1 ];
							coords[ index + 1 ] = vertices[ index1 + 1 ];
							coords[ index + 2 ] = vertices[ index1 + 2 ];
	
							var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
							coords[ index + 3 ] = vertices[ index2 ];
							coords[ index + 4 ] = vertices[ index2 + 1 ];
							coords[ index + 5 ] = vertices[ index2 + 2 ];
	
						}
	
					}
	
					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );
	
				}
	
			}
	
		}
	
		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		function ParametricBufferGeometry( func, slices, stacks ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ParametricBufferGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			// generate vertices and uvs
	
			var vertices = [];
			var uvs = [];
	
			var i, j, p;
			var u, v;
	
			var sliceCount = slices + 1;
	
			for ( i = 0; i <= stacks; i ++ ) {
	
				v = i / stacks;
	
				for ( j = 0; j <= slices; j ++ ) {
	
					u = j / slices;
	
					p = func( u, v );
					vertices.push( p.x, p.y, p.z );
	
					uvs.push( u, v );
	
				}
	
			}
	
			// generate indices
	
			var indices = [];
			var a, b, c, d;
	
			for ( i = 0; i < stacks; i ++ ) {
	
				for ( j = 0; j < slices; j ++ ) {
	
					a = i * sliceCount + j;
					b = i * sliceCount + j + 1;
					c = ( i + 1 ) * sliceCount + j + 1;
					d = ( i + 1 ) * sliceCount + j;
	
					// faces one and two
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', Float32Attribute( vertices, 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );
	
			// generate normals
	
			this.computeVertexNormals();
	
		}
	
		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
	
		/**
		 * @author zz85 / https://github.com/zz85
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		function ParametricGeometry( func, slices, stacks ) {
	
			Geometry.call( this );
	
			this.type = 'ParametricGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();
	
		}
	
		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PolyhedronBufferGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			radius = radius || 1;
			detail = detail || 0;
	
			// default buffer data
	
			var vertexBuffer = [];
			var uvBuffer = [];
	
			// the subdivision creates the vertex buffer data
	
			subdivide( detail );
	
			// all vertices should lie on a conceptual sphere with a given radius
	
			appplyRadius( radius );
	
			// finally, create the uv data
	
			generateUVs();
	
			// build non-indexed geometry
	
			this.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );
			this.normalizeNormals();
	
			this.boundingSphere = new Sphere( new Vector3(), radius );
	
			// helper functions
	
			function subdivide( detail ) {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				// iterate over all faces and apply a subdivison with the given detail value
	
				for ( var i = 0; i < indices.length; i += 3 ) {
	
					// get the vertices of the face
	
					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );
	
					// perform subdivision
	
					subdivideFace( a, b, c, detail );
	
				}
	
			}
	
			function subdivideFace( a, b, c, detail ) {
	
				var cols = Math.pow( 2, detail );
	
				// we use this multidimensional array as a data structure for creating the subdivision
	
				var v = [];
	
				var i, j;
	
				// construct all of the vertices for this subdivision
	
				for ( i = 0 ; i <= cols; i ++ ) {
	
					v[ i ] = [];
	
					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );
	
					var rows = cols - i;
	
					for ( j = 0; j <= rows; j ++ ) {
	
						if ( j === 0 && i === cols ) {
	
							v[ i ][ j ] = aj;
	
						} else {
	
							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
	
						}
	
					}
	
				}
	
				// construct all of the faces
	
				for ( i = 0; i < cols ; i ++ ) {
	
					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
						var k = Math.floor( j / 2 );
	
						if ( j % 2 === 0 ) {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );
	
						} else {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
	
						}
	
					}
	
				}
	
			}
	
			function appplyRadius( radius ) {
	
				var vertex = new Vector3();
	
				// iterate over the entire buffer and apply the radius to each vertex
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					vertex.normalize().multiplyScalar( radius );
	
					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;
	
				}
	
			}
	
			function generateUVs() {
	
				var vertex = new Vector3();
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );
	
				}
	
				correctUVs();
	
				correctSeam();
	
			}
	
			function correctSeam() {
	
				// handle case when face straddles the seam, see #3269
	
				for ( var i = 0; i < uvBuffer.length; i += 6 ) {
	
					// uv data of a single face
	
					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];
	
					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );
	
					// 0.9 is somewhat arbitrary
	
					if ( max > 0.9 && min < 0.1 ) {
	
						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
	
					}
	
				}
	
			}
	
			function pushVertex( vertex ) {
	
				vertexBuffer.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			function getVertexByIndex( index, vertex ) {
	
				var stride = index * 3;
	
				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];
	
			}
	
			function correctUVs() {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				var centroid = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
	
					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
	
					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
	
					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
	
					var azi = azimuth( centroid );
	
					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );
	
				}
	
			}
	
			function correctUV( uv, stride, vector, azimuth  ) {
	
				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
	
					uvBuffer[ stride ] =  uv.x - 1;
	
				}
	
				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
	
					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
	
				}
	
			}
	
			// Angle around the Y axis, counter-clockwise when looking from above.
	
			function azimuth( vector ) {
	
				return Math.atan2( vector.z, - vector.x );
	
			}
	
	
			// Angle above the XZ plane.
	
			function inclination( vector ) {
	
				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
			}
	
		}
	
		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TetrahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];
	
			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'TetrahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function TetrahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'TetrahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function OctahedronBufferGeometry( radius,detail ) {
	
			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];
	
			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'OctahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function OctahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'OctahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function IcosahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];
	
			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'IcosahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function IcosahedronGeometry( radius, detail ) {
	
		 	Geometry.call( this );
	
			this.type = 'IcosahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function DodecahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;
	
			var vertices = [
	
				// (1, 1, 1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				 1, - 1, - 1,     1, - 1,  1,
				 1,  1, - 1,     1,  1,  1,
	
				// (0, 1/, )
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,
	
				// (1/, , 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,
	
				// (, 0, 1/)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];
	
			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'DodecahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
	
		/**
		 * @author Abe Pazos / https://hamoid.com
		 */
	
		function DodecahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'DodecahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
	
		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function PolyhedronGeometry( vertices, indices, radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'PolyhedronGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();
	
		}
	
		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 *
		 */
	
		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TubeBufferGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;
	
			var frames = path.computeFrenetFrames( tubularSegments, closed );
	
			// expose internals
	
			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;
	
			// helper variables
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var i, j;
	
			// buffer
	
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
	
			// create buffer data
	
			generateBufferData();
	
			// build geometry
	
			this.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', Float32Attribute( vertices, 3 ) );
			this.addAttribute( 'normal', Float32Attribute( normals, 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );
	
			// functions
	
			function generateBufferData() {
	
				for ( i = 0; i < tubularSegments; i ++ ) {
	
					generateSegment( i );
	
				}
	
				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	
				generateSegment( ( closed === false ) ? tubularSegments : 0 );
	
				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries
	
				generateUVs();
	
				// finally create faces
	
				generateIndices();
	
			}
	
			function generateSegment( i ) {
	
				// we use getPointAt to sample evenly distributed points from the given path
	
				var P = path.getPointAt( i / tubularSegments );
	
				// retrieve corresponding normal and binormal
	
				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];
	
				// generate normals and vertices for the current segment
	
				for ( j = 0; j <= radialSegments; j ++ ) {
	
					var v = j / radialSegments * Math.PI * 2;
	
					var sin =   Math.sin( v );
					var cos = - Math.cos( v );
	
					// normal
	
					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// vertex
	
					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			function generateIndices() {
	
				for ( j = 1; j <= tubularSegments; j ++ ) {
	
					for ( i = 1; i <= radialSegments; i ++ ) {
	
						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
					}
	
				}
	
			}
	
			function generateUVs() {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					for ( j = 0; j <= radialSegments; j ++ ) {
	
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
	
						uvs.push( uv.x, uv.y );
	
					}
	
				}
	
			}
	
		}
	
		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
	
		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 */
	
		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
	
			Geometry.call( this );
	
			this.type = 'TubeGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
	
			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
	
			// expose internals
	
			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;
	
			// create geometry
	
			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();
	
		}
	
		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * see: http://www.blackpawn.com/texts/pqtorus/
		 */
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusKnotBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;
	
			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;
	
			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
			// helper variables
			var i, j, index = 0, indexOffset = 0;
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var P1 = new Vector3();
			var P2 = new Vector3();
	
			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();
	
			// generate vertices, normals and uvs
	
			for ( i = 0; i <= tubularSegments; ++ i ) {
	
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	
				var u = i / tubularSegments * p * Math.PI * 2;
	
				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	
				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
	
				// calculate orthonormal basis
	
				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );
	
				// normalize B, N. T can be ignored, we don't use it
	
				B.normalize();
				N.normalize();
	
				for ( j = 0; j <= radialSegments; ++ j ) {
	
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	
					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );
	
					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	
					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );
	
					// vertex
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
					normal.subVectors( vertex, P1 ).normalize();
					normals.setXYZ( index, normal.x, normal.y, normal.z );
	
					// uv
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
					uvs.setXY( index, uv.x, uv.y );
	
					// increase index
					index ++;
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= tubularSegments; j ++ ) {
	
				for ( i = 1; i <= radialSegments; i ++ ) {
	
					// indices
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;
	
					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );
	
			// this function calculates the current position on the torus curve
	
			function calculatePositionOnCurve( u, p, q, radius, position ) {
	
				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );
	
				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;
	
			}
	
		}
	
		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 */
	
		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	
			Geometry.call( this );
	
			this.type = 'TorusKnotGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	
			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();
	
		}
	
		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;
	
			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;
	
			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );
	
			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;
	
			// helper variables
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();
	
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= radialSegments; j ++ ) {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;
	
					// vertex
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );
	
					vertices[ vertexBufferOffset ] = vertex.x;
					vertices[ vertexBufferOffset + 1 ] = vertex.y;
					vertices[ vertexBufferOffset + 2 ] = vertex.z;
	
					// this vector is used to calculate the normal
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
	
					// normal
					normal.subVectors( vertex, center ).normalize();
	
					normals[ vertexBufferOffset ] = normal.x;
					normals[ vertexBufferOffset + 1 ] = normal.y;
					normals[ vertexBufferOffset + 2 ] = normal.z;
	
					// uv
					uvs[ uvBufferOffset ] = i / tubularSegments;
					uvs[ uvBufferOffset + 1 ] = j / radialSegments;
	
					// update offsets
					vertexBufferOffset += 3;
					uvBufferOffset += 2;
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= radialSegments; j ++ ) {
	
				for ( i = 1; i <= tubularSegments; i ++ ) {
	
					// indices
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;
	
					// face one
					indices[ indexBufferOffset ] = a;
					indices[ indexBufferOffset + 1 ] = b;
					indices[ indexBufferOffset + 2 ] = d;
	
					// face two
					indices[ indexBufferOffset + 3 ] = b;
					indices[ indexBufferOffset + 4 ] = c;
					indices[ indexBufferOffset + 5 ] = d;
	
					// update offset
					indexBufferOffset += 6;
	
				}
	
			}
	
			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );
	
		}
	
		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
		 */
	
		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			Geometry.call( this );
	
			this.type = 'TorusGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	
		}
	
		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		var ShapeUtils = {
	
			// calculate area of the contour polygon
	
			area: function ( contour ) {
	
				var n = contour.length;
				var a = 0.0;
	
				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
				}
	
				return a * 0.5;
	
			},
	
			triangulate: ( function () {
	
				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */
	
				function snip( contour, u, v, w, n, verts ) {
	
					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;
	
					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;
	
					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;
	
					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;
	
					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;
	
					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;
	
					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;
	
					for ( p = 0; p < n; p ++ ) {
	
						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;
	
						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;
	
						// see if p is inside triangle abc
	
						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;
	
						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
					}
	
					return true;
	
				}
	
				// takes in an contour array and returns
	
				return function triangulate( contour, indices ) {
	
					var n = contour.length;
	
					if ( n < 3 ) return null;
	
					var result = [],
						verts = [],
						vertIndices = [];
	
					/* we want a counter-clockwise polygon in verts */
	
					var u, v, w;
	
					if ( ShapeUtils.area( contour ) > 0.0 ) {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
					} else {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
					}
	
					var nv = n;
	
					/*  remove nv - 2 vertices, creating 1 triangle every time */
	
					var count = 2 * nv;   /* error detection */
	
					for ( v = nv - 1; nv > 2; ) {
	
						/* if we loop, it is probably a non-simple polygon */
	
						if ( ( count -- ) <= 0 ) {
	
							//** Triangulate: ERROR - probable bad polygon!
	
							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
							if ( indices ) return vertIndices;
							return result;
	
						}
	
						/* three consecutive vertices in current polygon, <u,v,w> */
	
						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
						if ( snip( contour, u, v, w, nv, verts ) ) {
	
							var a, b, c, s, t;
	
							/* true names of the vertices */
	
							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];
	
							/* output Triangle */
	
							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );
	
	
							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
							/* remove v from the remaining polygon */
	
							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
								verts[ s ] = verts[ t ];
	
							}
	
							nv --;
	
							/* reset error detection counter */
	
							count = 2 * nv;
	
						}
	
					}
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
			} )(),
	
			triangulateShape: function ( contour, holes ) {
	
				function removeDupEndPts(points) {
	
					var l = points.length;
	
					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
	
						points.pop();
	
					}
	
				}
	
				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );
	
				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {
	
						if ( inSegPt1.x < inSegPt2.x ) {
	
							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
						} else {
	
							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
						}
	
					} else {
	
						if ( inSegPt1.y < inSegPt2.y ) {
	
							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
						} else {
	
							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
						}
	
					}
	
				}
	
				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
					if ( Math.abs( limit ) > Number.EPSILON ) {
	
						// not parallel
	
						var perpSeg2;
						if ( limit > 0 ) {
	
							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
						} else {
	
							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
						}
	
						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];
	
						}
						if ( perpSeg2 === limit ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];
	
						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
					} else {
	
						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {
	
							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point
	
						}
						// segment#1  is a single point
						if ( seg1Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];
	
						}
						// segment#2  is a single point
						if ( seg2Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];
	
						}
	
						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {
	
							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
							}
	
						} else {
	
							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
							}
	
						}
						if ( seg1minVal <= seg2minVal ) {
	
							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];
	
						} else {
	
							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];
	
						}
	
					}
	
				}
	
				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
					// The order of legs is important
	
					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
						// angle != 180 deg.
	
						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
						if ( from2toAngle > 0 ) {
	
							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
						} else {
	
							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
						}
	
					} else {
	
						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );
	
					}
	
				}
	
	
				function removeHoles( contour, holes ) {
	
					var shape = contour.concat(); // work on this shape
					var hole;
	
					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;
	
						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;
	
						}
	
						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;
	
						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;
	
						}
	
						return	true;
	
					}
	
					function intersectsShapeEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
						return	false;
	
					}
	
					var indepHoles = [];
	
					function intersectsHoleEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;
	
							}
	
						}
						return	false;
	
					}
	
					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;
	
					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
						indepHoles.push( h );
	
					}
	
					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {
	
						counter --;
						if ( counter < 0 ) {
	
							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;
	
						}
	
						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;
	
							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {
	
								holeIdx = indepHoles[ h ];
	
								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;
	
								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
									holeIndex = h2;
									indepHoles.splice( h, 1 );
	
									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
									minShapeIndex = shapeIndex;
	
									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );
	
									break;
	
								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found
	
								failedCuts[ cutKey ] = true;			// remember failure
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
						}
	
					}
	
					return shape; 			/* shape with no holes */
	
				}
	
	
				var i, il, f, face,
					key, index,
					allPointsMap = {};
	
				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
				var allpoints = contour.concat();
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					Array.prototype.push.apply( allpoints, holes[ h ] );
	
				}
	
				//console.log( "allpoints",allpoints, allpoints.length );
	
				// prepare all points map
	
				for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
					key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
					if ( allPointsMap[ key ] !== undefined ) {
	
						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );
	
					}
	
					allPointsMap[ key ] = i;
	
				}
	
				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );
	
				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );
	
				// check all face vertices against all points map
	
				for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
					face = triangles[ i ];
	
					for ( f = 0; f < 3; f ++ ) {
	
						key = face[ f ].x + ":" + face[ f ].y;
	
						index = allPointsMap[ key ];
	
						if ( index !== undefined ) {
	
							face[ f ] = index;
	
						}
	
					}
	
				}
	
				return triangles.concat();
	
			},
	
			isClockWise: function ( pts ) {
	
				return ShapeUtils.area( pts ) < 0;
	
			},
	
			// Bezier Curves formulas obtained from
			// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
			// Quad Bezier Functions
	
			b2: ( function () {
	
				function b2p0( t, p ) {
	
					var k = 1 - t;
					return k * k * p;
	
				}
	
				function b2p1( t, p ) {
	
					return 2 * ( 1 - t ) * t * p;
	
				}
	
				function b2p2( t, p ) {
	
					return t * t * p;
	
				}
	
				return function b2( t, p0, p1, p2 ) {
	
					return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );
	
				};
	
			} )(),
	
			// Cubic Bezier Functions
	
			b3: ( function () {
	
				function b3p0( t, p ) {
	
					var k = 1 - t;
					return k * k * k * p;
	
				}
	
				function b3p1( t, p ) {
	
					var k = 1 - t;
					return 3 * k * k * t * p;
	
				}
	
				function b3p2( t, p ) {
	
					var k = 1 - t;
					return 3 * k * t * t * p;
	
				}
	
				function b3p3( t, p ) {
	
					return t * t * t * p;
	
				}
	
				return function b3( t, p0, p1, p2, p3 ) {
	
					return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );
	
				};
	
			} )()
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/
	
		function ExtrudeGeometry( shapes, options ) {
	
			if ( typeof( shapes ) === "undefined" ) {
	
				shapes = [];
				return;
	
			}
	
			Geometry.call( this );
	
			this.type = 'ExtrudeGeometry';
	
			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
			this.addShapeList( shapes, options );
	
			this.computeFaceNormals();
	
			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides
	
			//this.computeVertexNormals();
	
			//console.log( "took", ( Date.now() - startTime ) );
	
		}
	
		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
	
		ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
			var sl = shapes.length;
	
			for ( var s = 0; s < sl; s ++ ) {
	
				var shape = shapes[ s ];
				this.addShape( shape, options );
	
			}
	
		};
	
		ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
			var amount = options.amount !== undefined ? options.amount : 100;
	
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
			var steps = options.steps !== undefined ? options.steps : 1;
	
			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;
	
			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
	
			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {
	
				extrudePts = extrudePath.getSpacedPoints( steps );
	
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion
	
				// SETUP TNB variables
	
				// TODO1 - have a .isClosed in spline?
	
				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );
	
				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
	
			}
	
			// Safeguards if bevels are not enabled
	
			if ( ! bevelEnabled ) {
	
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
	
			}
	
			// Variables initialization
	
			var ahole, h, hl; // looping of holes
			var scope = this;
	
			var shapesOffset = this.vertices.length;
	
			var shapePoints = shape.extractPoints( curveSegments );
	
			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
	
			var reverse = ! ShapeUtils.isClockWise( vertices );
	
			if ( reverse ) {
	
				vertices = vertices.reverse();
	
				// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
	
					if ( ShapeUtils.isClockWise( ahole ) ) {
	
						holes[ h ] = ahole.reverse();
	
					}
	
				}
	
				reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
			}
	
	
			var faces = ShapeUtils.triangulateShape( vertices, holes );
	
			/* Vertices */
	
			var contour = vertices; // vertices has all points but contour has only points of circumference
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				vertices = vertices.concat( ahole );
	
			}
	
	
			function scalePt2( pt, vec, size ) {
	
				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
				return vec.clone().multiplyScalar( size ).add( pt );
	
			}
	
			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;
	
	
			// Find directions for point movement
	
	
			function getBevelVec( inPt, inPrev, inNext ) {
	
				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
				var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html
	
				var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
					// not collinear
	
					// length of vectors for normalizing
	
					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
					// shift adjacent points by unit vectors to the left
	
					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
					// scaling factor for v_prev to intersection point
	
					var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
							  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
					// vector from inPt to intersection point
	
					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {
	
						return	new Vector2( v_trans_x, v_trans_y );
	
					} else {
	
						shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
					}
	
				} else {
	
					// handle special case of collinear edges
	
					var direction_eq = false;		// assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {
	
						if ( v_next_x > Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( v_prev_x < - Number.EPSILON ) {
	
							if ( v_next_x < - Number.EPSILON ) {
	
								direction_eq = true;
	
							}
	
						} else {
	
							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
								direction_eq = true;
	
							}
	
						}
	
					}
	
					if ( direction_eq ) {
	
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y =  v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );
	
					} else {
	
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
					}
	
				}
	
				return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
			}
	
	
			var contourMovements = [];
	
			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)
	
				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
			}
	
			var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				oneHoleMovements = [];
	
				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
					if ( j === il ) j = 0;
					if ( k === il ) k = 0;
	
					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
				}
	
				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );
	
			}
	
	
			// Loop bevelSegments, 1 for the front, 1 for the back
	
			for ( b = 0; b < bevelSegments; b ++ ) {
	
				//for ( b = bevelSegments; b > 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						v( vert.x, vert.y,  - z );
	
					}
	
				}
	
			}
	
			bs = bevelSize;
	
			// Back facing vertices
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, 0 );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
			// Add stepped vertices...
			// Including front facing vertices
	
			var s;
	
			for ( s = 1; s <= steps; s ++ ) {
	
				for ( i = 0; i < vlen; i ++ ) {
	
					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y, amount / steps * s );
	
					} else {
	
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
						v( position2.x, position2.y, position2.z );
	
					}
	
				}
	
			}
	
	
			// Add bevel segments planes
	
			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos ( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y,  amount + z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						if ( ! extrudeByPath ) {
	
							v( vert.x, vert.y,  amount + z );
	
						} else {
	
							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
						}
	
					}
	
				}
	
			}
	
			/* Faces */
	
			// Top and bottom faces
	
			buildLidFaces();
	
			// Sides faces
	
			buildSideFaces();
	
	
			/////  Internal functions
	
			function buildLidFaces() {
	
				if ( bevelEnabled ) {
	
					var layer = 0; // steps + 1
					var offset = vlen * layer;
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
					}
	
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
					}
	
				} else {
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
					}
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
					}
	
				}
	
			}
	
			// Create faces for the z-sides of the shape
	
			function buildSideFaces() {
	
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );
	
					//, true
					layeroffset += ahole.length;
	
				}
	
			}
	
			function sidewalls( contour, layeroffset ) {
	
				var j, k;
				i = contour.length;
	
				while ( -- i >= 0 ) {
	
					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;
	
					//console.log('b', i,j, i-1, k,vertices.length);
	
					var s = 0, sl = steps  + bevelSegments * 2;
	
					for ( s = 0; s < sl; s ++ ) {
	
						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );
	
						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
	
						f4( a, b, c, d, contour, s, sl, j, k );
	
					}
	
				}
	
			}
	
	
			function v( x, y, z ) {
	
				scope.vertices.push( new Vector3( x, y, z ) );
	
			}
	
			function f3( a, b, c ) {
	
				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
	
				scope.faces.push( new Face3( a, b, c, null, null, 0 ) );
	
				var uvs = uvgen.generateTopUV( scope, a, b, c );
	
				scope.faceVertexUvs[ 0 ].push( uvs );
	
			}
	
			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
				d += shapesOffset;
	
				scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
				scope.faces.push( new Face3( b, c, d, null, null, 1 ) );
	
				var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
			}
	
		};
	
		ExtrudeGeometry.WorldUVGenerator = {
	
			generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
				var vertices = geometry.vertices;
	
				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
	
				return [
					new Vector2( a.x, a.y ),
					new Vector2( b.x, b.y ),
					new Vector2( c.x, c.y )
				];
	
			},
	
			generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
				var vertices = geometry.vertices;
	
				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
				var d = vertices[ indexD ];
	
				if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
					return [
						new Vector2( a.x, 1 - a.z ),
						new Vector2( b.x, 1 - b.z ),
						new Vector2( c.x, 1 - c.z ),
						new Vector2( d.x, 1 - d.z )
					];
	
				} else {
	
					return [
						new Vector2( a.y, 1 - a.z ),
						new Vector2( b.y, 1 - b.z ),
						new Vector2( c.y, 1 - c.z ),
						new Vector2( d.y, 1 - d.z )
					];
	
				}
	
			}
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */
	
		function TextGeometry( text, parameters ) {
	
			parameters = parameters || {};
	
			var font = parameters.font;
	
			if ( (font && font.isFont) === false ) {
	
				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();
	
			}
	
			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
			// translate parameters to ExtrudeGeometry API
	
			parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
			// defaults
	
			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
			ExtrudeGeometry.call( this, shapes, parameters );
	
			this.type = 'TextGeometry';
	
		}
	
		TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * based on THREE.SphereGeometry
		 */
	
		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'SphereBufferGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
	
			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
			var thetaEnd = thetaStart + thetaLength;
	
			var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );
	
			var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
			var index = 0, vertices = [], normal = new Vector3();
	
			for ( var y = 0; y <= heightSegments; y ++ ) {
	
				var verticesRow = [];
	
				var v = y / heightSegments;
	
				for ( var x = 0; x <= widthSegments; x ++ ) {
	
					var u = x / widthSegments;
	
					var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					var py = radius * Math.cos( thetaStart + v * thetaLength );
					var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
					normal.set( px, py, pz ).normalize();
	
					positions.setXYZ( index, px, py, pz );
					normals.setXYZ( index, normal.x, normal.y, normal.z );
					uvs.setXY( index, u, 1 - v );
	
					verticesRow.push( index );
	
					index ++;
	
				}
	
				vertices.push( verticesRow );
	
			}
	
			var indices = [];
	
			for ( var y = 0; y < heightSegments; y ++ ) {
	
				for ( var x = 0; x < widthSegments; x ++ ) {
	
					var v1 = vertices[ y ][ x + 1 ];
					var v2 = vertices[ y ][ x ];
					var v3 = vertices[ y + 1 ][ x ];
					var v4 = vertices[ y + 1 ][ x + 1 ];
	
					if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
					if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );
	
				}
	
			}
	
			this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', positions );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );
	
			this.boundingSphere = new Sphere( new Vector3(), radius );
	
		}
	
		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'SphereGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
		}
	
		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'RingBufferGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	
			// these are used to calculate buffer length
			var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
			var indexCount = thetaSegments * phiSegments * 2 * 3;
	
			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
			// some helper variables
			var index = 0, indexOffset = 0, segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;
	
			// generate vertices, normals and uvs
	
			// values are generate from the inside of the ring to the outside
	
			for ( j = 0; j <= phiSegments; j ++ ) {
	
				for ( i = 0; i <= thetaSegments; i ++ ) {
	
					segment = thetaStart + i / thetaSegments * thetaLength;
	
					// vertex
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
					// normal
					normals.setXYZ( index, 0, 0, 1 );
	
					// uv
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
					uvs.setXY( index, uv.x, uv.y );
	
					// increase index
					index++;
	
				}
	
				// increase the radius for next row of vertices
				radius += radiusStep;
	
			}
	
			// generate indices
	
			for ( j = 0; j < phiSegments; j ++ ) {
	
				var thetaSegmentLevel = j * ( thetaSegments + 1 );
	
				for ( i = 0; i < thetaSegments; i ++ ) {
	
					segment = i + thetaSegmentLevel;
	
					// indices
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;
	
					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
	
					// face two
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );
	
		}
	
		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;
	
		/**
		 * @author Kaleb Murphy
		 */
	
		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'RingGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	
		}
	
		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */
	
		function PlaneGeometry( width, height, widthSegments, heightSegments ) {
	
			Geometry.call( this );
	
			this.type = 'PlaneGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
		}
	
		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		 // points - to create a closed torus, one must use a set of points
		 //    like so: [ a, b, c, d, a ], see first is the same as last.
		 // segments - the number of circumference segments to create
		 // phiStart - the starting radian
		 // phiLength - the radian (0 to 2PI) range of the lathed section
		 //    2PI is a closed lathe, less than 2PI is a portion.
	
		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'LatheBufferGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;
	
			// clamp phiLength so it's in range of [ 0, 2PI ]
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
	
			// these are used to calculate buffer length
			var vertexCount = ( segments + 1 ) * points.length;
			var indexCount = segments * points.length * 2 * 3;
	
			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
			// helper variables
			var index = 0, indexOffset = 0, base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;
	
			// generate vertices and uvs
	
			for ( i = 0; i <= segments; i ++ ) {
	
				var phi = phiStart + i * inverseSegments * phiLength;
	
				var sin = Math.sin( phi );
				var cos = Math.cos( phi );
	
				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
	
					// vertex
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
					// uv
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
					uvs.setXY( index, uv.x, uv.y );
	
					// increase index
					index ++;
	
				}
	
			}
	
			// generate indices
	
			for ( i = 0; i < segments; i ++ ) {
	
				for ( j = 0; j < ( points.length - 1 ); j ++ ) {
	
					base = j + i * points.length;
	
					// indices
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;
	
					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;
	
					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'uv', uvs );
	
			// generate normals
	
			this.computeVertexNormals();
	
			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).
	
			if( phiLength === Math.PI * 2 ) {
	
				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();
	
				// this is the buffer offset for the last line of vertices
				base = segments * points.length * 3;
	
				for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
	
					// select the normal of the vertex in the first line
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];
	
					// select the normal of the vertex in the last line
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];
	
					// average normals
					n.addVectors( n1, n2 ).normalize();
	
					// assign the new values to both normals
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
	
				} // next row
	
			}
	
		}
	
		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
	
		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 */
	
		// points - to create a closed torus, one must use a set of points
		//    like so: [ a, b, c, d, a ], see first is the same as last.
		// segments - the number of circumference segments to create
		// phiStart - the starting radian
		// phiLength - the radian (0 to 2PI) range of the lathed section
		//    2PI is a closed lathe, less than 2PI is a portion.
	
		function LatheGeometry( points, segments, phiStart, phiLength ) {
	
			Geometry.call( this );
	
			this.type = 'LatheGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();
	
		}
	
		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;
	
		/**
		 * @author jonobr1 / http://jonobr1.com
		 *
		 * Creates a one-sided polygonal geometry from a path shape. Similar to
		 * ExtrudeGeometry.
		 *
		 * parameters = {
		 *
		 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
		 *
		 *	material: <int> // material index for front and back faces
		 *	uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/
	
		function ShapeGeometry( shapes, options ) {
	
			Geometry.call( this );
	
			this.type = 'ShapeGeometry';
	
			if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];
	
			this.addShapeList( shapes, options );
	
			this.computeFaceNormals();
	
		}
	
		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;
	
		/**
		 * Add an array of shapes to THREE.ShapeGeometry.
		 */
		ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
			for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
				this.addShape( shapes[ i ], options );
	
			}
	
			return this;
	
		};
	
		/**
		 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
		 */
		ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
			if ( options === undefined ) options = {};
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
			var material = options.material;
			var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
			//
	
			var i, l, hole;
	
			var shapesOffset = this.vertices.length;
			var shapePoints = shape.extractPoints( curveSegments );
	
			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
	
			var reverse = ! ShapeUtils.isClockWise( vertices );
	
			if ( reverse ) {
	
				vertices = vertices.reverse();
	
				// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
				for ( i = 0, l = holes.length; i < l; i ++ ) {
	
					hole = holes[ i ];
	
					if ( ShapeUtils.isClockWise( hole ) ) {
	
						holes[ i ] = hole.reverse();
	
					}
	
				}
	
				reverse = false;
	
			}
	
			var faces = ShapeUtils.triangulateShape( vertices, holes );
	
			// Vertices
	
			for ( i = 0, l = holes.length; i < l; i ++ ) {
	
				hole = holes[ i ];
				vertices = vertices.concat( hole );
	
			}
	
			//
	
			var vert, vlen = vertices.length;
			var face, flen = faces.length;
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = vertices[ i ];
	
				this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );
	
			}
	
			for ( i = 0; i < flen; i ++ ) {
	
				face = faces[ i ];
	
				var a = face[ 0 ] + shapesOffset;
				var b = face[ 1 ] + shapesOffset;
				var c = face[ 2 ] + shapesOffset;
	
				this.faces.push( new Face3( a, b, c, null, null, material ) );
				this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );
	
			}
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function EdgesGeometry( geometry, thresholdAngle ) {
	
			BufferGeometry.call( this );
	
			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
	
			var edge = [ 0, 0 ], hash = {};
	
			function sortFunction( a, b ) {
	
				return a - b;
	
			}
	
			var keys = [ 'a', 'b', 'c' ];
	
			var geometry2;
	
			if ( (geometry && geometry.isBufferGeometry) ) {
	
				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );
	
			} else {
	
				geometry2 = geometry.clone();
	
			}
	
			geometry2.mergeVertices();
			geometry2.computeFaceNormals();
	
			var vertices = geometry2.vertices;
			var faces = geometry2.faces;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					var key = edge.toString();
	
					if ( hash[ key ] === undefined ) {
	
						hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
	
					} else {
	
						hash[ key ].face2 = i;
	
					}
	
				}
	
			}
	
			var coords = [];
	
			for ( var key in hash ) {
	
				var h = hash[ key ];
	
				if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {
	
					var vertex = vertices[ h.vert1 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );
	
					vertex = vertices[ h.vert2 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );
	
				}
	
			}
	
			this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );
	
		}
	
		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CylinderBufferGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			var scope = this;
	
			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;
	
			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;
	
			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
	
			// used to calculate buffer length
	
			var nbCap = 0;
	
			if ( openEnded === false ) {
	
				if ( radiusTop > 0 ) nbCap ++;
				if ( radiusBottom > 0 ) nbCap ++;
	
			}
	
			var vertexCount = calculateVertexCount();
			var indexCount = calculateIndexCount();
	
			// buffers
	
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );
	
			// helper variables
	
			var index = 0,
			    indexOffset = 0,
			    indexArray = [],
			    halfHeight = height / 2;
	
			// group variables
			var groupStart = 0;
	
			// generate geometry
	
			generateTorso();
	
			if ( openEnded === false ) {
	
				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );
	
			// helper functions
	
			function calculateVertexCount() {
	
				var count = ( radialSegments + 1 ) * ( heightSegments + 1 );
	
				if ( openEnded === false ) {
	
					count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );
	
				}
	
				return count;
	
			}
	
			function calculateIndexCount() {
	
				var count = radialSegments * heightSegments * 2 * 3;
	
				if ( openEnded === false ) {
	
					count += radialSegments * nbCap * 3;
	
				}
	
				return count;
	
			}
	
			function generateTorso() {
	
				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;
	
				// generate vertices, normals and uvs
	
				for ( y = 0; y <= heightSegments; y ++ ) {
	
					var indexRow = [];
	
					var v = y / heightSegments;
	
					// calculate the radius of the current row
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
					for ( x = 0; x <= radialSegments; x ++ ) {
	
						var u = x / radialSegments;
	
						var theta = u * thetaLength + thetaStart;
	
						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );
	
						// vertex
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
						// normal
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.setXYZ( index, normal.x, normal.y, normal.z );
	
						// uv
						uvs.setXY( index, u, 1 - v );
	
						// save index of vertex in respective row
						indexRow.push( index );
	
						// increase index
						index ++;
	
					}
	
					// now save vertices of the row in our index array
					indexArray.push( indexRow );
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					for ( y = 0; y < heightSegments; y ++ ) {
	
						// we use the index array to access the correct indices
						var i1 = indexArray[ y ][ x ];
						var i2 = indexArray[ y + 1 ][ x ];
						var i3 = indexArray[ y + 1 ][ x + 1 ];
						var i4 = indexArray[ y ][ x + 1 ];
	
						// face one
						indices.setX( indexOffset, i1 ); indexOffset ++;
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;
	
						// face two
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i3 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;
	
						// update counters
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, 0 );
	
				// calculate new start value for groups
				groupStart += groupCount;
	
			}
	
			function generateCap( top ) {
	
				var x, centerIndexStart, centerIndexEnd;
	
				var uv = new Vector2();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;
	
				// save the index of the first center vertex
				centerIndexStart = index;
	
				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment
	
				for ( x = 1; x <= radialSegments; x ++ ) {
	
					// vertex
					vertices.setXYZ( index, 0, halfHeight * sign, 0 );
	
					// normal
					normals.setXYZ( index, 0, sign, 0 );
	
					// uv
					uv.x = 0.5;
					uv.y = 0.5;
	
					uvs.setXY( index, uv.x, uv.y );
	
					// increase index
					index ++;
	
				}
	
				// save the index of the last center vertex
				centerIndexEnd = index;
	
				// now we generate the surrounding vertices, normals and uvs
	
				for ( x = 0; x <= radialSegments; x ++ ) {
	
					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;
	
					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );
	
					// vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );
	
					// normal
					normals.setXYZ( index, 0, sign, 0 );
	
					// uv
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.setXY( index, uv.x, uv.y );
	
					// increase index
					index ++;
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;
	
					if ( top === true ) {
	
						// face top
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;
	
					} else {
	
						// face bottom
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;
	
					}
	
					// update counters
					groupCount += 3;
	
				}
	
				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
	
				// calculate new start value for groups
				groupStart += groupCount;
	
			}
	
		}
	
		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CylinderGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;
	
		/**
		 * @author: abelnation / http://github.com/abelnation
		 */
	
		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeBufferGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CircleBufferGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			var vertices = segments + 2;
	
			var positions = new Float32Array( vertices * 3 );
			var normals = new Float32Array( vertices * 3 );
			var uvs = new Float32Array( vertices * 2 );
	
			// center data is already zero, but need to set a few extras
			normals[ 2 ] = 1.0;
			uvs[ 0 ] = 0.5;
			uvs[ 1 ] = 0.5;
	
			for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {
	
				var segment = thetaStart + s / segments * thetaLength;
	
				positions[ i ] = radius * Math.cos( segment );
				positions[ i + 1 ] = radius * Math.sin( segment );
	
				normals[ i + 2 ] = 1; // normal z
	
				uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
				uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;
	
			}
	
			var indices = [];
	
			for ( var i = 1; i <= segments; i ++ ) {
	
				indices.push( i, i + 1, 0 );
	
			}
	
			this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );
	
			this.boundingSphere = new Sphere( new Vector3(), radius );
	
		}
	
		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
	
		/**
		 * @author hughes
		 */
	
		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CircleGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
		}
	
		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */
	
		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			Geometry.call( this );
	
			this.type = 'BoxGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();
	
		}
	
		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;
	
	
	
		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			SphereGeometry: SphereGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			CircleGeometry: CircleGeometry,
			BoxBufferGeometry: BoxBufferGeometry,
			BoxGeometry: BoxGeometry
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ShadowMaterial() {
	
			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib[ "lights" ],
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );
	
			this.lights = true;
			this.transparent = true;
	
			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );
	
		}
	
		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;
	
		ShadowMaterial.prototype.isShadowMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function RawShaderMaterial( parameters ) {
	
			ShaderMaterial.call( this, parameters );
	
			this.type = 'RawShaderMaterial';
	
		}
	
		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	
		RawShaderMaterial.prototype.isRawShaderMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MultiMaterial( materials ) {
	
			this.uuid = _Math.generateUUID();
	
			this.type = 'MultiMaterial';
	
			this.materials = materials instanceof Array ? materials : [];
	
			this.visible = true;
	
		}
	
		MultiMaterial.prototype = {
	
			constructor: MultiMaterial,
	
			isMultiMaterial: true,
	
			toJSON: function ( meta ) {
	
				var output = {
					metadata: {
						version: 4.2,
						type: 'material',
						generator: 'MaterialExporter'
					},
					uuid: this.uuid,
					type: this.type,
					materials: []
				};
	
				var materials = this.materials;
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					var material = materials[ i ].toJSON( meta );
					delete material.metadata;
	
					output.materials.push( material );
	
				}
	
				output.visible = this.visible;
	
				return output;
	
			},
	
			clone: function () {
	
				var material = new this.constructor();
	
				for ( var i = 0; i < this.materials.length; i ++ ) {
	
					material.materials.push( this.materials[ i ].clone() );
	
				}
	
				material.visible = this.visible;
	
				return material;
	
			}
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshStandardMaterial( parameters ) {
	
			Material.call( this );
	
			this.defines = { 'STANDARD': '' };
	
			this.type = 'MeshStandardMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 0.5;
			this.metalness = 0.5;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.roughnessMap = null;
	
			this.metalnessMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.envMapIntensity = 1.0;
	
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	
		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
	
		MeshStandardMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.defines = { 'STANDARD': '' };
	
			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.roughnessMap = source.roughnessMap;
	
			this.metalnessMap = source.metalnessMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
	
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */
	
		function MeshPhysicalMaterial( parameters ) {
	
			MeshStandardMaterial.call( this );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.type = 'MeshPhysicalMaterial';
	
			this.reflectivity = 0.5; // maps to F0 = 0.04
	
			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;
	
			this.setValues( parameters );
	
		}
	
		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	
		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
	
		MeshPhysicalMaterial.prototype.copy = function ( source ) {
	
			MeshStandardMaterial.prototype.copy.call( this, source );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.reflectivity = source.reflectivity;
	
			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshPhongMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshPhongMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	
		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
	
		MeshPhongMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */
	
		function MeshNormalMaterial( parameters ) {
	
			Material.call( this, parameters );
	
			this.type = 'MeshNormalMaterial';
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
			this.morphTargets = false;
	
			this.setValues( parameters );
	
		}
	
		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	
		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
	
		MeshNormalMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshLambertMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshLambertMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	
		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
	
		MeshLambertMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */
	
		function LineDashedMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineDashedMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
	
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	
		LineDashedMaterial.prototype.isLineDashedMaterial = true;
	
		LineDashedMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
	
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
	
			return this;
	
		};
	
	
	
		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MultiMaterial: MultiMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var Cache = {
	
			enabled: false,
	
			files: {},
	
			add: function ( key, file ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Adding key:', key );
	
				this.files[ key ] = file;
	
			},
	
			get: function ( key ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Checking key:', key );
	
				return this.files[ key ];
	
			},
	
			remove: function ( key ) {
	
				delete this.files[ key ];
	
			},
	
			clear: function () {
	
				this.files = {};
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LoadingManager( onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;
	
			this.itemStart = function ( url ) {
	
				itemsTotal ++;
	
				if ( isLoading === false ) {
	
					if ( scope.onStart !== undefined ) {
	
						scope.onStart( url, itemsLoaded, itemsTotal );
	
					}
	
				}
	
				isLoading = true;
	
			};
	
			this.itemEnd = function ( url ) {
	
				itemsLoaded ++;
	
				if ( scope.onProgress !== undefined ) {
	
					scope.onProgress( url, itemsLoaded, itemsTotal );
	
				}
	
				if ( itemsLoaded === itemsTotal ) {
	
					isLoading = false;
	
					if ( scope.onLoad !== undefined ) {
	
						scope.onLoad();
	
					}
	
				}
	
			};
	
			this.itemError = function ( url ) {
	
				if ( scope.onError !== undefined ) {
	
					scope.onError( url );
	
				}
	
			};
	
		}
	
		var DefaultLoadingManager = new LoadingManager();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function XHRLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( XHRLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );
	
				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {
	
					var mimeType = dataUriRegexResult[1];
					var isBase64 = !!dataUriRegexResult[2];
					var data = dataUriRegexResult[3];
	
					data = window.decodeURIComponent(data);
	
					if( isBase64 ) {
						data = window.atob(data);
					}
	
					try {
	
						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();
	
						switch ( responseType ) {
	
							case 'arraybuffer':
							case 'blob':
	
							 	response = new ArrayBuffer( data.length );
								var view = new Uint8Array( response );
								for ( var i = 0; i < data.length; i ++ ) {
	
										view[ i ] = data.charCodeAt( i );
	
								}
	
								if ( responseType === 'blob' ) {
	
									response = new Blob( [ response ], { "type" : mimeType } );
	
								}
	
								break;
	
							case 'document':
	
								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );
	
								break;
	
							case 'json':
	
								response = JSON.parse( data );
	
								break;
	
							default: // 'text' or other
	
								response = data;
	
								break;
	
						}
	
						// Wait for next browser tick
						window.setTimeout( function() {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						}, 0);
	
					} catch ( error ) {
	
						// Wait for next browser tick
						window.setTimeout( function() {
	
							if ( onError ) onError( error );
	
							scope.manager.itemError( url );
	
						}, 0);
	
					}
	
				} else {
	
					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );
	
					request.addEventListener( 'load', function ( event ) {
	
						var response = event.target.response;
	
						Cache.add( url, response );
	
						if ( this.status === 200 ) {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else if ( this.status === 0 ) {
	
							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.
	
							console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else {
	
							if ( onError ) onError( event );
	
							scope.manager.itemError( url );
	
						}
	
					}, false );
	
					if ( onProgress !== undefined ) {
	
						request.addEventListener( 'progress', function ( event ) {
	
							onProgress( event );
	
						}, false );
	
					}
	
					request.addEventListener( 'error', function ( event ) {
	
						if ( onError ) onError( event );
	
						scope.manager.itemError( url );
	
					}, false );
	
					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
					if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );
	
					request.send( null );
	
				}
	
				scope.manager.itemStart( url );
	
				return request;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			},
	
			setResponseType: function ( value ) {
	
				this.responseType = value;
				return this;
	
			},
	
			setWithCredentials: function ( value ) {
	
				this.withCredentials = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */
	
		function CompressedTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( CompressedTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var images = [];
	
				var texture = new CompressedTexture();
				texture.image = images;
	
				var loader = new XHRLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );
	
				function loadTexture( i ) {
	
					loader.load( url[ i ], function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};
	
						loaded += 1;
	
						if ( loaded === 6 ) {
	
							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;
	
							texture.format = texDatas.format;
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, onProgress, onError );
	
				}
	
				if ( Array.isArray( url ) ) {
	
					var loaded = 0;
	
					for ( var i = 0, il = url.length; i < il; ++ i ) {
	
						loadTexture( i );
	
					}
	
				} else {
	
					// compressed cubemap texture stored in a single DDS file
	
					loader.load( url, function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						if ( texDatas.isCubemap ) {
	
							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
							for ( var f = 0; f < faces; f ++ ) {
	
								images[ f ] = { mipmaps : [] };
	
								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;
	
								}
	
							}
	
						} else {
	
							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;
	
						}
	
						if ( texDatas.mipmapCount === 1 ) {
	
							texture.minFilter = LinearFilter;
	
						}
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}, onProgress, onError );
	
				}
	
				return texture;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */
	
		var DataTextureLoader = BinaryTextureLoader;
		function BinaryTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( BinaryTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texture = new DataTexture();
	
				var loader = new XHRLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
	
				loader.load( url, function ( buffer ) {
	
					var texData = scope._parser( buffer );
	
					if ( ! texData ) return;
	
					if ( undefined !== texData.image ) {
	
						texture.image = texData.image;
	
					} else if ( undefined !== texData.data ) {
	
						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;
	
					}
	
					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
	
					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
	
					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
					if ( undefined !== texData.format ) {
	
						texture.format = texData.format;
	
					}
					if ( undefined !== texData.type ) {
	
						texture.type = texData.type;
	
					}
	
					if ( undefined !== texData.mipmaps ) {
	
						texture.mipmaps = texData.mipmaps;
	
					}
	
					if ( 1 === texData.mipmapCount ) {
	
						texture.minFilter = LinearFilter;
	
					}
	
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture, texData );
	
				}, onProgress, onError );
	
	
				return texture;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ImageLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( ImageLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
				image.onload = function () {
	
					image.onload = null;
	
					URL.revokeObjectURL( image.src );
	
					if ( onLoad ) onLoad( image );
	
					scope.manager.itemEnd( url );
	
				};
				image.onerror = onError;
	
				if ( url.indexOf( 'data:' ) === 0 ) {
	
					image.src = url;
	
				} else {
	
					var loader = new XHRLoader();
					loader.setPath( this.path );
					loader.setResponseType( 'blob' );
					loader.setWithCredentials( this.withCredentials );
					loader.load( url, function ( blob ) {
	
						image.src = URL.createObjectURL( blob );
	
					}, onProgress, onError );
	
				}
	
				scope.manager.itemStart( url );
	
				return image;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setWithCredentials: function ( value ) {
	
				this.withCredentials = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( CubeTextureLoader.prototype, {
	
			load: function ( urls, onLoad, onProgress, onError ) {
	
				var texture = new CubeTexture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
	
				var loaded = 0;
	
				function loadTexture( i ) {
	
					loader.load( urls[ i ], function ( image ) {
	
						texture.images[ i ] = image;
	
						loaded ++;
	
						if ( loaded === 6 ) {
	
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, undefined, onError );
	
				}
	
				for ( var i = 0; i < urls.length; ++ i ) {
	
					loadTexture( i );
	
				}
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function TextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( TextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var texture = new Texture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setWithCredentials( this.withCredentials );
				loader.setPath( this.path );
				loader.load( url, function ( image ) {
	
					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
	
					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.image = image;
					texture.needsUpdate = true;
	
					if ( onLoad !== undefined ) {
	
						onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setWithCredentials: function ( value ) {
	
				this.withCredentials = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
	
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Light( color, intensity ) {
	
			Object3D.call( this );
	
			this.type = 'Light';
	
			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;
	
			this.receiveShadow = undefined;
	
		}
	
		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Light,
	
			isLight: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.color.copy( source.color );
				this.intensity = source.intensity;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;
	
				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
	
				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function HemisphereLight( skyColor, groundColor, intensity ) {
	
			Light.call( this, skyColor, intensity );
	
			this.type = 'HemisphereLight';
	
			this.castShadow = undefined;
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.groundColor = new Color( groundColor );
	
		}
	
		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: HemisphereLight,
	
			isHemisphereLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.groundColor.copy( source.groundColor );
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LightShadow( camera ) {
	
			this.camera = camera;
	
			this.bias = 0;
			this.radius = 1;
	
			this.mapSize = new Vector2( 512, 512 );
	
			this.map = null;
			this.matrix = new Matrix4();
	
		}
	
		Object.assign( LightShadow.prototype, {
	
			copy: function ( source ) {
	
				this.camera = source.camera.clone();
	
				this.bias = source.bias;
				this.radius = source.radius;
	
				this.mapSize.copy( source.mapSize );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			toJSON: function () {
	
				var object = {};
	
				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
	
				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;
	
				return object;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SpotLightShadow() {
	
			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
		}
	
		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: SpotLightShadow,
	
			isSpotLightShadow: true,
	
			update: function ( light ) {
	
				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || 500;
	
				var camera = this.camera;
	
				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
	
					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'SpotLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new SpotLightShadow();
	
		}
	
		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: SpotLight,
	
			isSpotLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
	
		function PointLight( color, intensity, distance, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'PointLight';
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;
	
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
		}
	
		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: PointLight,
	
			isPointLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.decay = source.decay;
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectionalLightShadow( light ) {
	
			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
		}
	
		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: DirectionalLightShadow
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DirectionalLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'DirectionalLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			this.shadow = new DirectionalLightShadow();
	
		}
	
		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: DirectionalLight,
	
			isDirectionalLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AmbientLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'AmbientLight';
	
			this.castShadow = undefined;
	
		}
	
		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: AmbientLight,
	
			isAmbientLight: true,
	
		} );
	
		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		var AnimationUtils = {
	
			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function( array, from, to ) {
	
				if ( AnimationUtils.isTypedArray( array ) ) {
	
					return new array.constructor( array.subarray( from, to ) );
	
				}
	
				return array.slice( from, to );
	
			},
	
			// converts an array to a specific type
			convertArray: function( array, type, forceClone ) {
	
				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;
	
				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
					return new type( array ); // create typed array
	
				}
	
				return Array.prototype.slice.call( array ); // create Array
	
			},
	
			isTypedArray: function( object ) {
	
				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );
	
			},
	
			// returns an array by which times and values can be sorted
			getKeyframeOrder: function( times ) {
	
				function compareTime( i, j ) {
	
					return times[ i ] - times[ j ];
	
				}
	
				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
				result.sort( compareTime );
	
				return result;
	
			},
	
			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function( values, stride, order ) {
	
				var nValues = values.length;
				var result = new values.constructor( nValues );
	
				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
					var srcOffset = order[ i ] * stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						result[ dstOffset ++ ] = values[ srcOffset + j ];
	
					}
	
				}
	
				return result;
	
			},
	
			// function for parsing AOS keyframe formats
			flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {
	
				var i = 1, key = jsonKeys[ 0 ];
	
				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
					key = jsonKeys[ i ++ ];
	
				}
	
				if ( key === undefined ) return; // no data
	
				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data
	
				if ( Array.isArray( value ) ) {
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push.apply( values, value ); // push all elements
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else if ( value.toArray !== undefined ) {
					// ...assume THREE.Math-ish
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							value.toArray( values, values.length );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else {
					// otherwise push as-is
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push( value );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				}
	
			}
	
		};
	
		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */
	
		function Interpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
	
			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
	
		}
	
		Interpolant.prototype = {
	
			constructor: Interpolant,
	
			evaluate: function( t ) {
	
				var pp = this.parameterPositions,
					i1 = this._cachedIndex,
	
					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];
	
				validate_interval: {
	
					seek: {
	
						var right;
	
						linear_scan: {
		//- See http://jsperf.com/comparison-to-undefined/3
		//- slower code:
		//-
		//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {
	
								for ( var giveUpAt = i1 + 2; ;) {
	
									if ( t1 === undefined ) {
	
										if ( t < t0 ) break forward_scan;
	
										// after end
	
										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t0 = t1;
									t1 = pp[ ++ i1 ];
	
									if ( t < t1 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;
	
							}
	
		//- slower code:
		//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {
	
								// looping?
	
								var t1global = pp[ 1 ];
	
								if ( t < t1global ) {
	
									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;
	
								}
	
								// linear reverse scan
	
								for ( var giveUpAt = i1 - 2; ;) {
	
									if ( t0 === undefined ) {
	
										// before start
	
										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t1 = t0;
									t0 = pp[ -- i1 - 1 ];
	
									if ( t >= t0 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;
	
							}
	
							// the interval is valid
	
							break validate_interval;
	
						} // linear scan
	
						// binary search
	
						while ( i1 < right ) {
	
							var mid = ( i1 + right ) >>> 1;
	
							if ( t < pp[ mid ] ) {
	
								right = mid;
	
							} else {
	
								i1 = mid + 1;
	
							}
	
						}
	
						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];
	
						// check boundary cases, again
	
						if ( t0 === undefined ) {
	
							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );
	
						}
	
						if ( t1 === undefined ) {
	
							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );
	
						}
	
					} // seek
	
					this._cachedIndex = i1;
	
					this.intervalChanged_( i1, t0, t1 );
	
				} // validate_interval
	
				return this.interpolate_( i1, t0, t, t1 );
	
			},
	
			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.
	
			// --- Protected interface
	
			DefaultSettings_: {},
	
			getSettings_: function() {
	
				return this.settings || this.DefaultSettings_;
	
			},
	
			copySampleValue_: function( index ) {
	
				// copies a sample value to the result buffer
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] = values[ offset + i ];
	
				}
	
				return result;
	
			},
	
			// Template methods for derived classes:
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				// empty
	
			}
	
		};
	
		Object.assign( Interpolant.prototype, {
	
			beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_,
	
			afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_
	
		} );
	
		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */
	
		function CubicInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
	
		}
	
		CubicInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: CubicInterpolant,
	
			DefaultSettings_: {
	
				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,
	
					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];
	
				if ( tPrev === undefined ) {
	
					switch ( this.getSettings_().endingStart ) {
	
						case ZeroSlopeEnding:
	
							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;
	
					}
	
				}
	
				if ( tNext === undefined ) {
	
					switch ( this.getSettings_().endingEnd ) {
	
						case ZeroSlopeEnding:
	
							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;
	
					}
	
				}
	
				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;
	
				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;
	
			},
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,
	
					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;
	
				// evaluate polynomials
	
				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;
	
				// combine data linearly
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 */
	
		function LinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		LinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: LinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset1 = i1 * stride,
					offset0 = offset1 - stride,
	
					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */
	
		function DiscreteInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		DiscreteInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: DiscreteInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				return this.copySampleValue_( i1 - 1 );
	
			}
	
		} );
	
		var KeyframeTrackPrototype;
	
		KeyframeTrackPrototype = {
	
			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodDiscrete: function( result ) {
	
				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodLinear: function( result ) {
	
				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: function( result ) {
	
				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			setInterpolation: function( interpolation ) {
	
				var factoryMethod;
	
				switch ( interpolation ) {
	
					case InterpolateDiscrete:
	
						factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
						break;
	
					case InterpolateLinear:
	
						factoryMethod = this.InterpolantFactoryMethodLinear;
	
						break;
	
					case InterpolateSmooth:
	
						factoryMethod = this.InterpolantFactoryMethodSmooth;
	
						break;
	
				}
	
				if ( factoryMethod === undefined ) {
	
					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;
	
					if ( this.createInterpolant === undefined ) {
	
						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {
	
							this.setInterpolation( this.DefaultInterpolation );
	
						} else {
	
							throw new Error( message ); // fatal, in this case
	
						}
	
					}
	
					console.warn( message );
					return;
	
				}
	
				this.createInterpolant = factoryMethod;
	
			},
	
			getInterpolation: function() {
	
				switch ( this.createInterpolant ) {
	
					case this.InterpolantFactoryMethodDiscrete:
	
						return InterpolateDiscrete;
	
					case this.InterpolantFactoryMethodLinear:
	
						return InterpolateLinear;
	
					case this.InterpolantFactoryMethodSmooth:
	
						return InterpolateSmooth;
	
				}
	
			},
	
			getValueSize: function() {
	
				return this.values.length / this.times.length;
	
			},
	
			// move all keyframes either forwards or backwards in time
			shift: function( timeOffset ) {
	
				if( timeOffset !== 0.0 ) {
	
					var times = this.times;
	
					for( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] += timeOffset;
	
					}
	
				}
	
				return this;
	
			},
	
			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function( timeScale ) {
	
				if( timeScale !== 1.0 ) {
	
					var times = this.times;
	
					for( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] *= timeScale;
	
					}
	
				}
	
				return this;
	
			},
	
			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function( startTime, endTime ) {
	
				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;
	
				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== -1 && times[ to ] > endTime ) -- to;
	
				++ to; // inclusive -> exclusive bound
	
				if( from !== 0 || to !== nKeys ) {
	
					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;
	
					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );
	
				}
	
				return this;
	
			},
	
			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function() {
	
				var valid = true;
	
				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
					console.error( "invalid value size in track", this );
					valid = false;
	
				}
	
				var times = this.times,
					values = this.values,
	
					nKeys = times.length;
	
				if( nKeys === 0 ) {
	
					console.error( "track is empty", this );
					valid = false;
	
				}
	
				var prevTime = null;
	
				for( var i = 0; i !== nKeys; i ++ ) {
	
					var currTime = times[ i ];
	
					if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
						console.error( "time is not a valid number", this, i, currTime );
						valid = false;
						break;
	
					}
	
					if( prevTime !== null && prevTime > currTime ) {
	
						console.error( "out of order keys", this, i, currTime, prevTime );
						valid = false;
						break;
	
					}
	
					prevTime = currTime;
	
				}
	
				if ( values !== undefined ) {
	
					if ( AnimationUtils.isTypedArray( values ) ) {
	
						for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
							var value = values[ i ];
	
							if ( isNaN( value ) ) {
	
								console.error( "value is not a valid number", this, i, value );
								valid = false;
								break;
	
							}
	
						}
	
					}
	
				}
	
				return valid;
	
			},
	
			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function() {
	
				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),
	
					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
	
					writeIndex = 1,
					lastIndex = times.length - 1;
	
				for( var i = 1; i < lastIndex; ++ i ) {
	
					var keep = false;
	
					var time = times[ i ];
					var timeNext = times[ i + 1 ];
	
					// remove adjacent keyframes scheduled at the same time
	
					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
						if ( ! smoothInterpolation ) {
	
							// remove unnecessary keyframes same as their neighbors
	
							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;
	
							for ( var j = 0; j !== stride; ++ j ) {
	
								var value = values[ offset + j ];
	
								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {
	
									keep = true;
									break;
	
								}
	
							}
	
						} else keep = true;
	
					}
	
					// in-place compaction
	
					if ( keep ) {
	
						if ( i !== writeIndex ) {
	
							times[ writeIndex ] = times[ i ];
	
							var readOffset = i * stride,
								writeOffset = writeIndex * stride;
	
							for ( var j = 0; j !== stride; ++ j )
	
								values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
						++ writeIndex;
	
					}
	
				}
	
				// flush last keyframe (compaction looks ahead)
	
				if ( lastIndex > 0 ) {
	
					times[ writeIndex ] = times[ lastIndex ];
	
					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )
	
						values[ writeOffset + j ] = values[ readOffset + j ];
	
					++ writeIndex;
	
				}
	
				if ( writeIndex !== times.length ) {
	
					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
				}
	
				return this;
	
			}
	
		};
	
		function KeyframeTrackConstructor( name, times, values, interpolation ) {
	
			if( name === undefined ) throw new Error( "track name is undefined" );
	
			if( times === undefined || times.length === 0 ) {
	
				throw new Error( "no keyframes in track named " + name );
	
			}
	
			this.name = name;
	
			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
	
			this.setInterpolation( interpolation || this.DefaultInterpolation );
	
			this.validate();
			this.optimize();
	
		}
	
		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function VectorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: VectorKeyframeTrack,
	
			ValueTypeName: 'vector'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */
	
		function QuaternionLinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		QuaternionLinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: QuaternionLinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset = i1 * stride,
	
					alpha = ( t - t0 ) / ( t1 - t0 );
	
				for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function QuaternionKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: QuaternionKeyframeTrack,
	
			ValueTypeName: 'quaternion',
	
			// ValueBufferType is inherited
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodLinear: function( result ) {
	
				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
		} );
	
		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function NumberKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: NumberKeyframeTrack,
	
			ValueTypeName: 'number',
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function StringKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: StringKeyframeTrack,
	
			ValueTypeName: 'string',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
	
			InterpolantFactoryMethodSmooth: undefined
	
		} );
	
		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function BooleanKeyframeTrack( name, times, values ) {
	
			KeyframeTrackConstructor.call( this, name, times, values );
	
		}
	
		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: BooleanKeyframeTrack,
	
			ValueTypeName: 'bool',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined
	
			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".
	
		} );
	
		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function ColorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: ColorKeyframeTrack,
	
			ValueTypeName: 'color'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
	
			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.
	
		} );
	
		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function KeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.apply( this, arguments );
	
		}
	
		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;
	
		// Static methods:
	
		Object.assign( KeyframeTrack, {
	
			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):
	
			parse: function( json ) {
	
				if( json.type === undefined ) {
	
					throw new Error( "track type undefined, can not parse" );
	
				}
	
				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
				if ( json.times === undefined ) {
	
					var times = [], values = [];
	
					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
					json.times = times;
					json.values = values;
	
				}
	
				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {
	
					return trackType.parse( json );
	
				} else {
	
					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );
	
				}
	
			},
	
			toJSON: function( track ) {
	
				var trackType = track.constructor;
	
				var json;
	
				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {
	
					json = trackType.toJSON( track );
	
				} else {
	
					// by default, we assume the data can be serialized as-is
					json = {
	
						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )
	
					};
	
					var interpolation = track.getInterpolation();
	
					if ( interpolation !== track.DefaultInterpolation ) {
	
						json.interpolation = interpolation;
	
					}
	
				}
	
				json.type = track.ValueTypeName; // mandatory
	
				return json;
	
			},
	
			_getTrackTypeForValueTypeName: function( typeName ) {
	
				switch( typeName.toLowerCase() ) {
	
					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":
	
						return NumberKeyframeTrack;
	
					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":
	
						return VectorKeyframeTrack;
	
					case "color":
	
						return ColorKeyframeTrack;
	
					case "quaternion":
	
						return QuaternionKeyframeTrack;
	
					case "bool":
					case "boolean":
	
						return BooleanKeyframeTrack;
	
					case "string":
	
						return StringKeyframeTrack;
	
				}
	
				throw new Error( "Unsupported typeName: " + typeName );
	
			}
	
		} );
	
		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		function AnimationClip( name, duration, tracks ) {
	
			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : -1;
	
			this.uuid = _Math.generateUUID();
	
			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {
	
				this.resetDuration();
	
			}
	
			this.optimize();
	
		}
	
		AnimationClip.prototype = {
	
			constructor: AnimationClip,
	
			resetDuration: function() {
	
				var tracks = this.tracks,
					duration = 0;
	
				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
					var track = this.tracks[ i ];
	
					duration = Math.max(
							duration, track.times[ track.times.length - 1 ] );
	
				}
	
				this.duration = duration;
	
			},
	
			trim: function() {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].trim( 0, this.duration );
	
				}
	
				return this;
	
			},
	
			optimize: function() {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].optimize();
	
				}
	
				return this;
	
			}
	
		};
	
		// Static methods:
	
		Object.assign( AnimationClip, {
	
			parse: function( json ) {
	
				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );
	
				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
				}
	
				return new AnimationClip( json.name, json.duration, tracks );
	
			},
	
	
			toJSON: function( clip ) {
	
				var tracks = [],
					clipTracks = clip.tracks;
	
				var json = {
	
					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks
	
				};
	
				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
				}
	
				return json;
	
			},
	
	
			CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {
	
				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];
	
				for ( var i = 0; i < numMorphTargets; i ++ ) {
	
					var times = [];
					var values = [];
	
					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );
	
					values.push( 0, 1, 0 );
	
					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );
	
					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {
	
						times.push( numMorphTargets );
						values.push( values[ 0 ] );
	
					}
	
					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
				}
	
				return new AnimationClip( name, -1, tracks );
	
			},
	
			findByName: function( objectOrClipArray, name ) {
	
				var clipArray = objectOrClipArray;
	
				if ( ! Array.isArray( objectOrClipArray ) ) {
	
					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;
	
				}
	
				for ( var i = 0; i < clipArray.length; i ++ ) {
	
					if ( clipArray[ i ].name === name ) {
	
						return clipArray[ i ];
	
					}
				}
	
				return null;
	
			},
	
			CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {
	
				var animationToMorphTargets = {};
	
				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;
	
				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );
	
					if ( parts && parts.length > 1 ) {
	
						var name = parts[ 1 ];
	
						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {
	
							animationToMorphTargets[ name ] = animationMorphTargets = [];
	
						}
	
						animationMorphTargets.push( morphTarget );
	
					}
	
				}
	
				var clips = [];
	
				for ( var name in animationToMorphTargets ) {
	
					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
	
				}
	
				return clips;
	
			},
	
			// parse the animation.hierarchy format
			parseAnimation: function( animation, bones ) {
	
				if ( ! animation ) {
	
					console.error( "  no animation in JSONLoader data" );
					return null;
	
				}
	
				var addNonemptyTrack = function(
						trackType, trackName, animationKeys, propertyName, destTracks ) {
	
					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {
	
						var times = [];
						var values = [];
	
						AnimationUtils.flattenJSON(
								animationKeys, times, values, propertyName );
	
						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {
	
							destTracks.push( new trackType( trackName, times, values ) );
	
						}
	
					}
	
				};
	
				var tracks = [];
	
				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || -1;
				var fps = animation.fps || 30;
	
				var hierarchyTracks = animation.hierarchy || [];
	
				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
					var animationKeys = hierarchyTracks[ h ].keys;
	
					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;
	
					// process morph targets in a way exactly compatible
					// with AnimationHandler.init( animation )
					if ( animationKeys[0].morphTargets ) {
	
						// figure out all morph targets used in this track
						var morphTargetNames = {};
						for ( var k = 0; k < animationKeys.length; k ++ ) {
	
							if ( animationKeys[k].morphTargets ) {
	
								for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
									morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
								}
	
							}
	
						}
	
						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {
	
							var times = [];
							var values = [];
	
							for ( var m = 0;
									m !== animationKeys[k].morphTargets.length; ++ m ) {
	
								var animationKey = animationKeys[k];
	
								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
	
							}
	
							tracks.push( new NumberKeyframeTrack(
									'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
						}
	
						duration = morphTargetNames.length * ( fps || 1.0 );
	
					} else {
						// ...assume skeletal animation
	
						var boneName = '.bones[' + bones[ h ].name + ']';
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );
	
						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );
	
					}
	
				}
	
				if ( tracks.length === 0 ) {
	
					return null;
	
				}
	
				var clip = new AnimationClip( clipName, duration, tracks );
	
				return clip;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MaterialLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};
	
		}
	
		Object.assign( MaterialLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			setTextures: function ( value ) {
	
				this.textures = value;
	
			},
	
			parse: function ( json ) {
	
				var textures = this.textures;
	
				function getTexture( name ) {
	
					if ( textures[ name ] === undefined ) {
	
						console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
					}
	
					return textures[ name ];
	
				}
	
				var material = new Materials[ json.type ]();
	
				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
	
				// for PointsMaterial
	
				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
				// maps
	
				if ( json.map !== undefined ) material.map = getTexture( json.map );
	
				if ( json.alphaMap !== undefined ) {
	
					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;
	
				}
	
				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {
	
					var normalScale = json.normalScale;
	
					if ( Array.isArray( normalScale ) === false ) {
	
						// Blender exporter used to export a scalar. See #7459
	
						normalScale = [ normalScale, normalScale ];
	
					}
	
					material.normalScale = new Vector2().fromArray( normalScale );
	
				}
	
				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
	
				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
	
				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
	
				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
	
				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
				// MultiMaterial
	
				if ( json.materials !== undefined ) {
	
					for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
						material.materials.push( this.parse( json.materials[ i ] ) );
	
					}
	
				}
	
				return material;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometryLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( BufferGeometryLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				var geometry = new BufferGeometry();
	
				var index = json.data.index;
	
				var TYPED_ARRAYS = {
					'Int8Array': Int8Array,
					'Uint8Array': Uint8Array,
					'Uint8ClampedArray': Uint8ClampedArray,
					'Int16Array': Int16Array,
					'Uint16Array': Uint16Array,
					'Int32Array': Int32Array,
					'Uint32Array': Uint32Array,
					'Float32Array': Float32Array,
					'Float64Array': Float64Array
				};
	
				if ( index !== undefined ) {
	
					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
	
				}
	
				var attributes = json.data.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
	
				}
	
				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
				if ( groups !== undefined ) {
	
					for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
						var group = groups[ i ];
	
						geometry.addGroup( group.start, group.count, group.materialIndex );
	
					}
	
				}
	
				var boundingSphere = json.data.boundingSphere;
	
				if ( boundingSphere !== undefined ) {
	
					var center = new Vector3();
	
					if ( boundingSphere.center !== undefined ) {
	
						center.fromArray( boundingSphere.center );
	
					}
	
					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Loader() {
	
			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};
	
		}
	
		Loader.prototype = {
	
			constructor: Loader,
	
			crossOrigin: undefined,
	
			extractUrlBase: function ( url ) {
	
				var parts = url.split( '/' );
	
				if ( parts.length === 1 ) return './';
	
				parts.pop();
	
				return parts.join( '/' ) + '/';
	
			},
	
			initMaterials: function ( materials, texturePath, crossOrigin ) {
	
				var array = [];
	
				for ( var i = 0; i < materials.length; ++ i ) {
	
					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
				}
	
				return array;
	
			},
	
			createMaterial: ( function () {
	
				var color, textureLoader, materialLoader;
	
				return function createMaterial( m, texturePath, crossOrigin ) {
	
					if ( color === undefined ) color = new Color();
					if ( textureLoader === undefined ) textureLoader = new TextureLoader();
					if ( materialLoader === undefined ) materialLoader = new MaterialLoader();
	
					// convert from old material format
	
					var textures = {};
	
					function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );
	
						var texture;
	
						if ( loader !== null ) {
	
							texture = loader.load( fullPath );
	
						} else {
	
							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );
	
						}
	
						if ( repeat !== undefined ) {
	
							texture.repeat.fromArray( repeat );
	
							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
	
						}
	
						if ( offset !== undefined ) {
	
							texture.offset.fromArray( offset );
	
						}
	
						if ( wrap !== undefined ) {
	
							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
	
							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
	
						}
	
						if ( anisotropy !== undefined ) {
	
							texture.anisotropy = anisotropy;
	
						}
	
						var uuid = _Math.generateUUID();
	
						textures[ uuid ] = texture;
	
						return uuid;
	
					}
	
					//
	
					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};
	
					for ( var name in m ) {
	
						var value = m[ name ];
	
						switch ( name ) {
							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;
						}
	
					}
	
					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
					if ( json.opacity < 1 ) json.transparent = true;
	
					materialLoader.setTextures( textures );
	
					return materialLoader.parse( json );
	
				};
	
			} )()
	
		};
	
		Loader.Handlers = {
	
			handlers: [],
	
			add: function ( regex, loader ) {
	
				this.handlers.push( regex, loader );
	
			},
	
			get: function ( file ) {
	
				var handlers = this.handlers;
	
				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
					var regex = handlers[ i ];
					var loader  = handlers[ i + 1 ];
	
					if ( regex.test( file ) ) {
	
						return loader;
	
					}
	
				}
	
				return null;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function JSONLoader( manager ) {
	
			if ( typeof manager === 'boolean' ) {
	
				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;
	
			}
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			this.withCredentials = false;
	
		}
	
		Object.assign( JSONLoader.prototype, {
	
			load: function( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );
	
				var loader = new XHRLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {
	
					var json = JSON.parse( text );
					var metadata = json.metadata;
	
					if ( metadata !== undefined ) {
	
						var type = metadata.type;
	
						if ( type !== undefined ) {
	
							if ( type.toLowerCase() === 'object' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;
	
							}
	
							if ( type.toLowerCase() === 'scene' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;
	
							}
	
						}
	
					}
	
					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			parse: function ( json, texturePath ) {
	
				var geometry = new Geometry(),
				scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
				parseModel( scale );
	
				parseSkin();
				parseMorphing( scale );
				parseAnimations();
	
				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();
	
				function parseModel( scale ) {
	
					function isBitSet( value, position ) {
	
						return value & ( 1 << position );
	
					}
	
					var i, j, fi,
	
					offset, zLength,
	
				colorIndex, normalIndex, uvIndex, materialIndex,
	
					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,
	
				vertex, face, faceA, faceB, hex, normal,
	
					uvLayer, uv, u, v,
	
					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,
	
					nUvLayers = 0;
	
					if ( json.uvs !== undefined ) {
	
						// disregard empty arrays
	
						for ( i = 0; i < json.uvs.length; i ++ ) {
	
							if ( json.uvs[ i ].length ) nUvLayers ++;
	
						}
	
						for ( i = 0; i < nUvLayers; i ++ ) {
	
							geometry.faceVertexUvs[ i ] = [];
	
						}
	
					}
	
					offset = 0;
					zLength = vertices.length;
	
					while ( offset < zLength ) {
	
						vertex = new Vector3();
	
						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;
	
						geometry.vertices.push( vertex );
	
					}
	
					offset = 0;
					zLength = faces.length;
	
					while ( offset < zLength ) {
	
						type = faces[ offset ++ ];
	
	
						isQuad              = isBitSet( type, 0 );
						hasMaterial         = isBitSet( type, 1 );
						hasFaceVertexUv     = isBitSet( type, 3 );
						hasFaceNormal       = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor	     = isBitSet( type, 6 );
						hasFaceVertexColor  = isBitSet( type, 7 );
	
						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
						if ( isQuad ) {
	
							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];
	
							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];
	
							offset += 4;
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
									for ( j = 0; j < 4; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								faceB.normal.copy( faceA.normal );
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
	
									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								faceA.color.setHex( hex );
								faceB.color.setHex( hex );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];
	
									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );
	
								}
	
							}
	
							geometry.faces.push( faceA );
							geometry.faces.push( faceB );
	
						} else {
	
							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
	
									for ( j = 0; j < 3; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
									face.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );
	
								}
	
							}
	
							geometry.faces.push( face );
	
						}
	
					}
	
				}
	
				function parseSkin() {
	
					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
					if ( json.skinWeights ) {
	
						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
							var x =                               json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
							geometry.skinWeights.push( new Vector4( x, y, z, w ) );
	
						}
	
					}
	
					if ( json.skinIndices ) {
	
						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
							var a =                               json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
							geometry.skinIndices.push( new Vector4( a, b, c, d ) );
	
						}
	
					}
	
					geometry.bones = json.bones;
	
					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
					}
	
				}
	
				function parseMorphing( scale ) {
	
					if ( json.morphTargets !== undefined ) {
	
						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];
	
							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;
	
							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;
	
								dstVertices.push( vertex );
	
							}
	
						}
	
					}
	
					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;
	
						for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
							faces[ i ].color.fromArray( morphColors, i * 3 );
	
						}
	
					}
	
				}
	
				function parseAnimations() {
	
					var outputAnimations = [];
	
					// parse old style Bone/Hierarchy animations
					var animations = [];
	
					if ( json.animation !== undefined ) {
	
						animations.push( json.animation );
	
					}
	
					if ( json.animations !== undefined ) {
	
						if ( json.animations.length ) {
	
							animations = animations.concat( json.animations );
	
						} else {
	
							animations.push( json.animations );
	
						}
	
					}
	
					for ( var i = 0; i < animations.length; i ++ ) {
	
						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );
	
					}
	
					// parse implicit morph animations
					if ( geometry.morphTargets ) {
	
						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );
	
					}
	
					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
				}
	
				if ( json.materials === undefined || json.materials.length === 0 ) {
	
					return { geometry: geometry };
	
				} else {
	
					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
					return { geometry: geometry, materials: materials };
	
				}
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ObjectLoader ( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';
	
		}
	
		Object.assign( ObjectLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( this.texturePath === '' ) {
	
					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
				}
	
				var scope = this;
	
				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					scope.parse( JSON.parse( text ), onLoad );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
	
			},
	
			parse: function ( json, onLoad ) {
	
				var geometries = this.parseGeometries( json.geometries );
	
				var images = this.parseImages( json.images, function () {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				} );
	
				var textures  = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );
	
				var object = this.parseObject( json.object, geometries, materials );
	
				if ( json.animations ) {
	
					object.animations = this.parseAnimations( json.animations );
	
				}
	
				if ( json.images === undefined || json.images.length === 0 ) {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				}
	
				return object;
	
			},
	
			parseGeometries: function ( json ) {
	
				var geometries = {};
	
				if ( json !== undefined ) {
	
					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var geometry;
						var data = json[ i ];
	
						switch ( data.type ) {
	
							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);
	
								break;
	
							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);
	
								break;
	
							case 'CircleGeometry':
							case 'CircleBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'ConeGeometry':
							case 'ConeBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'SphereGeometry':
							case 'SphereBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);
	
								break;
	
							case 'RingGeometry':
							case 'RingBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'TorusGeometry':
							case 'TorusBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);
	
								break;
	
							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);
	
								break;
	
							case 'LatheGeometry':
							case 'LatheBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);
	
								break;
	
							case 'BufferGeometry':
	
								geometry = bufferGeometryLoader.parse( data );
	
								break;
	
							case 'Geometry':
	
								geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
								break;
	
							default:
	
								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
								continue;
	
						}
	
						geometry.uuid = data.uuid;
	
						if ( data.name !== undefined ) geometry.name = data.name;
	
						geometries[ data.uuid ] = geometry;
	
					}
	
				}
	
				return geometries;
	
			},
	
			parseMaterials: function ( json, textures ) {
	
				var materials = {};
	
				if ( json !== undefined ) {
	
					var loader = new MaterialLoader();
					loader.setTextures( textures );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var material = loader.parse( json[ i ] );
						materials[ material.uuid ] = material;
	
					}
	
				}
	
				return materials;
	
			},
	
			parseAnimations: function ( json ) {
	
				var animations = [];
	
				for ( var i = 0; i < json.length; i ++ ) {
	
					var clip = AnimationClip.parse( json[ i ] );
	
					animations.push( clip );
	
				}
	
				return animations;
	
			},
	
			parseImages: function ( json, onLoad ) {
	
				var scope = this;
				var images = {};
	
				function loadImage( url ) {
	
					scope.manager.itemStart( url );
	
					return loader.load( url, function () {
	
						scope.manager.itemEnd( url );
	
					}, undefined, function () {
	
						scope.manager.itemError( url );
	
					} );
	
				}
	
				if ( json !== undefined && json.length > 0 ) {
	
					var manager = new LoadingManager( onLoad );
	
					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
						images[ image.uuid ] = loadImage( path );
	
					}
	
				}
	
				return images;
	
			},
	
			parseTextures: function ( json, images ) {
	
				function parseConstant( value, type ) {
	
					if ( typeof( value ) === 'number' ) return value;
	
					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
					return type[ value ];
	
				}
	
				var textures = {};
	
				if ( json !== undefined ) {
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var data = json[ i ];
	
						if ( data.image === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
						}
	
						if ( images[ data.image ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
						}
	
						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;
	
						texture.uuid = data.uuid;
	
						if ( data.name !== undefined ) texture.name = data.name;
	
						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );
	
						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {
	
							texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );
	
						}
	
						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
	
						if ( data.flipY !== undefined ) texture.flipY = data.flipY;
	
						textures[ data.uuid ] = texture;
	
					}
	
				}
	
				return textures;
	
			},
	
			parseObject: function () {
	
				var matrix = new Matrix4();
	
				return function parseObject( data, geometries, materials ) {
	
					var object;
	
					function getGeometry( name ) {
	
						if ( geometries[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
						}
	
						return geometries[ name ];
	
					}
	
					function getMaterial( name ) {
	
						if ( name === undefined ) return undefined;
	
						if ( materials[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
						}
	
						return materials[ name ];
	
					}
	
					switch ( data.type ) {
	
						case 'Scene':
	
							object = new Scene();
	
							if ( data.background !== undefined ) {
	
								if ( Number.isInteger( data.background ) ) {
	
									object.background = new Color( data.background );
	
								}
	
							}
	
							if ( data.fog !== undefined ) {
	
								if ( data.fog.type === 'Fog' ) {
	
									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
	
								} else if ( data.fog.type === 'FogExp2' ) {
	
									object.fog = new FogExp2( data.fog.color, data.fog.density );
	
								}
	
							}
	
							break;
	
						case 'PerspectiveCamera':
	
							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
							break;
	
						case 'OrthographicCamera':
	
							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
							break;
	
						case 'AmbientLight':
	
							object = new AmbientLight( data.color, data.intensity );
	
							break;
	
						case 'DirectionalLight':
	
							object = new DirectionalLight( data.color, data.intensity );
	
							break;
	
						case 'PointLight':
	
							object = new PointLight( data.color, data.intensity, data.distance, data.decay );
	
							break;
	
						case 'SpotLight':
	
							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
	
							break;
	
						case 'HemisphereLight':
	
							object = new HemisphereLight( data.color, data.groundColor, data.intensity );
	
							break;
	
						case 'Mesh':
	
							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );
	
							if ( geometry.bones && geometry.bones.length > 0 ) {
	
								object = new SkinnedMesh( geometry, material );
	
							} else {
	
								object = new Mesh( geometry, material );
	
							}
	
							break;
	
						case 'LOD':
	
							object = new LOD();
	
							break;
	
						case 'Line':
	
							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
							break;
	
						case 'LineSegments':
	
							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'PointCloud':
						case 'Points':
	
							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'Sprite':
	
							object = new Sprite( getMaterial( data.material ) );
	
							break;
	
						case 'Group':
	
							object = new Group();
	
							break;
	
						default:
	
							object = new Object3D();
	
					}
	
					object.uuid = data.uuid;
	
					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {
	
						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );
	
					} else {
	
						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
					}
	
					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
					if ( data.shadow ) {
	
						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
	
					}
	
					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;
	
					if ( data.children !== undefined ) {
	
						for ( var child in data.children ) {
	
							object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
						}
	
					}
	
					if ( data.type === 'LOD' ) {
	
						var levels = data.levels;
	
						for ( var l = 0; l < levels.length; l ++ ) {
	
							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );
	
							if ( child !== undefined ) {
	
								object.addLevel( child, level.distance );
	
							}
	
						}
	
					}
	
					return object;
	
				};
	
			}()
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of Curve methods
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following classes subclasses THREE.Curve:
		 *
		 * -- 2d classes --
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.CubicBezierCurve
		 * THREE.SplineCurve
		 * THREE.ArcCurve
		 * THREE.EllipseCurve
		 *
		 * -- 3d classes --
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.SplineCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath
		 *
		 **/
	
		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/
	
		function Curve() {}
	
		Curve.prototype = {
	
			constructor: Curve,
	
			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]
	
			getPoint: function ( t ) {
	
				console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
				return null;
	
			},
	
			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]
	
			getPointAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getPoint( t );
	
			},
	
			// Get sequence of points using getPoint( t )
	
			getPoints: function ( divisions ) {
	
				if ( ! divisions ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPoint( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get sequence of points using getPointAt( u )
	
			getSpacedPoints: function ( divisions ) {
	
				if ( ! divisions ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPointAt( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get total curve arc length
	
			getLength: function () {
	
				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];
	
			},
	
			// Get list of cumulative segment lengths
	
			getLengths: function ( divisions ) {
	
				if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
				if ( this.cacheArcLengths
					&& ( this.cacheArcLengths.length === divisions + 1 )
					&& ! this.needsUpdate ) {
	
					//console.log( "cached", this.cacheArcLengths );
					return this.cacheArcLengths;
	
				}
	
				this.needsUpdate = false;
	
				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;
	
				cache.push( 0 );
	
				for ( p = 1; p <= divisions; p ++ ) {
	
					current = this.getPoint ( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;
	
				}
	
				this.cacheArcLengths = cache;
	
				return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
			},
	
			updateArcLengths: function() {
	
				this.needsUpdate = true;
				this.getLengths();
	
			},
	
			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
			getUtoTmapping: function ( u, distance ) {
	
				var arcLengths = this.getLengths();
	
				var i = 0, il = arcLengths.length;
	
				var targetArcLength; // The targeted u distance value to get
	
				if ( distance ) {
	
					targetArcLength = distance;
	
				} else {
	
					targetArcLength = u * arcLengths[ il - 1 ];
	
				}
	
				//var time = Date.now();
	
				// binary search for the index with largest value smaller than target u distance
	
				var low = 0, high = il - 1, comparison;
	
				while ( low <= high ) {
	
					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
					comparison = arcLengths[ i ] - targetArcLength;
	
					if ( comparison < 0 ) {
	
						low = i + 1;
	
					} else if ( comparison > 0 ) {
	
						high = i - 1;
	
					} else {
	
						high = i;
						break;
	
						// DONE
	
					}
	
				}
	
				i = high;
	
				//console.log('b' , i, low, high, Date.now()- time);
	
				if ( arcLengths[ i ] === targetArcLength ) {
	
					var t = i / ( il - 1 );
					return t;
	
				}
	
				// we could get finer grain at lengths, or use simple interpolation between two points
	
				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];
	
				var segmentLength = lengthAfter - lengthBefore;
	
				// determine where we are between the 'before' and 'after' points
	
				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
				// add that fractional amount to t
	
				var t = ( i + segmentFraction ) / ( il - 1 );
	
				return t;
	
			},
	
			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation
	
			getTangent: function( t ) {
	
				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;
	
				// Capping in case of danger
	
				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;
	
				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );
	
				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();
	
			},
	
			getTangentAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getTangent( t );
	
			},
	
			computeFrenetFrames: function ( segments, closed ) {
	
				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	
				var normal = new Vector3();
	
				var tangents = [];
				var normals = [];
				var binormals = [];
	
				var vec = new Vector3();
				var mat = new Matrix4();
	
				var i, u, theta;
	
				// compute the tangent vectors for each segment on the curve
	
				for ( i = 0; i <= segments; i ++ ) {
	
					u = i / segments;
	
					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();
	
				}
	
				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component
	
				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );
	
				if ( tx <= min ) {
	
					min = tx;
					normal.set( 1, 0, 0 );
	
				}
	
				if ( ty <= min ) {
	
					min = ty;
					normal.set( 0, 1, 0 );
	
				}
	
				if ( tz <= min ) {
	
					normal.set( 0, 0, 1 );
	
				}
	
				vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
	
				// compute the slowly-varying normal and binormal vectors for each segment on the curve
	
				for ( i = 1; i <= segments; i ++ ) {
	
					normals[ i ] = normals[ i - 1 ].clone();
	
					binormals[ i ] = binormals[ i - 1 ].clone();
	
					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
					if ( vec.length() > Number.EPSILON ) {
	
						vec.normalize();
	
						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
					}
	
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
				}
	
				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
				if ( closed === true ) {
	
					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;
	
					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
	
						theta = - theta;
	
					}
	
					for ( i = 1; i <= segments; i ++ ) {
	
						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
					}
	
				}
	
				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};
	
			}
	
		};
	
		// TODO: Transformation for Curves?
	
		/**************************************************************
		 *	3D Curves
		 **************************************************************/
	
		// A Factory method for creating new curve subclasses
	
		Curve.create = function ( constructor, getPointFunc ) {
	
			constructor.prototype = Object.create( Curve.prototype );
			constructor.prototype.constructor = constructor;
			constructor.prototype.getPoint = getPointFunc;
	
			return constructor;
	
		};
	
		/**************************************************************
		 *	Line
		 **************************************************************/
	
		function LineCurve( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;
	
		LineCurve.prototype.isLineCurve = true;
	
		LineCurve.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
	
			return point;
	
		};
	
		// Line curve is linear, so we can overwrite default getPointAt
	
		LineCurve.prototype.getPointAt = function ( u ) {
	
			return this.getPoint( u );
	
		};
	
		LineCurve.prototype.getTangent = function( t ) {
	
			var tangent = this.v2.clone().sub( this.v1 );
	
			return tangent.normalize();
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/
	
		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/
	
		function CurvePath() {
	
			this.curves = [];
	
			this.autoClose = false; // Automatically closes the path
	
		}
	
		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
	
			constructor: CurvePath,
	
			add: function ( curve ) {
	
				this.curves.push( curve );
	
			},
	
			closePath: function () {
	
				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
				if ( ! startPoint.equals( endPoint ) ) {
	
					this.curves.push( new LineCurve( endPoint, startPoint ) );
	
				}
	
			},
	
			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:
	
			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')
	
			getPoint: function ( t ) {
	
				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;
	
				// To think about boundaries points.
	
				while ( i < curveLengths.length ) {
	
					if ( curveLengths[ i ] >= d ) {
	
						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];
	
						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	
						return curve.getPointAt( u );
	
					}
	
					i ++;
	
				}
	
				return null;
	
				// loop where sum != 0, sum > d , sum+1 <d
	
			},
	
			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength
	
			getLength: function () {
	
				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];
	
			},
	
			// cacheLengths must be recalculated.
			updateArcLengths: function () {
	
				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getLengths();
	
			},
	
			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.
	
			getCurveLengths: function () {
	
				// We use cache values if curves and cache array are same length
	
				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
					return this.cacheLengths;
	
				}
	
				// Get length of sub-curve
				// Push sums into cached array
	
				var lengths = [], sums = 0;
	
				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
					sums += this.curves[ i ].getLength();
					lengths.push( sums );
	
				}
	
				this.cacheLengths = lengths;
	
				return lengths;
	
			},
	
			getSpacedPoints: function ( divisions ) {
	
				if ( ! divisions ) divisions = 40;
	
				var points = [];
	
				for ( var i = 0; i <= divisions; i ++ ) {
	
					points.push( this.getPoint( i / divisions ) );
	
				}
	
				if ( this.autoClose ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			getPoints: function ( divisions ) {
	
				divisions = divisions || 12;
	
				var points = [], last;
	
				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
	
					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;
	
					var pts = curve.getPoints( resolution );
	
					for ( var j = 0; j < pts.length; j++ ) {
	
						var point = pts[ j ];
	
						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
	
						points.push( point );
						last = point;
	
					}
	
				}
	
				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/
	
			/// Generate geometry from path points (for Line or Points objects)
	
			createPointsGeometry: function ( divisions ) {
	
				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			// Generate geometry from equidistant sampling along the path
	
			createSpacedPointsGeometry: function ( divisions ) {
	
				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			createGeometry: function ( points ) {
	
				var geometry = new Geometry();
	
				for ( var i = 0, l = points.length; i < l; i ++ ) {
	
					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		/**************************************************************
		 *	Ellipse curve
		 **************************************************************/
	
		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			this.aX = aX;
			this.aY = aY;
	
			this.xRadius = xRadius;
			this.yRadius = yRadius;
	
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
	
			this.aClockwise = aClockwise;
	
			this.aRotation = aRotation || 0;
	
		}
	
		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;
	
		EllipseCurve.prototype.isEllipseCurve = true;
	
		EllipseCurve.prototype.getPoint = function( t ) {
	
			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	
			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	
			if ( deltaAngle < Number.EPSILON ) {
	
				if ( samePoints ) {
	
					deltaAngle = 0;
	
				} else {
	
					deltaAngle = twoPi;
	
				}
	
			}
	
			if ( this.aClockwise === true && ! samePoints ) {
	
				if ( deltaAngle === twoPi ) {
	
					deltaAngle = - twoPi;
	
				} else {
	
					deltaAngle = deltaAngle - twoPi;
	
				}
	
			}
	
			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );
	
			if ( this.aRotation !== 0 ) {
	
				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );
	
				var tx = x - this.aX;
				var ty = y - this.aY;
	
				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
	
			}
	
			return new Vector2( x, y );
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		var CurveUtils = {
	
			tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
				return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
			},
	
			// Puay Bing, thanks for helping with this derivative!
	
			tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {
	
				return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
					3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
					6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
					3 * t * t * p3;
	
			},
	
			tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
				// To check if my formulas are correct
	
				var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
				var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
				var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
				var h11 = 3 * t * t - 2 * t;	// t3  t2
	
				return h00 + h10 + h01 + h11;
	
			},
	
			// Catmull-Rom
	
			interpolate: function( p0, p1, p2, p3, t ) {
	
				var v0 = ( p2 - p0 ) * 0.5;
				var v1 = ( p3 - p1 ) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;
				return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
			}
	
		};
	
		/**************************************************************
		 *	Spline curve
		 **************************************************************/
	
		function SplineCurve( points /* array of Vector2 */ ) {
	
			this.points = ( points === undefined ) ? [] : points;
	
		}
	
		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;
	
		SplineCurve.prototype.isSplineCurve = true;
	
		SplineCurve.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			var interpolate = CurveUtils.interpolate;
	
			return new Vector2(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight )
			);
	
		};
	
		/**************************************************************
		 *	Cubic Bezier curve
		 **************************************************************/
	
		function CubicBezierCurve( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	
		CubicBezierCurve.prototype.getPoint = function ( t ) {
	
			var b3 = ShapeUtils.b3;
	
			return new Vector2(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
			);
	
		};
	
		CubicBezierCurve.prototype.getTangent = function( t ) {
	
			var tangentCubicBezier = CurveUtils.tangentCubicBezier;
	
			return new Vector2(
				tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
			).normalize();
	
		};
	
		/**************************************************************
		 *	Quadratic Bezier curve
		 **************************************************************/
	
	
		function QuadraticBezierCurve( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	
	
		QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
			var b2 = ShapeUtils.b2;
	
			return new Vector2(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y )
			);
	
		};
	
	
		QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
			var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;
	
			return new Vector2(
				tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
				tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
			).normalize();
	
		};
	
		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {
	
			fromPoints: function ( vectors ) {
	
				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
				for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
					this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
				}
	
			},
	
			moveTo: function ( x, y ) {
	
				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
	
			},
	
			lineTo: function ( x, y ) {
	
				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );
	
				this.currentPoint.set( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			splineThru: function ( pts /*Array of Vector*/ ) {
	
				var npts = [ this.currentPoint.clone() ].concat( pts );
	
				var curve = new SplineCurve( npts );
				this.curves.push( curve );
	
				this.currentPoint.copy( pts[ pts.length - 1 ] );
	
			},
	
			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );
	
			},
	
			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
			},
	
			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
			},
	
			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
				if ( this.curves.length > 0 ) {
	
					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );
	
					if ( ! firstPoint.equals( this.currentPoint ) ) {
	
						this.lineTo( firstPoint.x, firstPoint.y );
	
					}
	
				}
	
				this.curves.push( curve );
	
				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/
	
		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.
	
		function Shape() {
	
			Path.apply( this, arguments );
	
			this.holes = [];
	
		}
	
		Shape.prototype = Object.assign( Object.create( PathPrototype ), {
	
			constructor: Shape,
	
			getPointsHoles: function ( divisions ) {
	
				var holesPts = [];
	
				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
					holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
				}
	
				return holesPts;
	
			},
	
			// Get points of shape and holes (keypoints based on segments parameter)
	
			extractAllPoints: function ( divisions ) {
	
				return {
	
					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )
	
				};
	
			},
	
			extractPoints: function ( divisions ) {
	
				return this.extractAllPoints( divisions );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 *
		 **/
	
		function Path( points ) {
	
			CurvePath.call( this );
			this.currentPoint = new Vector2();
	
			if ( points ) {
	
				this.fromPoints( points );
	
			}
	
		}
	
		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;
	
	
		// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		function ShapePath() {
			this.subPaths = [];
			this.currentPath = null;
		}
	
		ShapePath.prototype = {
			moveTo: function ( x, y ) {
				this.currentPath = new Path();
				this.subPaths.push(this.currentPath);
				this.currentPath.moveTo( x, y );
			},
			lineTo: function ( x, y ) {
				this.currentPath.lineTo( x, y );
			},
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
			},
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
			},
			splineThru: function ( pts ) {
				this.currentPath.splineThru( pts );
			},
	
			toShapes: function ( isCCW, noHoles ) {
	
				function toShapesNoHoles( inSubpaths ) {
	
					var shapes = [];
	
					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
						var tmpPath = inSubpaths[ i ];
	
						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;
	
						shapes.push( tmpShape );
	
					}
	
					return shapes;
	
				}
	
				function isPointInsidePolygon( inPt, inPolygon ) {
	
					var polyLen = inPolygon.length;
	
					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];
	
						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
						if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
							// not parallel
							if ( edgeDy < 0 ) {
	
								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
							if ( inPt.y === edgeLowPt.y ) {
	
								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
							} else {
	
								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt
	
							}
	
						} else {
	
							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;
	
						}
	
					}
	
					return	inside;
	
				}
	
				var isClockWise = ShapeUtils.isClockWise;
	
				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];
	
				if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
				var solid, tmpPath, tmpShape, shapes = [];
	
				if ( subPaths.length === 1 ) {
	
					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;
	
				}
	
				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;
	
				// console.log("Holes first", holesFirst);
	
				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;
	
				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];
	
				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;
	
					if ( solid ) {
	
						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];
	
						//console.log('cw', i);
	
					} else {
	
						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
						//console.log('ccw', i);
	
					}
	
				}
	
				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
				if ( newShapes.length > 1 ) {
	
					var ambiguous = false;
					var toChange = [];
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						betterShapeHoles[ sIdx ] = [];
	
					}
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						var sho = newShapeHoles[ sIdx ];
	
						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
							var ho = sho[ hIdx ];
							var hole_unassigned = true;
	
							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {
	
										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );
	
									} else {
	
										ambiguous = true;
	
									}
	
								}
	
							}
							if ( hole_unassigned ) {
	
								betterShapeHoles[ sIdx ].push( ho );
	
							}
	
						}
	
					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {
	
						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
					}
	
				}
	
				var tmpHoles;
	
				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];
	
					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
						tmpShape.holes.push( tmpHoles[ j ].h );
	
					}
	
				}
	
				//console.log("shape", shapes);
	
				return shapes;
	
			}
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Font( data ) {
	
			this.data = data;
	
		}
	
		Object.assign( Font.prototype, {
	
			isFont: true,
	
			generateShapes: function ( text, size, divisions ) {
	
				function createPaths( text ) {
	
					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var offset = 0;
	
					var paths = [];
	
					for ( var i = 0; i < chars.length; i ++ ) {
	
						var ret = createPath( chars[ i ], scale, offset );
						offset += ret.offset;
	
						paths.push( ret.path );
	
					}
	
					return paths;
	
				}
	
				function createPath( c, scale, offset ) {
	
					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
					if ( ! glyph ) return;
	
					var path = new ShapePath();
	
					var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
					if ( glyph.o ) {
	
						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
						for ( var i = 0, l = outline.length; i < l; ) {
	
							var action = outline[ i ++ ];
	
							switch ( action ) {
	
								case 'm': // moveTo
	
									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;
	
									path.moveTo( x, y );
	
									break;
	
								case 'l': // lineTo
	
									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;
	
									path.lineTo( x, y );
	
									break;
	
								case 'q': // quadraticCurveTo
	
									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;
	
									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											b2( t, cpx0, cpx1, cpx );
											b2( t, cpy0, cpy1, cpy );
	
										}
	
									}
	
									break;
	
								case 'b': // bezierCurveTo
	
									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;
									cpx2 = outline[ i ++ ] * scale + offset;
									cpy2 = outline[ i ++ ] * scale;
	
									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											b3( t, cpx0, cpx1, cpx2, cpx );
											b3( t, cpy0, cpy1, cpy2, cpy );
	
										}
	
									}
	
									break;
	
							}
	
						}
	
					}
	
					return { offset: glyph.ha * scale, path: path };
	
				}
	
				//
	
				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;
	
				var data = this.data;
	
				var paths = createPaths( text );
				var shapes = [];
	
				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
				}
	
				return shapes;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FontLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FontLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new XHRLoader( this.manager );
				loader.load( url, function ( text ) {
	
					var json;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( e ) {
	
						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );
	
					}
	
					var font = scope.parse( json );
	
					if ( onLoad ) onLoad( font );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				return new Font( json );
	
			}
	
		} );
	
		var context;
	
		function getAudioContext() {
	
			if ( context === undefined ) {
	
				context = new ( window.AudioContext || window.webkitAudioContext )();
	
			}
	
			return context;
	
		}
	
		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function AudioLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( AudioLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var loader = new XHRLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {
	
					var context = getAudioContext();
	
					context.decodeAudioData( buffer, function ( audioBuffer ) {
	
						onLoad( audioBuffer );
	
					} );
	
				}, onProgress, onError );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function StereoCamera() {
	
			this.type = 'StereoCamera';
	
			this.aspect = 1;
	
			this.eyeSep = 0.064;
	
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;
	
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;
	
		}
	
		Object.assign( StereoCamera.prototype, {
	
			update: ( function () {
	
				var instance, focus, fov, aspect, near, far, zoom;
	
				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();
	
				return function update( camera ) {
	
					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom;
	
					if ( needsUpdate ) {
	
						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;
	
						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/
	
						var projectionMatrix = camera.projectionMatrix.clone();
						var eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;
	
						// translate xOffset
	
						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;
	
						// for left eye
	
						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraL.projectionMatrix.copy( projectionMatrix );
	
						// for right eye
	
						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraR.projectionMatrix.copy( projectionMatrix );
	
					}
	
					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
				};
	
			} )()
	
		} );
	
		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CubeCamera( near, far, cubeResolution ) {
	
			Object3D.call( this );
	
			this.type = 'CubeCamera';
	
			var fov = 90, aspect = 1;
	
			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );
	
			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );
	
			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );
	
			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );
	
			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );
	
			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );
	
			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
	
			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	
			this.updateCubeMap = function ( renderer, scene ) {
	
				if ( this.parent === null ) this.updateMatrixWorld();
	
				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;
	
				renderTarget.texture.generateMipmaps = false;
	
				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );
	
				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );
	
				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );
	
				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );
	
				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );
	
				renderTarget.texture.generateMipmaps = generateMipmaps;
	
				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );
	
				renderer.setRenderTarget( null );
	
			};
	
		}
	
		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioListener() {
	
			Object3D.call( this );
	
			this.type = 'AudioListener';
	
			this.context = getAudioContext();
	
			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );
	
			this.filter = null;
	
		}
	
		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: AudioListener,
	
			getInput: function () {
	
				return this.gain;
	
			},
	
			removeFilter: function ( ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;
	
				}
	
			},
	
			getFilter: function () {
	
				return this.filter;
	
			},
	
			setFilter: function ( value ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
	
				} else {
	
					this.gain.disconnect( this.context.destination );
	
				}
	
				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );
	
			},
	
			getMasterVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
			setMasterVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();
	
				var orientation = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					var listener = this.context.listener;
					var up = this.up;
	
					this.matrixWorld.decompose( position, quaternion, scale );
	
					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
				};
	
			} )()
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function Audio( listener ) {
	
			Object3D.call( this );
	
			this.type = 'Audio';
	
			this.context = listener.context;
			this.source = this.context.createBufferSource();
			this.source.onended = this.onEnded.bind( this );
	
			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );
	
			this.autoplay = false;
	
			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';
	
			this.filters = [];
	
		}
	
		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Audio,
	
			getOutput: function () {
	
				return this.gain;
	
			},
	
			setNodeSource: function ( audioNode ) {
	
				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();
	
				return this;
	
			},
	
			setBuffer: function ( audioBuffer ) {
	
				this.source.buffer = audioBuffer;
				this.sourceType = 'buffer';
	
				if ( this.autoplay ) this.play();
	
				return this;
	
			},
	
			play: function () {
	
				if ( this.isPlaying === true ) {
	
					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;
	
				}
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				var source = this.context.createBufferSource();
	
				source.buffer = this.source.buffer;
				source.loop = this.source.loop;
				source.onended = this.source.onended;
				source.start( 0, this.startTime );
				source.playbackRate.value = this.playbackRate;
	
				this.isPlaying = true;
	
				this.source = source;
	
				return this.connect();
	
			},
	
			pause: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;
	
				return this;
	
			},
	
			stop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;
	
				return this;
	
			},
	
			connect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.connect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].connect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
	
				} else {
	
					this.source.connect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			disconnect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.disconnect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].disconnect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
	
				} else {
	
					this.source.disconnect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			getFilters: function () {
	
				return this.filters;
	
			},
	
			setFilters: function ( value ) {
	
				if ( ! value ) value = [];
	
				if ( this.isPlaying === true ) {
	
					this.disconnect();
					this.filters = value;
					this.connect();
	
				} else {
	
					this.filters = value;
	
				}
	
				return this;
	
			},
	
			getFilter: function () {
	
				return this.getFilters()[ 0 ];
	
			},
	
			setFilter: function ( filter ) {
	
				return this.setFilters( filter ? [ filter ] : [] );
	
			},
	
			setPlaybackRate: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.playbackRate = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.playbackRate.value = this.playbackRate;
	
				}
	
				return this;
	
			},
	
			getPlaybackRate: function () {
	
				return this.playbackRate;
	
			},
	
			onEnded: function () {
	
				this.isPlaying = false;
	
			},
	
			getLoop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;
	
				}
	
				return this.source.loop;
	
			},
	
			setLoop: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.loop = value;
	
			},
	
			getVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
	
			setVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PositionalAudio( listener ) {
	
			Audio.call( this, listener );
	
			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );
	
		}
	
		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
	
			constructor: PositionalAudio,
	
			getOutput: function () {
	
				return this.panner;
	
			},
	
			getRefDistance: function () {
	
				return this.panner.refDistance;
	
			},
	
			setRefDistance: function ( value ) {
	
				this.panner.refDistance = value;
	
			},
	
			getRolloffFactor: function () {
	
				return this.panner.rolloffFactor;
	
			},
	
			setRolloffFactor: function ( value ) {
	
				this.panner.rolloffFactor = value;
	
			},
	
			getDistanceModel: function () {
	
				return this.panner.distanceModel;
	
			},
	
			setDistanceModel: function ( value ) {
	
				this.panner.distanceModel = value;
	
			},
	
			getMaxDistance: function () {
	
				return this.panner.maxDistance;
	
			},
	
			setMaxDistance: function ( value ) {
	
				this.panner.maxDistance = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					position.setFromMatrixPosition( this.matrixWorld );
	
					this.panner.setPosition( position.x, position.y, position.z );
	
				};
	
			} )()
	
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioAnalyser( audio, fftSize ) {
	
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
			this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
			audio.getOutput().connect( this.analyser );
	
		}
	
		Object.assign( AudioAnalyser.prototype, {
	
			getFrequencyData: function () {
	
				this.analyser.getByteFrequencyData( this.data );
	
				return this.data;
	
			},
	
			getAverageFrequency: function () {
	
				var value = 0, data = this.getFrequencyData();
	
				for ( var i = 0; i < data.length; i ++ ) {
	
					value += data[ i ];
	
				}
	
				return value / data.length;
	
			}
	
		} );
	
		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyMixer( binding, typeName, valueSize ) {
	
			this.binding = binding;
			this.valueSize = valueSize;
	
			var bufferType = Float64Array,
				mixFunction;
	
			switch ( typeName ) {
	
				case 'quaternion':			mixFunction = this._slerp;		break;
	
				case 'string':
				case 'bool':
	
					bufferType = Array,		mixFunction = this._select;		break;
	
				default:					mixFunction = this._lerp;
	
			}
	
			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
	
			this._mixBufferRegion = mixFunction;
	
			this.cumulativeWeight = 0;
	
			this.useCount = 0;
			this.referenceCount = 0;
	
		}
	
		PropertyMixer.prototype = {
	
			constructor: PropertyMixer,
	
			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function( accuIndex, weight ) {
	
				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place
	
				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,
	
					currentWeight = this.cumulativeWeight;
	
				if ( currentWeight === 0 ) {
	
					// accuN := incoming * weight
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ offset + i ] = buffer[ i ];
	
					}
	
					currentWeight = weight;
	
				} else {
	
					// accuN := accuN + incoming * weight
	
					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
				}
	
				this.cumulativeWeight = currentWeight;
	
			},
	
			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function( accuIndex ) {
	
				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,
	
					weight = this.cumulativeWeight,
	
					binding = this.binding;
	
				this.cumulativeWeight = 0;
	
				if ( weight < 1 ) {
	
					// accuN := accuN + original * ( 1 - cumulativeWeight )
	
					var originalValueOffset = stride * 3;
	
					this._mixBufferRegion(
							buffer, offset, originalValueOffset, 1 - weight, stride );
	
				}
	
				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
					if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
						// value has changed -> update scene graph
	
						binding.setValue( buffer, offset );
						break;
	
					}
	
				}
	
			},
	
			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function() {
	
				var binding = this.binding;
	
				var buffer = this.buffer,
					stride = this.valueSize,
	
					originalValueOffset = stride * 3;
	
				binding.getValue( buffer, originalValueOffset );
	
				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
				}
	
				this.cumulativeWeight = 0;
	
			},
	
			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function() {
	
				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );
	
			},
	
	
			// mix functions
	
			_select: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				if ( t >= 0.5 ) {
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
					}
	
				}
	
			},
	
			_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				Quaternion.slerpFlat( buffer, dstOffset,
						buffer, dstOffset, buffer, srcOffset, t );
	
			},
	
			_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				var s = 1 - t;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					var j = dstOffset + i;
	
					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
				}
	
			}
	
		};
	
		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyBinding( rootNode, path, parsedPath ) {
	
			this.path = path;
			this.parsedPath = parsedPath ||
					PropertyBinding.parseTrackName( path );
	
			this.node = PropertyBinding.findNode(
					rootNode, this.parsedPath.nodeName ) || rootNode;
	
			this.rootNode = rootNode;
	
		}
	
		PropertyBinding.prototype = {
	
			constructor: PropertyBinding,
	
			getValue: function getValue_unbound( targetArray, offset ) {
	
				this.bind();
				this.getValue( targetArray, offset );
	
				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.
	
			},
	
			setValue: function getValue_unbound( sourceArray, offset ) {
	
				this.bind();
				this.setValue( sourceArray, offset );
	
			},
	
			// create getter / setter pair for a property in the scene graph
			bind: function() {
	
				var targetObject = this.node,
					parsedPath = this.parsedPath,
	
					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;
	
				if ( ! targetObject ) {
	
					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
					this.node = targetObject;
	
				}
	
				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;
	
		 		// ensure there is a value node
				if ( ! targetObject ) {
	
					console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
					return;
	
				}
	
				if ( objectName ) {
	
					var objectIndex = parsedPath.objectIndex;
	
					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {
	
						case 'materials':
	
							if ( ! targetObject.material ) {
	
								console.error( '  can not bind to material as node does not have a material', this );
								return;
	
							}
	
							if ( ! targetObject.material.materials ) {
	
								console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
								return;
	
							}
	
							targetObject = targetObject.material.materials;
	
							break;
	
						case 'bones':
	
							if ( ! targetObject.skeleton ) {
	
								console.error( '  can not bind to bones as node does not have a skeleton', this );
								return;
	
							}
	
							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.
	
							targetObject = targetObject.skeleton.bones;
	
							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {
	
								if ( targetObject[ i ].name === objectIndex ) {
	
									objectIndex = i;
									break;
	
								}
	
							}
	
							break;
	
						default:
	
							if ( targetObject[ objectName ] === undefined ) {
	
								console.error( '  can not bind to objectName of node, undefined', this );
								return;
	
							}
	
							targetObject = targetObject[ objectName ];
	
					}
	
	
					if ( objectIndex !== undefined ) {
	
						if ( targetObject[ objectIndex ] === undefined ) {
	
							console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
							return;
	
						}
	
						targetObject = targetObject[ objectIndex ];
	
					}
	
				}
	
				// resolve property
				var nodeProperty = targetObject[ propertyName ];
	
				if ( nodeProperty === undefined ) {
	
					var nodeName = parsedPath.nodeName;
	
					console.error( "  trying to update property for track: " + nodeName +
							'.' + propertyName + " but it wasn't found.", targetObject );
					return;
	
				}
	
				// determine versioning scheme
				var versioning = this.Versioning.None;
	
				if ( targetObject.needsUpdate !== undefined ) { // material
	
					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;
	
				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;
	
				}
	
				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;
	
				if ( propertyIndex !== undefined ) {
					// access a sub element of the property array (only primitives are supported right now)
	
					if ( propertyName === "morphTargetInfluences" ) {
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {
	
							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
							return;
	
						}
	
						if ( ! targetObject.geometry.morphTargets ) {
	
							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
							return;
	
						}
	
						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
	
								propertyIndex = i;
								break;
	
							}
	
						}
	
					}
	
					bindingType = this.BindingType.ArrayElement;
	
					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;
	
				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
					// must use copy for Object3D.Euler/Quaternion
	
					bindingType = this.BindingType.HasFromToArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else if ( nodeProperty.length !== undefined ) {
	
					bindingType = this.BindingType.EntireArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else {
	
					this.propertyName = propertyName;
	
				}
	
				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
			},
	
			unbind: function() {
	
				this.node = null;
	
				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;
	
			}
	
		};
	
		Object.assign( PropertyBinding.prototype, { // prototype, continued
	
			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function() {},
			_setValue_unavailable: function() {},
	
			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,
	
			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},
	
			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},
	
			GetterByBindingType: [
	
				function getValue_direct( buffer, offset ) {
	
					buffer[ offset ] = this.node[ this.propertyName ];
	
				},
	
				function getValue_array( buffer, offset ) {
	
					var source = this.resolvedProperty;
	
					for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
						buffer[ offset ++ ] = source[ i ];
	
					}
	
				},
	
				function getValue_arrayElement( buffer, offset ) {
	
					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
				},
	
				function getValue_toArray( buffer, offset ) {
	
					this.resolvedProperty.toArray( buffer, offset );
	
				}
	
			],
	
			SetterByBindingTypeAndVersioning: [
	
				[
					// Direct
	
					function setValue_direct( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
	
					},
	
					function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// EntireArray
	
					function setValue_array( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
					},
	
					function setValue_array_setNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// ArrayElement
	
					function setValue_arrayElement( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
					},
	
					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// HasToFromArray
	
					function setValue_fromArray( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
	
					},
	
					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				]
	
			]
	
		} );
	
		PropertyBinding.Composite =
				function( targetGroup, path, optionalParsedPath ) {
	
			var parsedPath = optionalParsedPath ||
					PropertyBinding.parseTrackName( path );
	
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );
	
		};
	
		PropertyBinding.Composite.prototype = {
	
			constructor: PropertyBinding.Composite,
	
			getValue: function( array, offset ) {
	
				this.bind(); // bind all binding
	
				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];
	
				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );
	
			},
	
			setValue: function( array, offset ) {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].setValue( array, offset );
	
				}
	
			},
	
			bind: function() {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].bind();
	
				}
	
			},
	
			unbind: function() {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].unbind();
	
				}
	
			}
	
		};
	
		PropertyBinding.create = function( root, path, parsedPath ) {
	
			if ( ! ( (root && root.isAnimationObjectGroup) ) ) {
	
				return new PropertyBinding( root, path, parsedPath );
	
			} else {
	
				return new PropertyBinding.Composite( root, path, parsedPath );
	
			}
	
		};
	
		PropertyBinding.parseTrackName = function( trackName ) {
	
			// matches strings in the form of:
			//    nodeName.property
			//    nodeName.property[accessor]
			//    nodeName.material.property[accessor]
			//    uuid.property[accessor]
			//    uuid.objectName[objectIndex].propertyName[propertyIndex]
			//    parentName/nodeName.property
			//    parentName/parentName/nodeName.property[index]
			//    .bone[Armature.DEF_cog].position
			//    scene:helium_balloon_model:helium_balloon_model.position
			// created and tested via https://regex101.com/#javascript
	
			var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
			var matches = re.exec( trackName );
	
			if ( ! matches ) {
	
				throw new Error( "cannot parse trackName at all: " + trackName );
	
			}
	
			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
			};
	
			if ( results.propertyName === null || results.propertyName.length === 0 ) {
	
				throw new Error( "can not parse propertyName from trackName: " + trackName );
	
			}
	
			return results;
	
		};
	
		PropertyBinding.findNode = function( root, nodeName ) {
	
			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
				return root;
	
			}
	
			// search into skeleton bones.
			if ( root.skeleton ) {
	
				var searchSkeleton = function( skeleton ) {
	
					for( var i = 0; i < skeleton.bones.length; i ++ ) {
	
						var bone = skeleton.bones[ i ];
	
						if ( bone.name === nodeName ) {
	
							return bone;
	
						}
					}
	
					return null;
	
				};
	
				var bone = searchSkeleton( root.skeleton );
	
				if ( bone ) {
	
					return bone;
	
				}
			}
	
			// search into node subtree.
			if ( root.children ) {
	
				var searchNodeSubtree = function( children ) {
	
					for( var i = 0; i < children.length; i ++ ) {
	
						var childNode = children[ i ];
	
						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
							return childNode;
	
						}
	
						var result = searchNodeSubtree( childNode.children );
	
						if ( result ) return result;
	
					}
	
					return null;
	
				};
	
				var subTreeNode = searchNodeSubtree( root.children );
	
				if ( subTreeNode ) {
	
					return subTreeNode;
	
				}
	
			}
	
			return null;
	
		};
	
		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */
	
		function AnimationObjectGroup( var_args ) {
	
			this.uuid = _Math.generateUUID();
	
			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );
	
			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite
	
			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				indices[ arguments[ i ].uuid ] = i;
	
			}
	
			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
			var scope = this;
	
			this.stats = {
	
				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_;  }
				},
	
				get bindingsPerObject() { return scope._bindings.length; }
	
			};
	
		}
	
		AnimationObjectGroup.prototype = {
	
			constructor: AnimationObjectGroup,
	
			isAnimationObjectGroup: true,
	
			add: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index === undefined ) {
	
						// unknown object -> add it to the ACTIVE region
	
						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );
	
						}
	
					} else if ( index < nCachedObjects ) {
	
						var knownObject = objects[ index ];
	
						// move existing object to the ACTIVE region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];
	
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = lastCached;
	
							if ( binding === undefined ) {
	
								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist
	
								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );
	
							}
	
							bindingsForPath[ firstActiveIndex ] = binding;
	
						}
	
					} else if ( objects[ index ] !== knownObject) {
	
						console.error( "Different objects with the same UUID " +
								"detected. Clean the caches or recreate your " +
								"infrastructure when reloading scenes..." );
	
					} // else the object is already where we want it to be
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			remove: function( var_args ) {
	
				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined && index >= nCachedObjects ) {
	
						// move existing object into the CACHED region
	
						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];
	
						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;
	
						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;
	
						}
	
					}
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// remove & forget
			uncache: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined ) {
	
						delete indicesByUUID[ uuid ];
	
						if ( index < nCachedObjects ) {
	
							// object is cached, shrink the CACHED region
	
							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;
	
							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];
	
								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();
	
							}
	
						} else {
	
							// object is active, just swap with the last and pop
	
							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ];
	
								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();
	
							}
	
						} // cached or active
	
					} // if object is known
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// Internal interface used by befriended PropertyBinding.Composite:
	
			subscribe_: function( path, parsedPath ) {
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;
	
				if ( index !== undefined ) return bindings[ index ];
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );
	
				index = bindings.length;
	
				indicesByPath[ path ] = index;
	
				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );
	
				for ( var i = nCachedObjects,
						n = objects.length; i !== n; ++ i ) {
	
					var object = objects[ i ];
	
					bindingsForPath[ i ] =
							new PropertyBinding( object, path, parsedPath );
	
				}
	
				return bindingsForPath;
	
			},
	
			unsubscribe_: function( path ) {
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];
	
				if ( index !== undefined ) {
	
					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];
	
					indicesByPath[ lastBindingsPath ] = index;
	
					bindings[ index ] = lastBindings;
					bindings.pop();
	
					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();
	
					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();
	
				}
	
			}
	
		};
	
		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */
	
		function AnimationAction( mixer, clip, localRoot ) {
	
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;
	
			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );
	
			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;
	
			}
	
			this._interpolantSettings = interpolantSettings;
	
			this._interpolants = interpolants;	// bound by the mixer
	
			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );
	
			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager
	
			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
	
			this.loop = LoopRepeat;
			this._loopCount = -1;
	
			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;
	
			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;
	
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
	
			this.weight = 1;
			this._effectiveWeight = 1;
	
			this.repetitions = Infinity; 		// no. of repetitions when looping
	
			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight
	
			this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
		}
	
		AnimationAction.prototype = {
	
			constructor: AnimationAction,
	
			// State & Scheduling
	
			play: function() {
	
				this._mixer._activateAction( this );
	
				return this;
	
			},
	
			stop: function() {
	
				this._mixer._deactivateAction( this );
	
				return this.reset();
	
			},
	
			reset: function() {
	
				this.paused = false;
				this.enabled = true;
	
				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling
	
				return this.stopFading().stopWarping();
	
			},
	
			isRunning: function() {
	
				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );
	
			},
	
			// return true when play has been called
			isScheduled: function() {
	
				return this._mixer._isActiveAction( this );
	
			},
	
			startAt: function( time ) {
	
				this._startTime = time;
	
				return this;
	
			},
	
			setLoop: function( mode, repetitions ) {
	
				this.loop = mode;
				this.repetitions = repetitions;
	
				return this;
	
			},
	
			// Weight
	
			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {
	
				this.weight = weight;
	
				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;
	
				return this.stopFading();
	
			},
	
			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {
	
				return this._effectiveWeight;
	
			},
	
			fadeIn: function( duration ) {
	
				return this._scheduleFading( duration, 0, 1 );
	
			},
	
			fadeOut: function( duration ) {
	
				return this._scheduleFading( duration, 1, 0 );
	
			},
	
			crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );
	
				if( warp ) {
	
					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,
	
						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;
	
					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );
	
				}
	
				return this;
	
			},
	
			crossFadeTo: function( fadeInAction, duration, warp ) {
	
				return fadeInAction.crossFadeFrom( this, duration, warp );
	
			},
	
			stopFading: function() {
	
				var weightInterpolant = this._weightInterpolant;
	
				if ( weightInterpolant !== null ) {
	
					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );
	
				}
	
				return this;
	
			},
	
			// Time Scale Control
	
			// set the weight stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {
	
				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
				return this.stopWarping();
	
			},
	
			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {
	
				return this._effectiveTimeScale;
	
			},
	
			setDuration: function( duration ) {
	
				this.timeScale = this._clip.duration / duration;
	
				return this.stopWarping();
	
			},
	
			syncWith: function( action ) {
	
				this.time = action.time;
				this.timeScale = action.timeScale;
	
				return this.stopWarping();
	
			},
	
			halt: function( duration ) {
	
				return this.warp( this._effectiveTimeScale, 0, duration );
	
			},
	
			warp: function( startTimeScale, endTimeScale, duration ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,
	
					timeScale = this.timeScale;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant(),
					this._timeScaleInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now;
				times[ 1 ] = now + duration;
	
				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;
	
				return this;
	
			},
	
			stopWarping: function() {
	
				var timeScaleInterpolant = this._timeScaleInterpolant;
	
				if ( timeScaleInterpolant !== null ) {
	
					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
				}
	
				return this;
	
			},
	
			// Object Accessors
	
			getMixer: function() {
	
				return this._mixer;
	
			},
	
			getClip: function() {
	
				return this._clip;
	
			},
	
			getRoot: function() {
	
				return this._localRoot || this._mixer._root;
	
			},
	
			// Interna
	
			_update: function( time, deltaTime, timeDirection, accuIndex ) {
				// called by the mixer
	
				var startTime = this._startTime;
	
				if ( startTime !== null ) {
	
					// check for scheduled start of action
	
					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {
	
						return; // yet to come / don't decide when delta = 0
	
					}
	
					// start
	
					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;
	
				}
	
				// apply time scale and advance time
	
				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );
	
				// note: _updateTime may disable the action resulting in
				// an effective weight of 0
	
				var weight = this._updateWeight( time );
	
				if ( weight > 0 ) {
	
					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;
	
					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );
	
					}
	
				}
	
			},
	
			_updateWeight: function( time ) {
	
				var weight = 0;
	
				if ( this.enabled ) {
	
					weight = this.weight;
					var interpolant = this._weightInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						weight *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopFading();
	
							if ( interpolantValue === 0 ) {
	
								// faded out, disable
								this.enabled = false;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveWeight = weight;
				return weight;
	
			},
	
			_updateTimeScale: function( time ) {
	
				var timeScale = 0;
	
				if ( ! this.paused ) {
	
					timeScale = this.timeScale;
	
					var interpolant = this._timeScaleInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						timeScale *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopWarping();
	
							if ( timeScale === 0 ) {
	
								// motion has halted, pause
								this.paused = true;
	
							} else {
	
								// warp done - apply final time scale
								this.timeScale = timeScale;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveTimeScale = timeScale;
				return timeScale;
	
			},
	
			_updateTime: function( deltaTime ) {
	
				var time = this.time + deltaTime;
	
				if ( deltaTime === 0 ) return time;
	
				var duration = this._clip.duration,
	
					loop = this.loop,
					loopCount = this._loopCount;
	
				if ( loop === LoopOnce ) {
	
					if ( loopCount === -1 ) {
						// just started
	
						this.loopCount = 0;
						this._setEndings( true, true, false );
	
					}
	
					handle_stop: {
	
						if ( time >= duration ) {
	
							time = duration;
	
						} else if ( time < 0 ) {
	
							time = 0;
	
						} else break handle_stop;
	
						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
	
						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );
	
					}
	
				} else { // repetitive Repeat or PingPong
	
					var pingPong = ( loop === LoopPingPong );
	
					if ( loopCount === -1 ) {
						// just started
	
						if ( deltaTime >= 0 ) {
	
							loopCount = 0;
	
							this._setEndings(
									true, this.repetitions === 0, pingPong );
	
						} else {
	
							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1
	
							this._setEndings(
									this.repetitions === 0, true, pingPong );
	
						}
	
					}
	
					if ( time >= duration || time < 0 ) {
						// wrap around
	
						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;
	
						loopCount += Math.abs( loopDelta );
	
						var pending = this.repetitions - loopCount;
	
						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)
	
							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;
	
							time = deltaTime > 0 ? duration : 0;
	
							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );
	
						} else {
							// keep running
	
							if ( pending === 0 ) {
								// entering the last round
	
								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );
	
							} else {
	
								this._setEndings( false, false, pingPong );
	
							}
	
							this._loopCount = loopCount;
	
							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );
	
						}
	
					}
	
					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"
	
						this.time = time;
						return duration - time;
	
					}
	
				}
	
				this.time = time;
				return time;
	
			},
	
			_setEndings: function( atStart, atEnd, pingPong ) {
	
				var settings = this._interpolantSettings;
	
				if ( pingPong ) {
	
					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;
	
				} else {
	
					// assuming for LoopOnce atStart == atEnd == true
	
					if ( atStart ) {
	
						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingStart = WrapAroundEnding;
	
					}
	
					if ( atEnd ) {
	
						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingEnd 	 = WrapAroundEnding;
	
					}
	
				}
	
			},
	
			_scheduleFading: function( duration, weightNow, weightThen ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant(),
					this._weightInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
				return this;
	
			}
	
		};
	
		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function AnimationMixer( root ) {
	
			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
	
			this.time = 0;
	
			this.timeScale = 1.0;
	
		}
	
		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {
	
			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject !== null ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;
	
				if ( actionsForClip !== undefined ) {
	
					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];
	
					if ( existingAction !== undefined ) {
	
						return existingAction;
	
					}
	
					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];
	
					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;
	
				}
	
				// clip must be known when specified via string
				if ( clipObject === null ) return null;
	
				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );
	
				this._bindAction( newAction, prototypeAction );
	
				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );
	
				return newAction;
	
			},
	
			// get an existing action
			existingAction: function( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					return actionsForClip.actionByRoot[ rootUuid ] || null;
	
				}
	
				return null;
	
			},
	
			// deactivates all previously scheduled actions
			stopAllAction: function() {
	
				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				this._nActiveActions = 0;
				this._nActiveBindings = 0;
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					actions[ i ].reset();
	
				}
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].useCount = 0;
	
				}
	
				return this;
	
			},
	
			// advance the time and update apply the animation
			update: function( deltaTime ) {
	
				deltaTime *= this.timeScale;
	
				var actions = this._actions,
					nActions = this._nActiveActions,
	
					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),
	
					accuIndex = this._accuIndex ^= 1;
	
				// run active actions
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					var action = actions[ i ];
	
					if ( action.enabled ) {
	
						action._update( time, deltaTime, timeDirection, accuIndex );
	
					}
	
				}
	
				// update scene graph
	
				var bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].apply( accuIndex );
	
				}
	
				return this;
	
			},
	
			// return this mixer's root target object
			getRoot: function() {
	
				return this._root;
	
			},
	
			// free all resources specific to a particular clip
			uncacheClip: function( clip ) {
	
				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away
	
					var actionsToRemove = actionsForClip.knownActions;
	
					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
						var action = actionsToRemove[ i ];
	
						this._deactivateAction( action );
	
						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];
	
						action._cacheIndex = null;
						action._byClipCacheIndex = null;
	
						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();
	
						this._removeInactiveBindingsForAction( action );
	
					}
	
					delete actionsByClip[ clipUuid ];
	
				}
	
			},
	
			// free all resources specific to a particular root target object
			uncacheRoot: function( root ) {
	
				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;
	
				for ( var clipUuid in actionsByClip ) {
	
					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];
	
					if ( action !== undefined ) {
	
						this._deactivateAction( action );
						this._removeInactiveAction( action );
	
					}
	
				}
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingByName !== undefined ) {
	
					for ( var trackName in bindingByName ) {
	
						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			// remove a targeted clip from the cache
			uncacheAction: function( clip, optionalRoot ) {
	
				var action = this.existingAction( clip, optionalRoot );
	
				if ( action !== null ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
		} );
	
		// Implementation details:
	
		Object.assign( AnimationMixer.prototype, {
	
			_bindAction: function( action, prototypeAction ) {
	
				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingsByName === undefined ) {
	
					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;
	
				}
	
				for ( var i = 0; i !== nTracks; ++ i ) {
	
					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];
	
					if ( binding !== undefined ) {
	
						bindings[ i ] = binding;
	
					} else {
	
						binding = bindings[ i ];
	
						if ( binding !== undefined ) {
	
							// existing binding, make sure the cache knows
	
							if ( binding._cacheIndex === null ) {
	
								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );
	
							}
	
							continue;
	
						}
	
						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;
	
						binding = new PropertyMixer(
								PropertyBinding.create( root, trackName, path ),
								track.ValueTypeName, track.getValueSize() );
	
						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );
	
						bindings[ i ] = binding;
	
					}
	
					interpolants[ i ].resultBuffer = binding.buffer;
	
				}
	
			},
	
			_activateAction: function( action ) {
	
				if ( ! this._isActiveAction( action ) ) {
	
					if ( action._cacheIndex === null ) {
	
						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind
	
						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];
	
						this._bindAction( action,
								actionsForClip && actionsForClip.knownActions[ 0 ] );
	
						this._addInactiveAction( action, clipUuid, rootUuid );
	
					}
	
					var bindings = action._propertyBindings;
	
					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( binding.useCount ++ === 0 ) {
	
							this._lendBinding( binding );
							binding.saveOriginalState();
	
						}
	
					}
	
					this._lendAction( action );
	
				}
	
			},
	
			_deactivateAction: function( action ) {
	
				if ( this._isActiveAction( action ) ) {
	
					var bindings = action._propertyBindings;
	
					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( -- binding.useCount === 0 ) {
	
							binding.restoreOriginalState();
							this._takeBackBinding( binding );
	
						}
	
					}
	
					this._takeBackAction( action );
	
				}
	
			},
	
			// Memory manager
	
			_initMemoryManager: function() {
	
				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;
	
				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }
	
	
				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;
	
				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;
	
				var scope = this;
	
				this.stats = {
	
					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}
	
				};
	
			},
	
			// Memory management for AnimationAction objects
	
			_isActiveAction: function( action ) {
	
				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;
	
			},
	
			_addInactiveAction: function( action, clipUuid, rootUuid ) {
	
				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip === undefined ) {
	
					actionsForClip = {
	
						knownActions: [ action ],
						actionByRoot: {}
	
					};
	
					action._byClipCacheIndex = 0;
	
					actionsByClip[ clipUuid ] = actionsForClip;
	
				} else {
	
					var knownActions = actionsForClip.knownActions;
	
					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );
	
				}
	
				action._cacheIndex = actions.length;
				actions.push( action );
	
				actionsForClip.actionByRoot[ rootUuid ] = action;
	
			},
	
			_removeInactiveAction: function( action ) {
	
				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;
	
				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();
	
				action._cacheIndex = null;
	
	
				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,
	
					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],
	
					byClipCacheIndex = action._byClipCacheIndex;
	
				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();
	
				action._byClipCacheIndex = null;
	
	
				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( actions._localRoot || this._root ).uuid;
	
				delete actionByRoot[ rootUuid ];
	
				if ( knownActionsForClip.length === 0 ) {
	
					delete actionsByClip[ clipUuid ];
	
				}
	
				this._removeInactiveBindingsForAction( action );
	
			},
	
			_removeInactiveBindingsForAction: function( action ) {
	
				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.referenceCount === 0 ) {
	
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			_lendAction: function( action ) {
	
				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					lastActiveIndex = this._nActiveActions ++,
	
					firstInactiveAction = actions[ lastActiveIndex ];
	
				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;
	
				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;
	
			},
	
			_takeBackAction: function( action ) {
	
				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveActions,
	
					lastActiveAction = actions[ firstInactiveIndex ];
	
				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;
	
				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;
	
			},
	
			// Memory management for PropertyMixer objects
	
			_addInactiveBinding: function( binding, rootUuid, trackName ) {
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					bindings = this._bindings;
	
				if ( bindingByName === undefined ) {
	
					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;
	
				}
	
				bindingByName[ trackName ] = binding;
	
				binding._cacheIndex = bindings.length;
				bindings.push( binding );
	
			},
	
			_removeInactiveBinding: function( binding ) {
	
				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;
	
				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();
	
				delete bindingByName[ trackName ];
	
				remove_empty_map: {
	
					for ( var _ in bindingByName ) break remove_empty_map;
	
					delete bindingsByRoot[ rootUuid ];
	
				}
	
			},
	
			_lendBinding: function( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					lastActiveIndex = this._nActiveBindings ++,
	
					firstInactiveBinding = bindings[ lastActiveIndex ];
	
				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;
	
				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;
	
			},
	
			_takeBackBinding: function( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveBindings,
	
					lastActiveBinding = bindings[ firstInactiveIndex ];
	
				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;
	
				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;
	
			},
	
	
			// Memory management of Interpolants for weight and time scale
	
			_lendControlInterpolant: function() {
	
				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];
	
				if ( interpolant === undefined ) {
	
					interpolant = new LinearInterpolant(
							new Float32Array( 2 ), new Float32Array( 2 ),
								1, this._controlInterpolantsResultBuffer );
	
					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;
	
				}
	
				return interpolant;
	
			},
	
			_takeBackControlInterpolant: function( interpolant ) {
	
				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,
	
					firstInactiveIndex = -- this._nActiveControlInterpolants,
	
					lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;
	
				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;
	
			},
	
			_controlInterpolantsResultBuffer: new Float32Array( 1 )
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Uniform( value ) {
	
			if ( typeof value === 'string' ) {
	
				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];
	
			}
	
			this.value = value;
	
		}
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferGeometry() {
	
			BufferGeometry.call( this );
	
			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;
	
		}
	
		InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;
	
		InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
	
		InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex
	
			} );
	
		};
	
		InstancedBufferGeometry.prototype.copy = function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );
	
			}
	
			return this;
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
	
			this.uuid = _Math.generateUUID();
	
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
	
			this.normalized = normalized === true;
	
		}
	
	
		InterleavedBufferAttribute.prototype = {
	
			constructor: InterleavedBufferAttribute,
	
			isInterleavedBufferAttribute: true,
	
			get count() {
	
				return this.data.count;
	
			},
	
			get array() {
	
				return this.data.array;
	
			},
	
			setX: function ( index, x ) {
	
				this.data.array[ index * this.data.stride + this.offset ] = x;
	
				return this;
	
			},
	
			setY: function ( index, y ) {
	
				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
				return this;
	
			},
	
			setZ: function ( index, z ) {
	
				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
				return this;
	
			},
	
			setW: function ( index, w ) {
	
				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset ];
	
			},
	
			getY: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
			},
	
			getZ: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
			},
	
			getW: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
			},
	
			setXY: function ( index, x, y ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBuffer( array, stride ) {
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.version = 0;
	
		}
	
		InterleavedBuffer.prototype = {
	
			constructor: InterleavedBuffer,
	
			isInterleavedBuffer: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.stride;
				index2 *= attribute.stride;
	
				for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			}
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
	
			InterleavedBuffer.call( this, array, stride );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
		InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;
	
		InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
	
		InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
			InterleavedBuffer.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {
	
			BufferAttribute.call( this, array, itemSize );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;
	
		InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
	
		InstancedBufferAttribute.prototype.copy = function ( source ) {
	
			BufferAttribute.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */
	
		function Raycaster( origin, direction, near, far ) {
	
			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		}
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		Raycaster.prototype = {
	
			constructor: Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( (camera && camera.isPerspectiveCamera) ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( (camera && camera.isOrthographicCamera) ) {
	
					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Clock( autoStart ) {
	
			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
	
			this.running = false;
	
		}
	
		Clock.prototype = {
	
			constructor: Clock,
	
			start: function () {
	
				this.startTime = ( performance || Date ).now();
	
				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;
	
			},
	
			stop: function () {
	
				this.getElapsedTime();
				this.running = false;
	
			},
	
			getElapsedTime: function () {
	
				this.getDelta();
				return this.elapsedTime;
	
			},
	
			getDelta: function () {
	
				var diff = 0;
	
				if ( this.autoStart && ! this.running ) {
	
					this.start();
	
				}
	
				if ( this.running ) {
	
					var newTime = ( performance || Date ).now();
	
					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;
	
					this.elapsedTime += diff;
	
				}
	
				return diff;
	
			}
	
		};
	
		/**
		 * Spline from Tween.js, slightly optimized (and trashed)
		 * http://sole.github.com/tween.js/examples/05_spline.html
		 *
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Spline( points ) {
	
			this.points = points;
	
			var c = [], v3 = { x: 0, y: 0, z: 0 },
			point, intPoint, weight, w2, w3,
			pa, pb, pc, pd;
	
			this.initFromArray = function ( a ) {
	
				this.points = [];
	
				for ( var i = 0; i < a.length; i ++ ) {
	
					this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
				}
	
			};
	
			this.getPoint = function ( k ) {
	
				point = ( this.points.length - 1 ) * k;
				intPoint = Math.floor( point );
				weight = point - intPoint;
	
				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
				c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
				pa = this.points[ c[ 0 ] ];
				pb = this.points[ c[ 1 ] ];
				pc = this.points[ c[ 2 ] ];
				pd = this.points[ c[ 3 ] ];
	
				w2 = weight * weight;
				w3 = weight * w2;
	
				v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
				v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
				v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
				return v3;
	
			};
	
			this.getControlPointsArray = function () {
	
				var i, p, l = this.points.length,
					coords = [];
	
				for ( i = 0; i < l; i ++ ) {
	
					p = this.points[ i ];
					coords[ i ] = [ p.x, p.y, p.z ];
	
				}
	
				return coords;
	
			};
	
			// approximate length by summing linear segments
	
			this.getLength = function ( nSubDivisions ) {
	
				var i, index, nSamples, position,
					point = 0, intPoint = 0, oldIntPoint = 0,
					oldPosition = new Vector3(),
					tmpVec = new Vector3(),
					chunkLengths = [],
					totalLength = 0;
	
				// first point has 0 length
	
				chunkLengths[ 0 ] = 0;
	
				if ( ! nSubDivisions ) nSubDivisions = 100;
	
				nSamples = this.points.length * nSubDivisions;
	
				oldPosition.copy( this.points[ 0 ] );
	
				for ( i = 1; i < nSamples; i ++ ) {
	
					index = i / nSamples;
	
					position = this.getPoint( index );
					tmpVec.copy( position );
	
					totalLength += tmpVec.distanceTo( oldPosition );
	
					oldPosition.copy( position );
	
					point = ( this.points.length - 1 ) * index;
					intPoint = Math.floor( point );
	
					if ( intPoint !== oldIntPoint ) {
	
						chunkLengths[ intPoint ] = totalLength;
						oldIntPoint = intPoint;
	
					}
	
				}
	
				// last point ends with total length
	
				chunkLengths[ chunkLengths.length ] = totalLength;
	
				return { chunks: chunkLengths, total: totalLength };
	
			};
	
			this.reparametrizeByArcLength = function ( samplingCoef ) {
	
				var i, j,
					index, indexCurrent, indexNext,
					realDistance,
					sampling, position,
					newpoints = [],
					tmpVec = new Vector3(),
					sl = this.getLength();
	
				newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
				for ( i = 1; i < this.points.length; i ++ ) {
	
					//tmpVec.copy( this.points[ i - 1 ] );
					//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
					realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
					sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
					indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
					indexNext = i / ( this.points.length - 1 );
	
					for ( j = 1; j < sampling - 1; j ++ ) {
	
						index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
						position = this.getPoint( index );
						newpoints.push( tmpVec.copy( position ).clone() );
	
					}
	
					newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
				}
	
				this.points = newpoints;
	
			};
	
			// Catmull-Rom
	
			function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;
	
				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
			}
	
		}
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */
	
		function Spherical( radius, phi, theta ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere
	
			return this;
	
		}
	
		Spherical.prototype = {
	
			constructor: Spherical,
	
			set: function ( radius, phi, theta ) {
	
				this.radius = radius;
				this.phi = phi;
				this.theta = theta;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;
	
				return this;
	
			},
	
			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {
	
				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = vec3.length();
	
				if ( this.radius === 0 ) {
	
					this.theta = 0;
					this.phi = 0;
	
				} else {
	
					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle
	
				}
	
				return this;
	
			},
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function MorphBlendMesh( geometry, material ) {
	
			Mesh.call( this, geometry, material );
	
			this.animationsMap = {};
			this.animationsList = [];
	
			// prepare default animation
			// (all frames played together in 1 second)
	
			var numFrames = this.geometry.morphTargets.length;
	
			var name = "__default";
	
			var startFrame = 0;
			var endFrame = numFrames - 1;
	
			var fps = numFrames / 1;
	
			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );
	
		}
	
		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;
	
		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
			var animation = {
	
				start: start,
				end: end,
	
				length: end - start + 1,
	
				fps: fps,
				duration: ( end - start ) / fps,
	
				lastFrame: 0,
				currentFrame: 0,
	
				active: false,
	
				time: 0,
				direction: 1,
				weight: 1,
	
				directionBackwards: false,
				mirroredLoop: false
	
			};
	
			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );
	
		};
	
		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
			var pattern = /([a-z]+)_?(\d+)/i;
	
			var firstAnimation, frameRanges = {};
	
			var geometry = this.geometry;
	
			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );
	
				if ( chunks && chunks.length > 1 ) {
	
					var name = chunks[ 1 ];
	
					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
					var range = frameRanges[ name ];
	
					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;
	
					if ( ! firstAnimation ) firstAnimation = name;
	
				}
	
			}
	
			for ( var name in frameRanges ) {
	
				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );
	
			}
	
			this.firstAnimation = firstAnimation;
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = 1;
				animation.directionBackwards = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = - 1;
				animation.directionBackwards = true;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.weight = weight;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = time;
	
			}
	
		};
	
		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
			var time = 0;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				time = animation.time;
	
			}
	
			return time;
	
		};
	
		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
			var duration = - 1;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				duration = animation.duration;
	
			}
	
			return duration;
	
		};
	
		MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = 0;
				animation.active = true;
	
			} else {
	
				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
			}
	
		};
	
		MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.active = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.update = function ( delta ) {
	
			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
				var animation = this.animationsList[ i ];
	
				if ( ! animation.active ) continue;
	
				var frameTime = animation.duration / animation.length;
	
				animation.time += animation.direction * delta;
	
				if ( animation.mirroredLoop ) {
	
					if ( animation.time > animation.duration || animation.time < 0 ) {
	
						animation.direction *= - 1;
	
						if ( animation.time > animation.duration ) {
	
							animation.time = animation.duration;
							animation.directionBackwards = true;
	
						}
	
						if ( animation.time < 0 ) {
	
							animation.time = 0;
							animation.directionBackwards = false;
	
						}
	
					}
	
				} else {
	
					animation.time = animation.time % animation.duration;
	
					if ( animation.time < 0 ) animation.time += animation.duration;
	
				}
	
				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;
	
				if ( keyframe !== animation.currentFrame ) {
	
					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
					this.morphTargetInfluences[ keyframe ] = 0;
	
					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;
	
				}
	
				var mix = ( animation.time % frameTime ) / frameTime;
	
				if ( animation.directionBackwards ) mix = 1 - mix;
	
				if ( animation.currentFrame !== animation.lastFrame ) {
	
					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
				} else {
	
					this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
				}
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function ImmediateRenderObject( material ) {
	
			Object3D.call( this );
	
			this.material = material;
			this.render = function ( renderCallback ) {};
	
		}
	
		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	
		ImmediateRenderObject.prototype.isImmediateRenderObject = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function VertexNormalsHelper( object, size, hex, linewidth ) {
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xff0000;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( (objGeometry && objGeometry.isGeometry) ) {
	
				nNormals = objGeometry.faces.length * 3;
	
			} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {
	
				nNormals = objGeometry.attributes.normal.count;
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32Attribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
	
		VertexNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				var keys = [ 'a', 'b', 'c' ];
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				if ( (objGeometry && objGeometry.isGeometry) ) {
	
					var vertices = objGeometry.vertices;
	
					var faces = objGeometry.faces;
	
					var idx = 0;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						var face = faces[ i ];
	
						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
							var vertex = vertices[ face[ keys[ j ] ] ];
	
							var normal = face.vertexNormals[ j ];
	
							v1.copy( vertex ).applyMatrix4( matrixWorld );
	
							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
							position.setXYZ( idx, v1.x, v1.y, v1.z );
	
							idx = idx + 1;
	
							position.setXYZ( idx, v2.x, v2.y, v2.z );
	
							idx = idx + 1;
	
						}
	
					}
	
				} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {
	
					var objPos = objGeometry.attributes.position;
	
					var objNorm = objGeometry.attributes.normal;
	
					var idx = 0;
	
					// for simplicity, ignore index and drawcalls, and render every normal
	
					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
				position.needsUpdate = true;
	
				return this;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function SpotLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new BufferGeometry();
	
			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];
	
			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
	
				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;
	
				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);
	
			}
	
			geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );
	
			this.update();
	
		}
	
		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;
	
		SpotLightHelper.prototype.dispose = function () {
	
			this.cone.geometry.dispose();
			this.cone.material.dispose();
	
		};
	
		SpotLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
			var vector2 = new Vector3();
	
			return function update() {
	
				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );
	
				this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
				this.cone.lookAt( vector2.sub( vector ) );
	
				this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			};
	
		}();
	
		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 */
	
		function SkeletonHelper( object ) {
	
			this.bones = this.getBoneList( object );
	
			var geometry = new Geometry();
	
			for ( var i = 0; i < this.bones.length; i ++ ) {
	
				var bone = this.bones[ i ];
	
				if ( (bone.parent && bone.parent.isBone) ) {
	
					geometry.vertices.push( new Vector3() );
					geometry.vertices.push( new Vector3() );
					geometry.colors.push( new Color( 0, 0, 1 ) );
					geometry.colors.push( new Color( 0, 1, 0 ) );
	
				}
	
			}
	
			geometry.dynamic = true;
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
			LineSegments.call( this, geometry, material );
	
			this.root = object;
	
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
	
		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;
	
		SkeletonHelper.prototype.getBoneList = function( object ) {
	
			var boneList = [];
	
			if ( (object && object.isBone) ) {
	
				boneList.push( object );
	
			}
	
			for ( var i = 0; i < object.children.length; i ++ ) {
	
				boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
			}
	
			return boneList;
	
		};
	
		SkeletonHelper.prototype.update = function () {
	
			var geometry = this.geometry;
	
			var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );
	
			var boneMatrix = new Matrix4();
	
			var j = 0;
	
			for ( var i = 0; i < this.bones.length; i ++ ) {
	
				var bone = this.bones[ i ];
	
				if ( (bone.parent && bone.parent.isBone) ) {
	
					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );
	
					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );
	
					j += 2;
	
				}
	
			}
	
			geometry.verticesNeedUpdate = true;
	
			geometry.computeBoundingSphere();
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PointLightHelper( light, sphereSize ) {
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			Mesh.call( this, geometry, material );
	
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
			var d = light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.scale.set( d, d, d );
	
			}
	
			this.add( this.lightDistance );
			*/
	
		}
	
		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;
	
		PointLightHelper.prototype.dispose = function () {
	
			this.geometry.dispose();
			this.material.dispose();
	
		};
	
		PointLightHelper.prototype.update = function () {
	
			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			/*
			var d = this.light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
	
			}
			*/
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function HemisphereLightHelper( light, sphereSize ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.colors = [ new Color(), new Color() ];
	
			var geometry = new SphereGeometry( sphereSize, 4, 2 );
			geometry.rotateX( - Math.PI / 2 );
	
			for ( var i = 0, il = 8; i < il; i ++ ) {
	
				geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];
	
			}
	
			var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );
	
			this.lightSphere = new Mesh( geometry, material );
			this.add( this.lightSphere );
	
			this.update();
	
		}
	
		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
	
		HemisphereLightHelper.prototype.dispose = function () {
	
			this.lightSphere.geometry.dispose();
			this.lightSphere.material.dispose();
	
		};
	
		HemisphereLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
	
			return function update() {
	
				this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
				this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
				this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
				this.lightSphere.geometry.colorsNeedUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function GridHelper( size, divisions, color1, color2 ) {
	
			divisions = divisions || 1;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var center = divisions / 2;
			var step = ( size * 2 ) / divisions;
			var vertices = [], colors = [];
	
			for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {
	
				vertices.push( - size, 0, k, size, 0, k );
				vertices.push( k, 0, - size, k, 0, size );
	
				var color = i === center ? color1 : color2;
	
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;
	
		GridHelper.prototype.setColors = function () {
	
			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function FaceNormalsHelper( object, size, hex, linewidth ) {
	
			// FaceNormalsHelper only supports THREE.Geometry
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xffff00;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( (objGeometry && objGeometry.isGeometry) ) {
	
				nNormals = objGeometry.faces.length;
	
			} else {
	
				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32Attribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
			this.update();
	
		}
	
		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
	
		FaceNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var normal = face.normal;
	
					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );
	
					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
				position.needsUpdate = true;
	
				return this;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function DirectionalLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			if ( size === undefined ) size = 1;
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.add( new Line( geometry, material ) );
	
			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	
			this.add( new Line( geometry, material ));
	
			this.update();
	
		}
	
		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
	
		DirectionalLightHelper.prototype.dispose = function () {
	
			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];
	
			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();
	
		};
	
		DirectionalLightHelper.prototype.update = function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();
	
			return function update() {
	
				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );
	
				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];
	
				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */
	
		function CameraHelper( camera ) {
	
			var geometry = new Geometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
	
			var pointMap = {};
	
			// colors
	
			var hexFrustum = 0xffaa00;
			var hexCone = 0xff0000;
			var hexUp = 0x00aaff;
			var hexTarget = 0xffffff;
			var hexCross = 0x333333;
	
			// near
	
			addLine( "n1", "n2", hexFrustum );
			addLine( "n2", "n4", hexFrustum );
			addLine( "n4", "n3", hexFrustum );
			addLine( "n3", "n1", hexFrustum );
	
			// far
	
			addLine( "f1", "f2", hexFrustum );
			addLine( "f2", "f4", hexFrustum );
			addLine( "f4", "f3", hexFrustum );
			addLine( "f3", "f1", hexFrustum );
	
			// sides
	
			addLine( "n1", "f1", hexFrustum );
			addLine( "n2", "f2", hexFrustum );
			addLine( "n3", "f3", hexFrustum );
			addLine( "n4", "f4", hexFrustum );
	
			// cone
	
			addLine( "p", "n1", hexCone );
			addLine( "p", "n2", hexCone );
			addLine( "p", "n3", hexCone );
			addLine( "p", "n4", hexCone );
	
			// up
	
			addLine( "u1", "u2", hexUp );
			addLine( "u2", "u3", hexUp );
			addLine( "u3", "u1", hexUp );
	
			// target
	
			addLine( "c", "t", hexTarget );
			addLine( "p", "c", hexCross );
	
			// cross
	
			addLine( "cn1", "cn2", hexCross );
			addLine( "cn3", "cn4", hexCross );
	
			addLine( "cf1", "cf2", hexCross );
			addLine( "cf3", "cf4", hexCross );
	
			function addLine( a, b, hex ) {
	
				addPoint( a, hex );
				addPoint( b, hex );
	
			}
	
			function addPoint( id, hex ) {
	
				geometry.vertices.push( new Vector3() );
				geometry.colors.push( new Color( hex ) );
	
				if ( pointMap[ id ] === undefined ) {
	
					pointMap[ id ] = [];
	
				}
	
				pointMap[ id ].push( geometry.vertices.length - 1 );
	
			}
	
			LineSegments.call( this, geometry, material );
	
			this.camera = camera;
			if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.pointMap = pointMap;
	
			this.update();
	
		}
	
		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;
	
		CameraHelper.prototype.update = function () {
	
			var geometry, pointMap;
	
			var vector = new Vector3();
			var camera = new Camera();
	
			function setPoint( point, x, y, z ) {
	
				vector.set( x, y, z ).unproject( camera );
	
				var points = pointMap[ point ];
	
				if ( points !== undefined ) {
	
					for ( var i = 0, il = points.length; i < il; i ++ ) {
	
						geometry.vertices[ points[ i ] ].copy( vector );
	
					}
	
				}
	
			}
	
			return function update() {
	
				geometry = this.geometry;
				pointMap = this.pointMap;
	
				var w = 1, h = 1;
	
				// we need just camera projection matrix
				// world matrix must be identity
	
				camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
				// center / target
	
				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );
	
				// near
	
				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );
	
				// far
	
				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );
	
				// up
	
				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );
	
				// cross
	
				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );
	
				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );
	
				geometry.verticesNeedUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		// a helper to show the world-axis-aligned bounding box for an object
	
		function BoundingBoxHelper( object, hex ) {
	
			var color = ( hex !== undefined ) ? hex : 0x888888;
	
			this.object = object;
	
			this.box = new Box3();
	
			Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );
	
		}
	
		BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
		BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;
	
		BoundingBoxHelper.prototype.update = function () {
	
			this.box.setFromObject( this.object );
	
			this.box.getSize( this.scale );
	
			this.box.getCenter( this.position );
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BoxHelper( object, color ) {
	
			if ( color === undefined ) color = 0xffff00;
	
			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );
	
			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
			if ( object !== undefined ) {
	
				this.update( object );
	
			}
	
		}
	
		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;
	
		BoxHelper.prototype.update = ( function () {
	
			var box = new Box3();
	
			return function update( object ) {
	
				if ( (object && object.isBox3) ) {
	
					box.copy( object );
	
				} else {
	
					box.setFromObject( object );
	
				}
	
				if ( box.isEmpty() ) return;
	
				var min = box.min;
				var max = box.max;
	
				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/
	
				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/
	
				var position = this.geometry.attributes.position;
				var array = position.array;
	
				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
				position.needsUpdate = true;
	
				this.geometry.computeBoundingSphere();
	
			};
	
		} )();
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */
	
		var lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
	
		var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );
	
		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.position.copy( origin );
	
			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;
	
		ArrowHelper.prototype.setDirection = ( function () {
	
			var axis = new Vector3();
			var radians;
	
			return function setDirection( dir ) {
	
				// dir is assumed to be normalized
	
				if ( dir.y > 0.99999 ) {
	
					this.quaternion.set( 0, 0, 0, 1 );
	
				} else if ( dir.y < - 0.99999 ) {
	
					this.quaternion.set( 1, 0, 0, 0 );
	
				} else {
	
					axis.set( dir.z, 0, - dir.x ).normalize();
	
					radians = Math.acos( dir.y );
	
					this.quaternion.setFromAxisAngle( axis, radians );
	
				}
	
			};
	
		}() );
	
		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();
	
			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();
	
		};
	
		ArrowHelper.prototype.setColor = function ( color ) {
	
			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );
	
		};
	
		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AxisHelper( size ) {
	
			size = size || 1;
	
			var vertices = new Float32Array( [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			] );
	
			var colors = new Float32Array( [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			] );
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;
	
		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */
	
		var CatmullRomCurve3 = ( function() {
	
			var
				tmp = new Vector3(),
				px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();
	
			/*
			Based on an optimized c++ solution in
			 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
			 - http://ideone.com/NoEbVM
	
			This CubicPoly class could be used for reusing some variables and calculations,
			but for three.js curve use, it could be possible inlined and flatten into a single function call
			which can be placed in CurveUtils.
			*/
	
			function CubicPoly() {}
	
			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {
	
				this.c0 = x0;
				this.c1 = t0;
				this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
			};
	
			CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;
	
				// initCubicPoly
				this.init( x1, x2, t1, t2 );
	
			};
	
			// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
			CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {
	
				this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
			};
	
			CubicPoly.prototype.calc = function( t ) {
	
				var t2 = t * t;
				var t3 = t2 * t;
				return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
	
			};
	
			// Subclass Three.js curve
			return Curve.create(
	
				function ( p /* array of Vector3 */ ) {
	
					this.points = p || [];
					this.closed = false;
	
				},
	
				function ( t ) {
	
					var points = this.points,
						point, intPoint, weight, l;
	
					l = points.length;
	
					if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
					point = ( l - ( this.closed ? 0 : 1 ) ) * t;
					intPoint = Math.floor( point );
					weight = point - intPoint;
	
					if ( this.closed ) {
	
						intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
					} else if ( weight === 0 && intPoint === l - 1 ) {
	
						intPoint = l - 2;
						weight = 1;
	
					}
	
					var p0, p1, p2, p3; // 4 points
	
					if ( this.closed || intPoint > 0 ) {
	
						p0 = points[ ( intPoint - 1 ) % l ];
	
					} else {
	
						// extrapolate first point
						tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
						p0 = tmp;
	
					}
	
					p1 = points[ intPoint % l ];
					p2 = points[ ( intPoint + 1 ) % l ];
	
					if ( this.closed || intPoint + 2 < l ) {
	
						p3 = points[ ( intPoint + 2 ) % l ];
	
					} else {
	
						// extrapolate last point
						tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
						p3 = tmp;
	
					}
	
					if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
						// init Centripetal / Chordal Catmull-Rom
						var pow = this.type === 'chordal' ? 0.5 : 0.25;
						var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
						var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
						var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
						// safety check for repeated points
						if ( dt1 < 1e-4 ) dt1 = 1.0;
						if ( dt0 < 1e-4 ) dt0 = dt1;
						if ( dt2 < 1e-4 ) dt2 = dt1;
	
						px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
						py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
						pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
					} else if ( this.type === 'catmullrom' ) {
	
						var tension = this.tension !== undefined ? this.tension : 0.5;
						px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
						py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
						pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
					}
	
					var v = new Vector3(
						px.calc( weight ),
						py.calc( weight ),
						pz.calc( weight )
					);
	
					return v;
	
				}
	
			);
	
		} )();
	
		/**************************************************************
		 *	Closed Spline 3D curve
		 **************************************************************/
	
	
		function ClosedSplineCurve3( points ) {
	
			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;
	
		}
	
		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		/**************************************************************
		 *	Spline 3D curve
		 **************************************************************/
	
	
		var SplineCurve3 = Curve.create(
	
			function ( points /* array of Vector3 */ ) {
	
				console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
				this.points = ( points === undefined ) ? [] : points;
	
			},
	
			function ( t ) {
	
				var points = this.points;
				var point = ( points.length - 1 ) * t;
	
				var intPoint = Math.floor( point );
				var weight = point - intPoint;
	
				var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
				var point1 = points[ intPoint ];
				var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
				var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
				var interpolate = CurveUtils.interpolate;
	
				return new Vector3(
					interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
					interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
					interpolate( point0.z, point1.z, point2.z, point3.z, weight )
				);
	
			}
	
		);
	
		/**************************************************************
		 *	Cubic Bezier 3D curve
		 **************************************************************/
	
		var CubicBezierCurve3 = Curve.create(
	
			function ( v0, v1, v2, v3 ) {
	
				this.v0 = v0;
				this.v1 = v1;
				this.v2 = v2;
				this.v3 = v3;
	
			},
	
			function ( t ) {
	
				var b3 = ShapeUtils.b3;
	
				return new Vector3(
					b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
					b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
					b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
				);
	
			}
	
		);
	
		/**************************************************************
		 *	Quadratic Bezier 3D curve
		 **************************************************************/
	
		var QuadraticBezierCurve3 = Curve.create(
	
			function ( v0, v1, v2 ) {
	
				this.v0 = v0;
				this.v1 = v1;
				this.v2 = v2;
	
			},
	
			function ( t ) {
	
				var b2 = ShapeUtils.b2;
	
				return new Vector3(
					b2( t, this.v0.x, this.v1.x, this.v2.x ),
					b2( t, this.v0.y, this.v1.y, this.v2.y ),
					b2( t, this.v0.z, this.v1.z, this.v2.z )
				);
	
			}
	
		);
	
		/**************************************************************
		 *	Line3D
		 **************************************************************/
	
		var LineCurve3 = Curve.create(
	
			function ( v1, v2 ) {
	
				this.v1 = v1;
				this.v2 = v2;
	
			},
	
			function ( t ) {
	
				if ( t === 1 ) {
	
					return this.v2.clone();
	
				}
	
				var vector = new Vector3();
	
				vector.subVectors( this.v2, this.v1 ); // diff
				vector.multiplyScalar( t );
				vector.add( this.v1 );
	
				return vector;
	
			}
	
		);
	
		/**************************************************************
		 *	Arc curve
		 **************************************************************/
	
		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		}
	
		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var SceneUtils = {
	
			createMultiMaterialObject: function ( geometry, materials ) {
	
				var group = new Group();
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					group.add( new Mesh( geometry, materials[ i ] ) );
	
				}
	
				return group;
	
			},
	
			detach: function ( child, parent, scene ) {
	
				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );
	
			},
	
			attach: function ( child, scene, parent ) {
	
				var matrixWorldInverse = new Matrix4();
				matrixWorldInverse.getInverse( parent.matrixWorld );
				child.applyMatrix( matrixWorldInverse );
	
				scene.remove( child );
				parent.add( child );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Face4 ( a, b, c, d, normal, color, materialIndex ) {
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );
		}
	
		var LineStrip = 0;
	
		var LinePieces = 1;
	
		function PointCloud ( geometry, material ) {
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );
		}
	
		function ParticleSystem ( geometry, material ) {
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );
		}
	
		function PointCloudMaterial ( parameters ) {
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}
	
		function ParticleBasicMaterial ( parameters ) {
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}
	
		function ParticleSystemMaterial ( parameters ) {
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}
	
		function Vertex ( x, y, z ) {
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );
		}
	
		//
	
		function EdgesHelper( object, hex ) {
			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
		}
	
		function WireframeHelper( object, hex ) {
			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
		}
	
		//
	
		Object.assign( Box2.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			},
			empty: function () {
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			},
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			size: function ( optionalTarget ) {
				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
			}
		} );
	
		Object.assign( Box3.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			},
			empty: function () {
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			},
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			isIntersectionSphere: function ( sphere ) {
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			},
			size: function ( optionalTarget ) {
				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
			}
		} );
	
		Object.assign( Line3.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			}
		} );
	
		Object.assign( Matrix3.prototype, {
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
			},
			multiplyVector3Array: function ( a ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		} );
	
		Object.assign( Matrix4.prototype, {
			extractPosition: function ( m ) {
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
			},
			setRotationFromQuaternion: function ( q ) {
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
			},
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
				return vector.applyProjection( this );
			},
			multiplyVector4: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			},
			multiplyVector3Array: function ( a ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			},
			rotateAxis: function ( v ) {
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
			},
			crossVector: function ( vector ) {
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			},
			translate: function ( v ) {
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
			},
			rotateX: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
			},
			rotateY: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
			},
			rotateZ: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
			},
			rotateByAxis: function ( axis, angle ) {
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
			}
		} );
	
		Object.assign( Plane.prototype, {
			isIntersectionLine: function ( line ) {
				console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
				return this.intersectsLine( line );
			}
		} );
	
		Object.assign( Quaternion.prototype, {
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
				return vector.applyQuaternion( this );
			}
		} );
	
		Object.assign( Ray.prototype, {
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			isIntersectionPlane: function ( plane ) {
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
			},
			isIntersectionSphere: function ( sphere ) {
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		} );
	
		Object.assign( Shape.prototype, {
			extrude: function ( options ) {
				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );
			},
			makeGeometry: function ( options ) {
				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );
			}
		} );
	
		Object.assign( Vector3.prototype, {
			setEulerFromRotationMatrix: function () {
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
			},
			setEulerFromQuaternion: function () {
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
			},
			getPositionFromMatrix: function ( m ) {
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
			},
			getScaleFromMatrix: function ( m ) {
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
			},
			getColumnFromMatrix: function ( index, matrix ) {
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );
			}
		} );
	
		//
	
		Object.assign( Object3D.prototype, {
			getChildByName: function ( name ) {
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
			},
			renderDepth: function ( value ) {
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
			},
			translate: function ( distance, axis ) {
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
			}
		} );
	
		Object.defineProperties( Object3D.prototype, {
			eulerOrder: {
				get: function () {
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;
				},
				set: function ( value ) {
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;
				}
			},
			useQuaternion: {
				get: function () {
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
				},
				set: function ( value ) {
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
				}
			}
		} );
	
		Object.defineProperties( LOD.prototype, {
			objects: {
				get: function () {
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
				}
			}
		} );
	
		//
	
		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	
			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );
	
			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );
	
		};
	
		//
	
		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .onlyShadow has been removed.' );
				}
			},
			shadowCameraFov: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;
				}
			},
			shadowCameraLeft: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;
				}
			},
			shadowCameraRight: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;
				}
			},
			shadowCameraTop: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;
				}
			},
			shadowCameraBottom: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;
				}
			},
			shadowCameraNear: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;
				}
			},
			shadowCameraFar: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;
				}
			},
			shadowCameraVisible: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
				}
			},
			shadowBias: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;
				}
			},
			shadowDarkness: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
				}
			},
			shadowMapWidth: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;
				}
			},
			shadowMapHeight: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;
				}
			}
		} );
	
		//
	
		Object.defineProperties( BufferAttribute.prototype, {
			length: {
				get: function () {
					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
					return this.array.length;
				}
			}
		} );
	
		Object.assign( BufferGeometry.prototype, {
			addIndex: function ( index ) {
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
			},
			addDrawCall: function ( start, count, indexOffset ) {
				if ( indexOffset !== undefined ) {
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
			},
			clearDrawCalls: function () {
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
			},
			computeTangents: function () {
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
			},
			computeOffsets: function () {
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
			}
		} );
	
		Object.defineProperties( BufferGeometry.prototype, {
			drawcalls: {
				get: function () {
					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;
				}
			},
			offsets: {
				get: function () {
					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;
				}
			}
		} );
	
		//
	
		Object.defineProperties( Material.prototype, {
			wrapAround: {
				get: function () {
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
				},
				set: function ( value ) {
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
				}
			},
			wrapRGB: {
				get: function () {
					console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
					return new Color();
				}
			}
		} );
	
		Object.defineProperties( MeshPhongMaterial.prototype, {
			metal: {
				get: function () {
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;
				},
				set: function ( value ) {
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
				}
			}
		} );
	
		Object.defineProperties( ShaderMaterial.prototype, {
			derivatives: {
				get: function () {
					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;
				},
				set: function ( value ) {
					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;
				}
			}
		} );
	
		//
	
		EventDispatcher.prototype = Object.assign( Object.create( {
	
			// Note: Extra base ensures these properties are not 'assign'ed.
	
			constructor: EventDispatcher,
	
			apply: function ( target ) {
	
				console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
						"just inherit or Object.assign the prototype to mix-in." );
	
				Object.assign( target, this );
	
			}
	
		} ), EventDispatcher.prototype );
	
		//
	
		Object.defineProperties( Uniform.prototype, {
			dynamic: {
				set: function ( value ) {
					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
				}
			},
			onUpdate: {
				value: function () {
					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;
				}
			}
		} );
	
		//
	
		Object.assign( WebGLRenderer.prototype, {
			supportsFloatTextures: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
			},
			supportsHalfFloatTextures: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
			},
			supportsStandardDerivatives: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
			},
			supportsCompressedTextureS3TC: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
			},
			supportsCompressedTexturePVRTC: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
			},
			supportsBlendMinMax: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
			},
			supportsVertexTextures: function () {
				return this.capabilities.vertexTextures;
			},
			supportsInstancedArrays: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
			},
			enableScissorTest: function ( boolean ) {
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
			},
			initMaterial: function () {
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
			},
			addPrePlugin: function () {
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
			},
			addPostPlugin: function () {
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
			},
			updateShadowMap: function () {
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
			}
		} );
	
		Object.defineProperties( WebGLRenderer.prototype, {
			shadowMapEnabled: {
				get: function () {
					return this.shadowMap.enabled;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;
				}
			},
			shadowMapType: {
				get: function () {
					return this.shadowMap.type;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;
				}
			},
			shadowMapCullFace: {
				get: function () {
					return this.shadowMap.cullFace;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;
				}
			}
		} );
	
		Object.defineProperties( WebGLShadowMap.prototype, {
			cullFace: {
				get: function () {
					return this.renderReverseSided ? CullFaceFront : CullFaceBack;
				},
				set: function ( cullFace ) {
					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;
				}
			}
		} );
	
		//
	
		Object.defineProperties( WebGLRenderTarget.prototype, {
			wrapS: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;
				}
			},
			wrapT: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;
				}
			},
			magFilter: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;
				}
			},
			minFilter: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;
				}
			},
			anisotropy: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;
				}
			},
			offset: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;
				}
			},
			repeat: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;
				}
			},
			format: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;
				}
			},
			type: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;
				}
			},
			generateMipmaps: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;
				}
			}
		} );
	
		//
	
		Object.assign( Audio.prototype, {
			load: function ( file ) {
				console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
				var scope = this;
				var audioLoader = new AudioLoader();
				audioLoader.load( file, function ( buffer ) {
					scope.setBuffer( buffer );
				} );
				return this;
			}
		} );
	
		Object.assign( AudioAnalyser.prototype, {
			getData: function ( file ) {
				console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
				return this.getFrequencyData();
			}
		} );
	
		//
	
		var GeometryUtils = {
	
			merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
	
				var matrix;
	
				if ( geometry2.isMesh ) {
	
					geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;
	
				}
	
				geometry1.merge( geometry2, matrix, materialIndexOffset );
	
			},
	
			center: function ( geometry ) {
	
				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();
	
			}
	
		};
	
		var ImageUtils = {
	
			crossOrigin: undefined,
	
			loadTexture: function ( url, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( url, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( urls, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadCompressedTexture: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
			},
	
			loadCompressedTextureCube: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
			}
	
		};
	
		//
	
		function Projector () {
	
			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
			this.projectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );
	
			};
	
			this.unprojectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );
	
			};
	
			this.pickingRay = function ( vector, camera ) {
	
				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
			};
	
		}
	
		//
	
		function CanvasRenderer () {
	
			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};
	
		}
	
		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.TextureIdCount = TextureIdCount;
		exports.Texture = Texture;
		exports.MaterialIdCount = MaterialIdCount;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.XHRLoader = XHRLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.getAudioContext = getAudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Float64Attribute = Float64Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Int8Attribute = Int8Attribute;
		exports.BufferAttribute = BufferAttribute;
		exports.Face3 = Face3;
		exports.Object3DIdCount = Object3DIdCount;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Spline = Spline;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.ColorKeywords = ColorKeywords;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.ShapePath = ShapePath;
		exports.Path = Path;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.CurveUtils = CurveUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.Material = Material;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.BlendingMode = BlendingMode;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.TextureMapping = TextureMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.TextureWrapping = TextureWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.TextureFilter = TextureFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MultiMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Sprite;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;
	
		Object.defineProperty(exports, '__esModule', { value: true });
	
		Object.defineProperty( exports, 'AudioContext', {
			get: function () {
				return exports.getAudioContext();
			}
		});
	
	})));


/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (THREE) {
	
	  /**
	   * @author mrdoob / http://mrdoob.com/
	   */
	  THREE.OBJLoader = function (manager) {
	
	    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;
	  };
	
	  THREE.OBJLoader.prototype = {
	
	    constructor: THREE.OBJLoader,
	
	    load: function load(url, onLoad, onProgress, onError) {
	
	      var scope = this;
	
	      var loader = new THREE.XHRLoader(scope.manager);
	      loader.load(url, function (text) {
	
	        onLoad(scope.parse(text));
	      }, onProgress, onError);
	    },
	
	    parse: function parse(text) {
	
	      console.time('OBJLoader');
	
	      var object,
	          objects = [];
	      var geometry, material;
	
	      function parseVertexIndex(value) {
	
	        var index = parseInt(value);
	
	        return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
	      }
	
	      function parseNormalIndex(value) {
	
	        var index = parseInt(value);
	
	        return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
	      }
	
	      function parseUVIndex(value) {
	
	        var index = parseInt(value);
	
	        return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
	      }
	
	      function addVertex(a, b, c) {
	
	        geometry.vertices.push(vertices[a], vertices[a + 1], vertices[a + 2], vertices[b], vertices[b + 1], vertices[b + 2], vertices[c], vertices[c + 1], vertices[c + 2]);
	      }
	
	      function addNormal(a, b, c) {
	
	        geometry.normals.push(normals[a], normals[a + 1], normals[a + 2], normals[b], normals[b + 1], normals[b + 2], normals[c], normals[c + 1], normals[c + 2]);
	      }
	
	      function addUV(a, b, c) {
	
	        geometry.uvs.push(uvs[a], uvs[a + 1], uvs[b], uvs[b + 1], uvs[c], uvs[c + 1]);
	      }
	
	      function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
	
	        var ia = parseVertexIndex(a);
	        var ib = parseVertexIndex(b);
	        var ic = parseVertexIndex(c);
	        var id;
	
	        if (d === undefined) {
	
	          addVertex(ia, ib, ic);
	        } else {
	
	          id = parseVertexIndex(d);
	
	          addVertex(ia, ib, id);
	          addVertex(ib, ic, id);
	        }
	
	        if (ua !== undefined) {
	
	          ia = parseUVIndex(ua);
	          ib = parseUVIndex(ub);
	          ic = parseUVIndex(uc);
	
	          if (d === undefined) {
	
	            addUV(ia, ib, ic);
	          } else {
	
	            id = parseUVIndex(ud);
	
	            addUV(ia, ib, id);
	            addUV(ib, ic, id);
	          }
	        }
	
	        if (na !== undefined) {
	
	          ia = parseNormalIndex(na);
	          ib = parseNormalIndex(nb);
	          ic = parseNormalIndex(nc);
	
	          if (d === undefined) {
	
	            addNormal(ia, ib, ic);
	          } else {
	
	            id = parseNormalIndex(nd);
	
	            addNormal(ia, ib, id);
	            addNormal(ib, ic, id);
	          }
	        }
	      }
	
	      // create mesh if no objects in text
	
	      if (/^o /gm.test(text) === false) {
	
	        geometry = {
	          vertices: [],
	          normals: [],
	          uvs: []
	        };
	
	        material = {
	          name: ''
	        };
	
	        object = {
	          name: '',
	          geometry: geometry,
	          material: material
	        };
	
	        objects.push(object);
	      }
	
	      var vertices = [];
	      var normals = [];
	      var uvs = [];
	
	      // v float float float
	
	      var vertex_pattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;
	
	      // vn float float float
	
	      var normal_pattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;
	
	      // vt float float
	
	      var uv_pattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;
	
	      // f vertex vertex vertex ...
	
	      var face_pattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;
	
	      // f vertex/uv vertex/uv vertex/uv ...
	
	      var face_pattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;
	
	      // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
	
	      var face_pattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;
	
	      // f vertex//normal vertex//normal vertex//normal ...
	
	      var face_pattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;
	
	      //
	
	      var lines = text.split('\n');
	
	      for (var i = 0; i < lines.length; i++) {
	
	        var line = lines[i];
	        line = line.trim();
	
	        var result;
	
	        if (line.length === 0 || line.charAt(0) === '#') {
	
	          continue;
	        } else if ((result = vertex_pattern.exec(line)) !== null) {
	
	          // ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
	          vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
	        } else if ((result = normal_pattern.exec(line)) !== null) {
	
	          // ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]
	
	          normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
	        } else if ((result = uv_pattern.exec(line)) !== null) {
	
	          // ["vt 0.1 0.2", "0.1", "0.2"]
	
	          uvs.push(parseFloat(result[1]), parseFloat(result[2]));
	        } else if ((result = face_pattern1.exec(line)) !== null) {
	
	          // ["f 1 2 3", "1", "2", "3", undefined]
	
	          addFace(result[1], result[2], result[3], result[4]);
	        } else if ((result = face_pattern2.exec(line)) !== null) {
	
	          // ["f 1/1 2/2 3/3", " 1/1", "1", "1", " 2/2", "2", "2", " 3/3", "3", "3", undefined, undefined, undefined]
	
	          addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
	        } else if ((result = face_pattern3.exec(line)) !== null) {
	
	          // ["f 1/1/1 2/2/2 3/3/3", " 1/1/1", "1", "1", "1", " 2/2/2", "2", "2", "2", " 3/3/3", "3", "3", "3", undefined, undefined, undefined, undefined]
	
	          addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
	        } else if ((result = face_pattern4.exec(line)) !== null) {
	
	          // ["f 1//1 2//2 3//3", " 1//1", "1", "1", " 2//2", "2", "2", " 3//3", "3", "3", undefined, undefined, undefined]
	
	          addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
	        } else if (/^o /.test(line)) {
	
	          geometry = {
	            vertices: [],
	            normals: [],
	            uvs: []
	          };
	
	          material = {
	            name: ''
	          };
	
	          object = {
	            name: line.substring(2).trim(),
	            geometry: geometry,
	            material: material
	          };
	
	          objects.push(object);
	        } else if (/^g /.test(line)) {
	
	          // group
	
	        } else if (/^usemtl /.test(line)) {
	
	            // material
	
	            material.name = line.substring(7).trim();
	          } else if (/^mtllib /.test(line)) {
	
	            // mtl file
	
	          } else if (/^s /.test(line)) {
	
	              // smooth shading
	
	            } else {
	
	                // console.log( "THREE.OBJLoader: Unhandled line " + line );
	
	              }
	      }
	
	      var container = new THREE.Object3D();
	      var l;
	
	      for (i = 0, l = objects.length; i < l; i++) {
	
	        object = objects[i];
	        geometry = object.geometry;
	
	        var buffergeometry = new THREE.BufferGeometry();
	
	        buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));
	
	        if (geometry.normals.length > 0) {
	
	          buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));
	        }
	
	        if (geometry.uvs.length > 0) {
	
	          buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));
	        }
	
	        material = new THREE.MeshLambertMaterial({
	          color: 0xff0000
	        });
	        material.name = object.material.name;
	
	        var mesh = new THREE.Mesh(buffergeometry, material);
	        mesh.name = object.name;
	
	        container.add(mesh);
	      }
	
	      console.timeEnd('OBJLoader');
	
	      return container;
	    }
	
	  };
	};

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = function( THREE ) {
		/**
		 * @author qiao / https://github.com/qiao
		 * @author mrdoob / http://mrdoob.com
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author erich666 / http://erichaines.com
		 */
	
	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finter swipe
	
		function OrbitControls( object, domElement ) {
	
			this.object = object;
	
			this.domElement = ( domElement !== undefined ) ? domElement : document;
	
			// Set to false to disable this control
			this.enabled = true;
	
			// "target" sets the location of focus, where the object orbits around
			this.target = new THREE.Vector3();
	
			// How far you can dolly in and out ( PerspectiveCamera only )
			this.minDistance = 0;
			this.maxDistance = Infinity;
	
			// How far you can zoom in and out ( OrthographicCamera only )
			this.minZoom = 0;
			this.maxZoom = Infinity;
	
			// How far you can orbit vertically, upper and lower limits.
			// Range is 0 to Math.PI radians.
			this.minPolarAngle = 0; // radians
			this.maxPolarAngle = Math.PI; // radians
	
			// How far you can orbit horizontally, upper and lower limits.
			// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
			this.minAzimuthAngle = - Infinity; // radians
			this.maxAzimuthAngle = Infinity; // radians
	
			// Set to true to enable damping (inertia)
			// If damping is enabled, you must call controls.update() in your animation loop
			this.enableDamping = false;
			this.dampingFactor = 0.25;
	
			// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
			// Set to false to disable zooming
			this.enableZoom = true;
			this.zoomSpeed = 1.0;
	
			// Set to false to disable rotating
			this.enableRotate = true;
			this.rotateSpeed = 1.0;
	
			// Set to false to disable panning
			this.enablePan = true;
			this.keyPanSpeed = 7.0;	// pixels moved per arrow key push
	
			// Set to true to automatically rotate around the target
			// If auto-rotate is enabled, you must call controls.update() in your animation loop
			this.autoRotate = false;
			this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
	
			// Set to false to disable use of the keys
			this.enableKeys = true;
	
			// The four arrow keys
			this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
	
			// Mouse buttons
			this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };
	
			// for reset
			this.target0 = this.target.clone();
			this.position0 = this.object.position.clone();
			this.zoom0 = this.object.zoom;
	
			//
			// public methods
			//
	
			this.getPolarAngle = function () {
	
				return spherical.phi;
	
			};
	
			this.getAzimuthalAngle = function () {
	
				return spherical.theta;
	
			};
	
			this.reset = function () {
	
				scope.target.copy( scope.target0 );
				scope.object.position.copy( scope.position0 );
				scope.object.zoom = scope.zoom0;
	
				scope.object.updateProjectionMatrix();
				scope.dispatchEvent( changeEvent );
	
				scope.update();
	
				state = STATE.NONE;
	
			};
	
			// this method is exposed, but perhaps it would be better if we can make it private...
			this.update = function() {
	
				var offset = new THREE.Vector3();
	
				// so camera.up is the orbit axis
				var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
				var quatInverse = quat.clone().inverse();
	
				var lastPosition = new THREE.Vector3();
				var lastQuaternion = new THREE.Quaternion();
	
				return function update () {
	
					var position = scope.object.position;
	
					offset.copy( position ).sub( scope.target );
	
					// rotate offset to "y-axis-is-up" space
					offset.applyQuaternion( quat );
	
					// angle from z-axis around y-axis
					spherical.setFromVector3( offset );
	
					if ( scope.autoRotate && state === STATE.NONE ) {
	
						rotateLeft( getAutoRotationAngle() );
	
					}
	
					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;
	
					// restrict theta to be between desired limits
					spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );
	
					// restrict phi to be between desired limits
					spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
	
					spherical.makeSafe();
	
	
					spherical.radius *= scale;
	
					// restrict radius to be between desired limits
					spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );
	
					// move target to panned location
					scope.target.add( panOffset );
	
					offset.setFromSpherical( spherical );
	
					// rotate offset back to "camera-up-vector-is-up" space
					offset.applyQuaternion( quatInverse );
	
					position.copy( scope.target ).add( offset );
	
					scope.object.lookAt( scope.target );
	
					if ( scope.enableDamping === true ) {
	
						sphericalDelta.theta *= ( 1 - scope.dampingFactor );
						sphericalDelta.phi *= ( 1 - scope.dampingFactor );
	
					} else {
	
						sphericalDelta.set( 0, 0, 0 );
	
					}
	
					scale = 1;
					panOffset.set( 0, 0, 0 );
	
					// update condition is:
					// min(camera displacement, camera rotation in radians)^2 > EPS
					// using small-angle approximation cos(x/2) = 1 - x^2 / 8
	
					if ( zoomChanged ||
						lastPosition.distanceToSquared( scope.object.position ) > EPS ||
						8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {
	
						scope.dispatchEvent( changeEvent );
	
						lastPosition.copy( scope.object.position );
						lastQuaternion.copy( scope.object.quaternion );
						zoomChanged = false;
	
						return true;
	
					}
	
					return false;
	
				};
	
			}();
	
			this.dispose = function() {
	
				scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
				scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
				scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );
	
				scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
				scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
				scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );
	
				document.removeEventListener( 'mousemove', onMouseMove, false );
				document.removeEventListener( 'mouseup', onMouseUp, false );
	
				window.removeEventListener( 'keydown', onKeyDown, false );
	
				//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	
			};
	
			//
			// internals
			//
	
			var scope = this;
	
			var changeEvent = { type: 'change' };
			var startEvent = { type: 'start' };
			var endEvent = { type: 'end' };
	
			var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };
	
			var state = STATE.NONE;
	
			var EPS = 0.000001;
	
			// current position in spherical coordinates
			var spherical = new THREE.Spherical();
			var sphericalDelta = new THREE.Spherical();
	
			var scale = 1;
			var panOffset = new THREE.Vector3();
			var zoomChanged = false;
	
			var rotateStart = new THREE.Vector2();
			var rotateEnd = new THREE.Vector2();
			var rotateDelta = new THREE.Vector2();
	
			var panStart = new THREE.Vector2();
			var panEnd = new THREE.Vector2();
			var panDelta = new THREE.Vector2();
	
			var dollyStart = new THREE.Vector2();
			var dollyEnd = new THREE.Vector2();
			var dollyDelta = new THREE.Vector2();
	
			function getAutoRotationAngle() {
	
				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
	
			}
	
			function getZoomScale() {
	
				return Math.pow( 0.95, scope.zoomSpeed );
	
			}
	
			function rotateLeft( angle ) {
	
				sphericalDelta.theta -= angle;
	
			}
	
			function rotateUp( angle ) {
	
				sphericalDelta.phi -= angle;
	
			}
	
			var panLeft = function() {
	
				var v = new THREE.Vector3();
	
				return function panLeft( distance, objectMatrix ) {
	
					v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
					v.multiplyScalar( - distance );
	
					panOffset.add( v );
	
				};
	
			}();
	
			var panUp = function() {
	
				var v = new THREE.Vector3();
	
				return function panUp( distance, objectMatrix ) {
	
					v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
					v.multiplyScalar( distance );
	
					panOffset.add( v );
	
				};
	
			}();
	
			// deltaX and deltaY are in pixels; right and down are positive
			var pan = function() {
	
				var offset = new THREE.Vector3();
	
				return function pan ( deltaX, deltaY ) {
	
					var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
	
					if ( scope.object instanceof THREE.PerspectiveCamera ) {
	
						// perspective
						var position = scope.object.position;
						offset.copy( position ).sub( scope.target );
						var targetDistance = offset.length();
	
						// half of the fov is center to top of screen
						targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );
	
						// we actually don't use screenWidth, since perspective camera is fixed to screen height
						panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
						panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );
	
					} else if ( scope.object instanceof THREE.OrthographicCamera ) {
	
						// orthographic
						panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
						panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );
	
					} else {
	
						// camera neither orthographic nor perspective
						console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
						scope.enablePan = false;
	
					}
	
				};
	
			}();
	
			function dollyIn( dollyScale ) {
	
				if ( scope.object instanceof THREE.PerspectiveCamera ) {
	
					scale /= dollyScale;
	
				} else if ( scope.object instanceof THREE.OrthographicCamera ) {
	
					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;
	
				} else {
	
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
					scope.enableZoom = false;
	
				}
	
			}
	
			function dollyOut( dollyScale ) {
	
				if ( scope.object instanceof THREE.PerspectiveCamera ) {
	
					scale *= dollyScale;
	
				} else if ( scope.object instanceof THREE.OrthographicCamera ) {
	
					scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
					scope.object.updateProjectionMatrix();
					zoomChanged = true;
	
				} else {
	
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
					scope.enableZoom = false;
	
				}
	
			}
	
			//
			// event callbacks - update the object state
			//
	
			function handleMouseDownRotate( event ) {
	
				//console.log( 'handleMouseDownRotate' );
	
				rotateStart.set( event.clientX, event.clientY );
	
			}
	
			function handleMouseDownDolly( event ) {
	
				//console.log( 'handleMouseDownDolly' );
	
				dollyStart.set( event.clientX, event.clientY );
	
			}
	
			function handleMouseDownPan( event ) {
	
				//console.log( 'handleMouseDownPan' );
	
				panStart.set( event.clientX, event.clientY );
	
			}
	
			function handleMouseMoveRotate( event ) {
	
				//console.log( 'handleMouseMoveRotate' );
	
				rotateEnd.set( event.clientX, event.clientY );
				rotateDelta.subVectors( rotateEnd, rotateStart );
	
				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
	
				// rotating across whole screen goes 360 degrees around
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
	
				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );
	
				rotateStart.copy( rotateEnd );
	
				scope.update();
	
			}
	
			function handleMouseMoveDolly( event ) {
	
				//console.log( 'handleMouseMoveDolly' );
	
				dollyEnd.set( event.clientX, event.clientY );
	
				dollyDelta.subVectors( dollyEnd, dollyStart );
	
				if ( dollyDelta.y > 0 ) {
	
					dollyIn( getZoomScale() );
	
				} else if ( dollyDelta.y < 0 ) {
	
					dollyOut( getZoomScale() );
	
				}
	
				dollyStart.copy( dollyEnd );
	
				scope.update();
	
			}
	
			function handleMouseMovePan( event ) {
	
				//console.log( 'handleMouseMovePan' );
	
				panEnd.set( event.clientX, event.clientY );
	
				panDelta.subVectors( panEnd, panStart );
	
				pan( panDelta.x, panDelta.y );
	
				panStart.copy( panEnd );
	
				scope.update();
	
			}
	
			function handleMouseUp( event ) {
	
				//console.log( 'handleMouseUp' );
	
			}
	
			function handleMouseWheel( event ) {
	
				//console.log( 'handleMouseWheel' );
	
				if ( event.deltaY < 0 ) {
	
					dollyOut( getZoomScale() );
	
				} else if ( event.deltaY > 0 ) {
	
					dollyIn( getZoomScale() );
	
				}
	
				scope.update();
	
			}
	
			function handleKeyDown( event ) {
	
				//console.log( 'handleKeyDown' );
	
				switch ( event.keyCode ) {
	
					case scope.keys.UP:
						pan( 0, scope.keyPanSpeed );
						scope.update();
						break;
	
					case scope.keys.BOTTOM:
						pan( 0, - scope.keyPanSpeed );
						scope.update();
						break;
	
					case scope.keys.LEFT:
						pan( scope.keyPanSpeed, 0 );
						scope.update();
						break;
	
					case scope.keys.RIGHT:
						pan( - scope.keyPanSpeed, 0 );
						scope.update();
						break;
	
				}
	
			}
	
			function handleTouchStartRotate( event ) {
	
				//console.log( 'handleTouchStartRotate' );
	
				rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	
			}
	
			function handleTouchStartDolly( event ) {
	
				//console.log( 'handleTouchStartDolly' );
	
				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	
				var distance = Math.sqrt( dx * dx + dy * dy );
	
				dollyStart.set( 0, distance );
	
			}
	
			function handleTouchStartPan( event ) {
	
				//console.log( 'handleTouchStartPan' );
	
				panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	
			}
	
			function handleTouchMoveRotate( event ) {
	
				//console.log( 'handleTouchMoveRotate' );
	
				rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				rotateDelta.subVectors( rotateEnd, rotateStart );
	
				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
	
				// rotating across whole screen goes 360 degrees around
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
	
				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );
	
				rotateStart.copy( rotateEnd );
	
				scope.update();
	
			}
	
			function handleTouchMoveDolly( event ) {
	
				//console.log( 'handleTouchMoveDolly' );
	
				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
	
				var distance = Math.sqrt( dx * dx + dy * dy );
	
				dollyEnd.set( 0, distance );
	
				dollyDelta.subVectors( dollyEnd, dollyStart );
	
				if ( dollyDelta.y > 0 ) {
	
					dollyOut( getZoomScale() );
	
				} else if ( dollyDelta.y < 0 ) {
	
					dollyIn( getZoomScale() );
	
				}
	
				dollyStart.copy( dollyEnd );
	
				scope.update();
	
			}
	
			function handleTouchMovePan( event ) {
	
				//console.log( 'handleTouchMovePan' );
	
				panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
	
				panDelta.subVectors( panEnd, panStart );
	
				pan( panDelta.x, panDelta.y );
	
				panStart.copy( panEnd );
	
				scope.update();
	
			}
	
			function handleTouchEnd( event ) {
	
				//console.log( 'handleTouchEnd' );
	
			}
	
			//
			// event handlers - FSM: listen for events and reset state
			//
	
			function onMouseDown( event ) {
	
				if ( scope.enabled === false ) return;
	
				event.preventDefault();
	
				if ( event.button === scope.mouseButtons.ORBIT ) {
	
					if ( scope.enableRotate === false ) return;
	
					handleMouseDownRotate( event );
	
					state = STATE.ROTATE;
	
				} else if ( event.button === scope.mouseButtons.ZOOM ) {
	
					if ( scope.enableZoom === false ) return;
	
					handleMouseDownDolly( event );
	
					state = STATE.DOLLY;
	
				} else if ( event.button === scope.mouseButtons.PAN ) {
	
					if ( scope.enablePan === false ) return;
	
					handleMouseDownPan( event );
	
					state = STATE.PAN;
	
				}
	
				if ( state !== STATE.NONE ) {
	
					document.addEventListener( 'mousemove', onMouseMove, false );
					document.addEventListener( 'mouseup', onMouseUp, false );
	
					scope.dispatchEvent( startEvent );
	
				}
	
			}
	
			function onMouseMove( event ) {
	
				if ( scope.enabled === false ) return;
	
				event.preventDefault();
	
				if ( state === STATE.ROTATE ) {
	
					if ( scope.enableRotate === false ) return;
	
					handleMouseMoveRotate( event );
	
				} else if ( state === STATE.DOLLY ) {
	
					if ( scope.enableZoom === false ) return;
	
					handleMouseMoveDolly( event );
	
				} else if ( state === STATE.PAN ) {
	
					if ( scope.enablePan === false ) return;
	
					handleMouseMovePan( event );
	
				}
	
			}
	
			function onMouseUp( event ) {
	
				if ( scope.enabled === false ) return;
	
				handleMouseUp( event );
	
				document.removeEventListener( 'mousemove', onMouseMove, false );
				document.removeEventListener( 'mouseup', onMouseUp, false );
	
				scope.dispatchEvent( endEvent );
	
				state = STATE.NONE;
	
			}
	
			function onMouseWheel( event ) {
	
				if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;
	
				event.preventDefault();
				event.stopPropagation();
	
				handleMouseWheel( event );
	
				scope.dispatchEvent( startEvent ); // not sure why these are here...
				scope.dispatchEvent( endEvent );
	
			}
	
			function onKeyDown( event ) {
	
				if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;
	
				handleKeyDown( event );
	
			}
	
			function onTouchStart( event ) {
	
				if ( scope.enabled === false ) return;
	
				switch ( event.touches.length ) {
	
					case 1:	// one-fingered touch: rotate
	
						if ( scope.enableRotate === false ) return;
	
						handleTouchStartRotate( event );
	
						state = STATE.TOUCH_ROTATE;
	
						break;
	
					case 2:	// two-fingered touch: dolly
	
						if ( scope.enableZoom === false ) return;
	
						handleTouchStartDolly( event );
	
						state = STATE.TOUCH_DOLLY;
	
						break;
	
					case 3: // three-fingered touch: pan
	
						if ( scope.enablePan === false ) return;
	
						handleTouchStartPan( event );
	
						state = STATE.TOUCH_PAN;
	
						break;
	
					default:
	
						state = STATE.NONE;
	
				}
	
				if ( state !== STATE.NONE ) {
	
					scope.dispatchEvent( startEvent );
	
				}
	
			}
	
			function onTouchMove( event ) {
	
				if ( scope.enabled === false ) return;
	
				event.preventDefault();
				event.stopPropagation();
	
				switch ( event.touches.length ) {
	
					case 1: // one-fingered touch: rotate
	
						if ( scope.enableRotate === false ) return;
						if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...
	
						handleTouchMoveRotate( event );
	
						break;
	
					case 2: // two-fingered touch: dolly
	
						if ( scope.enableZoom === false ) return;
						if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...
	
						handleTouchMoveDolly( event );
	
						break;
	
					case 3: // three-fingered touch: pan
	
						if ( scope.enablePan === false ) return;
						if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...
	
						handleTouchMovePan( event );
	
						break;
	
					default:
	
						state = STATE.NONE;
	
				}
	
			}
	
			function onTouchEnd( event ) {
	
				if ( scope.enabled === false ) return;
	
				handleTouchEnd( event );
	
				scope.dispatchEvent( endEvent );
	
				state = STATE.NONE;
	
			}
	
			function onContextMenu( event ) {
	
				event.preventDefault();
	
			}
	
			//
	
			scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );
	
			scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
			scope.domElement.addEventListener( 'wheel', onMouseWheel, false );
	
			scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
			scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
			scope.domElement.addEventListener( 'touchmove', onTouchMove, false );
	
			window.addEventListener( 'keydown', onKeyDown, false );
	
			// force an update at start
	
			this.update();
	
		};
	
		OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
		OrbitControls.prototype.constructor = OrbitControls;
	
		Object.defineProperties( OrbitControls.prototype, {
	
			center: {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
					return this.target;
	
				}
	
			},
	
			// backward compatibility
	
			noZoom: {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
					return ! this.enableZoom;
	
				},
	
				set: function ( value ) {
	
					console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
					this.enableZoom = ! value;
	
				}
	
			},
	
			noRotate: {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
					return ! this.enableRotate;
	
				},
	
				set: function ( value ) {
	
					console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
					this.enableRotate = ! value;
	
				}
	
			},
	
			noPan: {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
					return ! this.enablePan;
	
				},
	
				set: function ( value ) {
	
					console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
					this.enablePan = ! value;
	
				}
	
			},
	
			noKeys: {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
					return ! this.enableKeys;
	
				},
	
				set: function ( value ) {
	
					console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
					this.enableKeys = ! value;
	
				}
	
			},
	
			staticMoving : {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
					return ! this.enableDamping;
	
				},
	
				set: function ( value ) {
	
					console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
					this.enableDamping = ! value;
	
				}
	
			},
	
			dynamicDampingFactor : {
	
				get: function () {
	
					console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
					return this.dampingFactor;
	
				},
	
				set: function ( value ) {
	
					console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
					this.dampingFactor = value;
	
				}
	
			}
	
		} );
	
		return OrbitControls;
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	
	var World = function () {
	    function World(scene, timer, baseMesh, position) {
	        _classCallCheck(this, World);
	
	        this.position = position;
	        this.scene = scene;
	        this.timer = timer;
	        this.assets = [];
	        this.baseMesh = baseMesh;
	        this.displayed = false;
	        this.rotateSpeed = Math.PI / 200;
	        // this.pivot = new THREE.Group();
	        // scene.add( this.pivot );
	        // 
	        // this.pivot.add( this.baseMesh );
	        // this.baseMesh.position.set( -this.position.x, -this.position.y, -this.position.z); // the negative of the group's center
	        //this.setMeshPosition(this.baseMesh, this.position.x, this.position.y, this.position.z);
	    }
	
	    _createClass(World, [{
	        key: 'toggleDisplay',
	        value: function toggleDisplay(displayed) {
	            if (!this.displayed && displayed) {
	                this.scene.add(this.baseMesh);
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].show();
	                }
	            } else if (this.displayed && !displayed) {
	                this.scene.remove(this.baseMesh);
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].hide();
	                }
	            }
	            this.displayed = displayed;
	        }
	
	        // easy getter for vertex list
	
	    }, {
	        key: 'worldVertices',
	        value: function worldVertices() {
	            return this.baseMesh.geometry.vertices;
	        }
	
	        // easy getter for face list
	
	    }, {
	        key: 'worldFaces',
	        value: function worldFaces() {
	            return this.baseMesh.geometry.faces;
	        }
	    }, {
	        key: 'spinIndefinitely',
	        value: function spinIndefinitely(speed) {
	            this.baseMesh.rotation.y = speed;
	            this.baseMesh.updateMatrix();
	            this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	
	            for (var i = 0; i < this.assets.length; i++) {
	                var asset = this.assets[i];
	                asset.setPosition(asset.vertex);
	                this.baseMesh.geometry.computeFaceNormals();
	                this.baseMesh.geometry.computeVertexNormals();
	                asset.alignItemsWithNormal();
	            }
	        }
	        // world animation options 
	
	    }, {
	        key: 'spin',
	        value: function spin(tStart, tEnd, speed) {
	            // Spin the world  
	            if (this.timer.elapsedTime >= tStart && this.timer.elapsedTime < tEnd) {
	                this.baseMesh.rotation.y = speed;
	                this.baseMesh.updateMatrix();
	                this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	
	                for (var i = 0; i < this.assets.length; i++) {
	                    var asset = this.assets[i];
	                    asset.setPosition(asset.vertex);
	                    this.baseMesh.geometry.computeFaceNormals();
	                    this.baseMesh.geometry.computeVertexNormals();
	                    asset.alignItemsWithNormal();
	                }
	            }
	        }
	    }, {
	        key: 'spinAccelerate',
	        value: function spinAccelerate(tStart, tEnd, speed) {
	            if (this.timer.elapsedTime >= tStart && this.timer.elapsedTime < tEnd) {
	                this.baseMesh.rotation.y += speed;
	                this.baseMesh.updateMatrix();
	                this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	
	                for (var i = 0; i < this.assets.length; i++) {
	                    var asset = this.assets[i];
	                    asset.setPosition(asset.vertex);
	                    this.baseMesh.geometry.computeFaceNormals();
	                    this.baseMesh.geometry.computeVertexNormals();
	                    asset.alignItemsWithNormal();
	                }
	            }
	        }
	    }, {
	        key: 'spinDeccelerate',
	        value: function spinDeccelerate(tStart, tEnd, speed) {
	            if (this.timer.elapsedTime >= tStart && this.timer.elapsedTime < tEnd) {
	                this.baseMesh.rotation.y -= speed;
	                this.baseMesh.updateMatrix();
	                this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	
	                for (var i = 0; i < this.assets.length; i++) {
	                    var asset = this.assets[i];
	                    asset.setPosition(asset.vertex);
	                    this.baseMesh.geometry.computeFaceNormals();
	                    this.baseMesh.geometry.computeVertexNormals();
	                    asset.alignItemsWithNormal();
	                }
	            }
	        }
	
	        // spawn asset at random vertex (adds to scene) and adds to the global list of assets
	
	    }, {
	        key: 'spawnAsset',
	        value: function spawnAsset(asset) {
	            var vertices = this.worldVertices();
	            var faces = this.worldFaces();
	
	            // get vertex from idx stored in face
	            var faceIdx = Math.max(0, Math.min(Math.floor(Math.random() * faces.length), faces.length - 1));
	            var vIdx = Math.max(0, Math.min(Math.floor(Math.random() * 3), 2));
	
	            var face = faces[faceIdx];
	
	            var arr = ['a', 'b', 'c'];
	            var char = arr[vIdx];
	
	            var vertex = vertices[face[char]];
	            asset.vertex = vertex;
	
	            // add asset to a random point on the sphere
	            this.addAsset(asset, vertex);
	
	            // assign normal
	
	            asset.faceIdx = faceIdx;
	            asset.vIdx = vIdx;
	            asset.normal = this.getNormal(asset);
	            asset.alignItemsWithNormal();
	        }
	    }, {
	        key: 'getNormal',
	        value: function getNormal(asset) {
	            var faces = this.worldFaces();
	            return faces[asset.faceIdx].vertexNormals[asset.vIdx];
	        }
	
	        // adds assets to global list and adds their geometry to the scene
	
	    }, {
	        key: 'addAsset',
	        value: function addAsset(asset, position) {
	            this.assets.push(asset);
	            asset.setPosition(position);
	        }
	
	        // update shader times
	
	    }, {
	        key: 'updateShaderUniforms',
	        value: function updateShaderUniforms() {
	            this.baseMesh.material.uniforms;
	            if (this.baseMesh.material.uniforms !== undefined) {
	                this.baseMesh.material.uniforms.time.value = this.timer.elapsedTime;
	            }
	            for (var i = 0; i < this.assets.length; i++) {
	                this.assets[i].updateShaderUniforms();
	            }
	        }
	    }, {
	        key: 'resetTransform',
	        value: function resetTransform(mesh) {
	            mesh.updateMatrix();
	            mesh.geometry.applyMatrix(mesh.matrix);
	            // mesh.position.set( this.position.x, this.position.y, this.position.z );
	            // mesh.rotation.set( 0, 0, 0 );
	            // mesh.scale.set( 1, 1, 1 );
	            // mesh.updateMatrix();
	        }
	    }, {
	        key: 'setMeshPosition',
	        value: function setMeshPosition(mesh, x, y, z) {
	            mesh.position.set(x, y, z);
	            this.resetTransform(mesh);
	        }
	
	        // update assets
	
	    }, {
	        key: 'tick',
	        value: function tick() {
	            if (this.displayed) {
	                this.spinIndefinitely(this.rotateSpeed);
	                this.updateShaderUniforms();
	                // assets tick
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].tick();
	                }
	            }
	        }
	    }]);
	
	    return World;
	}();
	
	exports.default = World;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _item = __webpack_require__(11);
	
	var _item2 = _interopRequireDefault(_item);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var THREE = __webpack_require__(6);
	
	// this class will be overridden very frequently for the various assets.
	var Asset = function () {
	  function Asset(scene, timer, world) {
	    _classCallCheck(this, Asset);
	
	    // name for debugging purposes
	    this.name = "";
	    this.scene = scene;
	    this.timer = timer;
	    this.items = [];
	    this.world = world;
	    this.rotation = new THREE.Vector3(0, 0, 0);
	    this.position = new THREE.Vector3(0, 1, 0);
	    this.scale = new THREE.Vector3(1, 1, 1);
	    this.up = new THREE.Vector3(0, 1, 0);
	    this.up.applyEuler(new THREE.Euler(this.rotation.x, this.rotation.y, this.rotation.z, 'XYZ'));
	
	    // stores vertex and normal for access
	    this.vertex;
	    this.normal;
	
	    this.faceIdx;
	    this.vIdx;
	  }
	
	  // adds all item meshes
	
	
	  _createClass(Asset, [{
	    key: 'show',
	    value: function show() {
	      for (var i = 0; i < this.items.length; i++) {
	        this.scene.add(this.items[i].mesh);
	        if (this.items[i].mesh.material.uniforms) {
	          if (this.items[i].mesh.material.uniforms.alpha) {
	            this.items[i].mesh.material.uniforms.alpha.value = 0.9;
	          }
	        }
	      }
	    }
	
	    // remove all meshes (in an optional timed interval)
	
	  }, {
	    key: 'hide',
	    value: function hide() {
	      for (var i = 0; i < this.items.length; i++) {
	        this.scene.remove(this.items[i].mesh);
	        if (this.items[i].mesh.material.uniforms) {
	          if (this.items[i].mesh.material.uniforms.alpha) {
	            this.items[i].mesh.material.uniforms.alpha.value = 0.0;
	          }
	        }
	      }
	    }
	
	    // sets the overall asset position and moves the items accordingly
	
	  }, {
	    key: 'setPosition',
	    value: function setPosition(position) {
	      this.position = position;
	      this.updatePositions();
	    }
	
	    // allows the individual meshes to have their own offsets, updates them
	
	  }, {
	    key: 'updatePositions',
	    value: function updatePositions() {
	      for (var i = 0; i < this.items.length; i++) {
	        this.items[i].setWorldPosition(this.position);
	      }
	    }
	
	    // sets the overall asset position and moves the items accordingly
	
	  }, {
	    key: 'setScale',
	    value: function setScale(scale) {
	      this.scale = new THREE.Vector3(scale, scale, scale);
	      this.updateScales();
	    }
	
	    // allows the individual meshes to have their own offsets, updates them
	
	  }, {
	    key: 'updateScales',
	    value: function updateScales() {
	      for (var i = 0; i < this.items.length; i++) {
	        this.items[i].setWorldScale(this.scale);
	      }
	    }
	
	    // sets the overall asset rotation
	
	  }, {
	    key: 'setRotation',
	    value: function setRotation(rotation) {
	      this.rotation = rotation;
	      var x = this.localRotation.x * (Math.PI / 180);
	      var y = this.localRotation.y * (Math.PI / 180);
	      var z = this.localRotation.z * (Math.PI / 180);
	      this.up.applyEuler(new THREE.Vector3(x, y, z));
	      this.updateRotations();
	    }
	
	    // allows the individual meshes to have their own offsets, updates them
	
	  }, {
	    key: 'updateRotations',
	    value: function updateRotations() {
	      for (var i = 0; i < this.items.length; i++) {
	        this.items[i].align(this.up, this.normal);
	      }
	    }
	
	    // aligns items with the normals
	
	  }, {
	    key: 'alignItemsWithNormal',
	    value: function alignItemsWithNormal() {
	      this.updateRotations();
	      //this.up = this.normal;
	    }
	
	    // updates the time for the shaders for the item meshes
	
	  }, {
	    key: 'updateShaderUniforms',
	    value: function updateShaderUniforms() {
	      for (var i = 0; i < this.items.length; i++) {
	        var shader = this.items[i].mesh.material;
	
	        if (shader.uniforms !== undefined) {
	          if (shader.uniforms.time !== undefined) {
	            shader.uniforms.time.value = this.timer.elapsedTime;
	          }
	        }
	      }
	    }
	
	    // can override / update this function for each asset
	
	  }, {
	    key: 'tick',
	    value: function tick() {
	      this.updatePositions();
	      this.updateShaderUniforms();
	    }
	  }]);
	
	  return Asset;
	}();
	
	exports.default = Asset;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var THREE = __webpack_require__(6);
	
	var Item = function () {
		function Item(mesh) {
			_classCallCheck(this, Item);
	
			this.name = "";
			this.mesh = mesh;
			this.localScale = new THREE.Vector3(1, 1, 1);
			this.localPosition = new THREE.Vector3(0, 0, 0);
	
			// this is in degrees
			this.localRotation = new THREE.Vector3(0, 0, 0);
		}
	
		// update the mesh's main position to be that of the assets and adds local displacement
	
	
		_createClass(Item, [{
			key: 'setWorldPosition',
			value: function setWorldPosition(position) {
				this.mesh.position.x = position.x + this.localPosition.x;
				this.mesh.position.y = position.y + this.localPosition.y;
				this.mesh.position.z = position.z + this.localPosition.z;
			}
	
			// aligns the mesh with the vector specified (usually with the normal)
			// will have to call align every time local rotation is changed, does the actual rotation
	
		}, {
			key: 'align',
			value: function align(axis, vector) {
				var v = vector.clone();
				var x = this.localRotation.x * (Math.PI / 180);
				var y = this.localRotation.y * (Math.PI / 180);
				var z = this.localRotation.z * (Math.PI / 180);
				v.applyEuler(new THREE.Euler(x, y, z, 'XYZ'));
				this.mesh.quaternion.setFromUnitVectors(axis, v.clone().normalize());
			}
	
			// update the mesh's main scale to be that of the assets and adds local scale
	
		}, {
			key: 'setWorldScale',
			value: function setWorldScale(scale) {
				this.mesh.scale.x = scale.x * this.localScale.x;
				this.mesh.scale.y = scale.y * this.localScale.y;
				this.mesh.scale.z = scale.z * this.localScale.z;
			}
		}]);
	
		return Item;
	}();
	
	exports.default = Item;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _cubes = __webpack_require__(13);
	
	var _cubes2 = _interopRequireDefault(_cubes);
	
	var _world = __webpack_require__(9);
	
	var _world2 = _interopRequireDefault(_world);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var BasicWorld = function (_World) {
	    _inherits(BasicWorld, _World);
	
	    function BasicWorld(scene, timer, light) {
	        _classCallCheck(this, BasicWorld);
	
	        // initialize example uniform variables and store in list
	        var shaderUniforms = {
	            time: {
	                type: "float",
	                value: 0
	            },
	            color: {
	                type: "v4",
	                value: new THREE.Vector4(1., 1., 1., 1.)
	            },
	            light_vec: {
	                type: "v3",
	                value: new THREE.Vector3(light.position.x, light.position.y, light.position.z)
	            }
	        };
	
	        // initialize example shader and mesh
	        var material = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(16),
	            fragmentShader: __webpack_require__(17)
	        });
	
	        var geometry = new THREE.IcosahedronGeometry(6, 3);
	        var baseMesh = new THREE.Mesh(geometry, material);
	
	        var _this = _possibleConstructorReturn(this, (BasicWorld.__proto__ || Object.getPrototypeOf(BasicWorld)).call(this, scene, timer, baseMesh));
	
	        for (var i = 0; i < 30; i++) {
	            _this.spawnAsset(new _cubes2.default(scene, timer, _this));
	        }
	        return _this;
	    }
	
	    return BasicWorld;
	}(_world2.default);
	
	exports.default = BasicWorld;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _item = __webpack_require__(11);
	
	var _item2 = _interopRequireDefault(_item);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var Cubes = function (_Asset) {
	    _inherits(Cubes, _Asset);
	
	    function Cubes(scene, timer, world) {
	        _classCallCheck(this, Cubes);
	
	        // add basic cube mesh item as example asset
	        var _this = _possibleConstructorReturn(this, (Cubes.__proto__ || Object.getPrototypeOf(Cubes)).call(this, scene, timer, world));
	
	        _this.shaderUniforms = {
	            time: {
	                type: "float",
	                value: 0
	            },
	            color: {
	                type: "v4",
	                value: new THREE.Vector4(1., 0., 0., 1.)
	            }
	        };
	
	        var material = new THREE.ShaderMaterial({
	            uniforms: _this.shaderUniforms,
	            vertexShader: __webpack_require__(14),
	            fragmentShader: __webpack_require__(15)
	        });
	
	        // var material2 = new THREE.MeshLamb ertMaterial({color: 0xfffff} ); 
	
	        var geometry = new THREE.BoxGeometry(1, 1, 1);
	        var mesh = new THREE.Mesh(geometry, material);
	
	        var redCube = new _item2.default(mesh);
	
	        // The asset class must have a normal and a vertex assigned before alignment can occur
	        // Make sure to call updateRotations from the asset class to update the item rotations
	        redCube.localRotation = new THREE.Vector3(45, 45, 0);
	
	        _this.items.push(redCube);
	        return _this;
	    }
	
	    return Cubes;
	}(_asset2.default);
	
	exports.default = Cubes;

/***/ },
/* 14 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_position; \nvarying vec3 f_normal; \n\nvoid main() {\n    vUv = uv;\n    f_normal = normal;\n    f_position = position;     \n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying float noise;\nuniform sampler2D image;\n\n\nvoid main() {\n\n  vec2 uv = vec2(1,1) - vUv;\n  vec4 color = texture2D( image, uv );\n\n  gl_FragColor = vec4( color.rgb, 1.0 );\n\n}"

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_normal; \nvarying vec3 f_position;\n\nvoid main() {\n    vUv = uv;\n    f_normal = normal;\n    f_position = position; \n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying float noise;\nuniform sampler2D image;\nvarying vec3 f_normal; \nvarying vec3 f_position;\nuniform vec3 light_vec; \n\nvoid main() {\n  vec2 uv = vec2(1,1) - vUv;\n  vec4 color = texture2D( image, uv );\n\n  // simple lambertian lighting\n  vec3 d = normalize(light_vec - f_position);\n  float lambert = clamp(dot(d, f_normal), 0.0, 1.0); \n  float globalIllum = 0.2; \n  gl_FragColor = vec4( lambert * color.rgb, 1.0) + globalIllum * vec4(color.rgb, 1);\n}"

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _world = __webpack_require__(9);
	
	var _world2 = _interopRequireDefault(_world);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var CameraControls = function () {
		function CameraControls(scene, timer, camera) {
			_classCallCheck(this, CameraControls);
	
			this.scene = scene;
			this.timer = timer;
			this.camera = camera;
			this.focusPoints = [];
		}
	
		_createClass(CameraControls, [{
			key: 'simplePanX',
			value: function simplePanX(timeStart, timeEnd) {
				// pan .. todo, fix it 
				var targetX = focusPoints[planetIndex].x;
				var targetY = focusPoints[planetIndex].y;
				var targetZ = focusPoints[planetIndex].z;
	
				if (this.timer.elapsedTime > timeStart && this.timer.elapsedTime < timeEnd) {
					this.camera.position.set(this.camera.position.x + .1, 1, 20);
					this.camera.lookAt(new THREE.Vector3(targetX, targetY, targetZ));
					this.camera.updateProjectionMatrix();
				}
			}
	
			// zoom into the x direction 
	
		}, {
			key: 'zoomInZ',
			value: function zoomInZ(timeStart, timeEnd, target) {
				var totalTime = timeEnd - timeStart;
				if (this.timer.elapsedTime > timeStart && this.timer.elapsedTime < timeEnd) {
					if (this.camera.position.z > target) {
						this.camera.position.set(this.camera.position.x, this.camera.position.y, this.camera.position.z - 0.3);
						this.camera.lookAt(new THREE.Vector3(this.camera.position.x, this.camera.position.y, this.camera.position.z - 20));
						this.camera.updateProjectionMatrix();
					}
				}
			}
		}, {
			key: 'zoom',
			value: function zoom(timeStart, timeEnd, originalPos, target) {
				// zoom out 
				if (this.timer.elapsedTime > timeStart && this.timer.elapsedTime < timeEnd) {
					this.timer.getDelta();
					var t = (this.timer.elapsedTime - timeStart) / (timeEnd - timeStart);
					var delta = t * target + (1 - t) * originalPos;
					this.camera.position.set(this.camera.position.x, this.camera.position.y, delta);
					this.camera.lookAt(new THREE.Vector3(this.camera.position.x, this.camera.position.y, this.camera.position.z - 20));
					this.camera.updateProjectionMatrix();
					return true;
				}
				return false;
			}
		}, {
			key: 'zoomOutZ',
			value: function zoomOutZ(timeStart, timeEnd, originalPos, target) {
				// zoom out 
				if (this.timer.elapsedTime > timeStart && this.timer.elapsedTime < timeEnd) {
					if (this.camera.position.z <= target) {
						this.timer.getDelta();
						var t = (this.timer.elapsedTime - timeStart) / (timeEnd - timeStart);
						var delta = t * target + (1 - t) * originalPos;
						this.camera.position.set(this.camera.position.x, this.camera.position.y, delta);
						this.camera.lookAt(new THREE.Vector3(this.camera.position.x, this.camera.position.y, this.camera.position.z - 20));
						this.camera.updateProjectionMatrix();
					}
				}
			}
		}]);
	
		return CameraControls;
	}();
	
	exports.default = CameraControls;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _flower = __webpack_require__(20);
	
	var _flower2 = _interopRequireDefault(_flower);
	
	var _world = __webpack_require__(9);
	
	var _world2 = _interopRequireDefault(_world);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var FlowerWorld = function (_World) {
	    _inherits(FlowerWorld, _World);
	
	    function FlowerWorld(scene, timer, light, position) {
	        _classCallCheck(this, FlowerWorld);
	
	        // initialize example uniform variables and store in list
	        var shaderUniforms = {
	            time: {
	                type: "float",
	                value: 0
	            },
	            color: {
	                type: "v4",
	                value: new THREE.Vector4(1., 1., 1., 1.)
	            },
	            image: { // Check the Three.JS documentation for the different allowed types and values
	                type: "t",
	                value: THREE.ImageUtils.loadTexture('./textures/grass.jpg')
	            },
	            light_vec: {
	                type: "v3",
	                value: new THREE.Vector3(light.position.x, light.position.y, light.position.z)
	            }
	        };
	
	        // initialize example shader and mesh
	        var material = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(16),
	            fragmentShader: __webpack_require__(17)
	        });
	        material.side = THREE.DoubleSide;
	
	        var geometry = new THREE.IcosahedronGeometry(4, 1);
	        var baseMesh = new THREE.Mesh(geometry, material);
	
	        var _this = _possibleConstructorReturn(this, (FlowerWorld.__proto__ || Object.getPrototypeOf(FlowerWorld)).call(this, scene, timer, baseMesh, position));
	
	        _this.setMeshPosition(baseMesh, _this.position.x, _this.position.y, _this.position.z);
	
	        for (var i = 0; i < 10; i++) {
	            _this.spawnAsset(new _flower2.default(scene, timer, _this));
	        }
	        return _this;
	    }
	
	    _createClass(FlowerWorld, [{
	        key: 'animateAsset',
	        value: function animateAsset(asset, spinningSpeed) {
	            var vertices = this.worldVertices();
	
	            var pos = asset.vertex;
	            //pos.addVectors(asset.vertex, asset.normal.clone().multiplyScalar(this.normalOffset));
	
	            var up = asset.normal.clone();
	            var newPos = new THREE.Vector3();
	            //newPos.addVectors ( pos, up.multiplyScalar(this.musicData[this.k] / 70) );
	            asset.setScale(this.musicData[this.k] / 200);
	            if (this.k < this.musicData.length) {
	                this.k++;
	            }
	            asset.position = pos;
	            asset.updatePositions();
	        }
	    }, {
	        key: 'spinIndefinitely',
	        value: function spinIndefinitely(speed) {
	            this.baseMesh.rotation.y = speed;
	            this.baseMesh.updateMatrix();
	            this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	            var bufferLength = this.analyser.frequencyBinCount;
	            this.musicData = new Uint8Array(bufferLength);
	            this.analyser.getByteFrequencyData(this.musicData);
	
	            for (var i = 0; i < this.assets.length; i++) {
	                var asset = this.assets[i];
	                this.animateAsset(asset, speed);
	                this.baseMesh.geometry.computeFaceNormals();
	                this.baseMesh.geometry.computeVertexNormals();
	                asset.alignItemsWithNormal();
	            }
	
	            this.k = 0;
	        }
	    }]);
	
	    return FlowerWorld;
	}(_world2.default);
	
	exports.default = FlowerWorld;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _item = __webpack_require__(11);
	
	var _item2 = _interopRequireDefault(_item);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var Flower = function (_Asset) {
	    _inherits(Flower, _Asset);
	
	    function Flower(scene, timer, world) {
	        _classCallCheck(this, Flower);
	
	        // Create inside petals
	        var _this = _possibleConstructorReturn(this, (Flower.__proto__ || Object.getPrototypeOf(Flower)).call(this, scene, timer, world));
	
	        for (var i = 0; i < 3; i++) {
	            var c = createPetal();
	            var item = new _item2.default(c);
	            setAbsoluteRotation(c, 'Y', Math.PI * 2 / 3 * i + Math.PI * 2 / 6);
	            setAbsoluteScale(c, 0.5, 0.5, 0.5);
	            setAbsolutePosition(c, 0, 1, 0);
	            //item.localPosition.y += 3;
	            _this.items.push(item);
	        }
	
	        // Create outside petals
	        for (var i = 0; i < 3; i++) {
	            var c = createPetal();
	            var item = new _item2.default(c);
	            setAbsolutePosition(c, 0, -0.5, 0);
	            setAbsoluteRotation(c, 'Y', Math.PI * 2 / 3 * i);
	            setAbsoluteScale(c, 0.5, 0.5, 0.5);
	            setAbsolutePosition(c, 0, 1, 0);
	            //item.localPosition.y += 3;
	            _this.items.push(item);
	        }
	        return _this;
	    }
	
	    return Flower;
	}(_asset2.default);
	
	// Allows the mesh to assume it is untransformed
	
	
	exports.default = Flower;
	function resetTransform(mesh) {
	    mesh.updateMatrix();
	    mesh.geometry.applyMatrix(mesh.matrix);
	    mesh.position.set(0, 0, 0);
	    mesh.rotation.set(0, 0, 0);
	    mesh.scale.set(1, 1, 1);
	    mesh.updateMatrix();
	}
	
	function setAbsolutePosition(mesh, x, y, z) {
	    mesh.position.set(x, y, z);
	    resetTransform(mesh);
	}
	
	function setAbsoluteScale(mesh, x, y, z) {
	    mesh.scale.set(x, y, z);
	    resetTransform(mesh);
	}
	
	function setAbsoluteRotation(mesh, axis, rotation) {
	    switch (axis) {
	        case 'X':
	            mesh.rotation.x = rotation;
	            break;
	
	        case 'Y':
	            mesh.rotation.y = rotation;
	            break;
	
	        case 'Z':
	            mesh.rotation.z = rotation;
	            break;
	    }
	    resetTransform(mesh);
	}
	
	// Uses toolbox functions to create flower meshes
	function createPetal() {
	    var texloader = new THREE.TextureLoader();
	    var shaderUniforms = {
	        time: {
	            type: "float",
	            value: 0
	        },
	        color: {
	            type: "v4",
	            value: new THREE.Vector4(1., 0., 0., 1.)
	        },
	        image: { // Check the Three.JS documentation for the different allowed types and values
	            type: "t",
	            value: texloader.load('./textures/petal.jpg')
	        }
	    };
	
	    var material = new THREE.ShaderMaterial({
	        uniforms: shaderUniforms,
	        vertexShader: __webpack_require__(14),
	        fragmentShader: __webpack_require__(15),
	        side: THREE.DoubleSide
	        //lights: true
	    });
	
	    // Create flower meshes procedurally
	    var width = 1.0;
	    var height = 5;
	    var geometry = new THREE.PlaneGeometry(width, height, 1, 20);
	    var petal = new THREE.Mesh(geometry, material);
	
	    // create inner petal geometry
	    for (var i = 0; i < petal.geometry.vertices.length / 2; i++) {
	        var val = 0.25 * easeInQuadratic(petal.geometry.vertices[2 * i].y);
	        petal.geometry.vertices[2 * i].z = val;
	        petal.geometry.vertices[2 * i + 1].z = val;
	    }
	
	    for (var i = 0; i < petal.geometry.vertices.length; i++) {
	        if (petal.geometry.vertices[i].x == width / 2) {
	            var xval = width + width / 4 - easeInQuadratic(petal.geometry.vertices[i].y) / (height * width);
	            petal.geometry.vertices[i].x = xval;
	        } else if (petal.geometry.vertices[i].x == -width / 2) {
	            var xval = -width - width / 4 + easeInQuadratic(petal.geometry.vertices[i].y) / (height * width);
	            petal.geometry.vertices[i].x = xval;
	        }
	    }
	
	    setAbsolutePosition(petal, 0, 2, 0);
	    setAbsoluteRotation(petal, 'X', Math.PI / 3);
	
	    return petal;
	}
	
	function lerp(a0, a1, t) {
	    return t + a0 + (1 - t) * a1;
	}
	
	function bias(b, t) {
	    return Math.pow(t, Math.log(b) / Math.log(0.5));
	}
	
	function easeInQuadratic(t) {
	    return t * t;
	}
	
	function easeOutQuadratic(t) {
	    return 1 - easeInQuadratic(1 - t);
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _seaweed = __webpack_require__(22);
	
	var _seaweed2 = _interopRequireDefault(_seaweed);
	
	var _koi = __webpack_require__(25);
	
	var _koi2 = _interopRequireDefault(_koi);
	
	var _world = __webpack_require__(9);
	
	var _world2 = _interopRequireDefault(_world);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	
	var seaweeds = [];
	var kois = [];
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	
	var WaterWorld = function (_World) {
	    _inherits(WaterWorld, _World);
	
	    function WaterWorld(scene, timer, light, koiGeo, position) {
	        _classCallCheck(this, WaterWorld);
	
	        // initialize example uniform variables and store in list
	        var shaderUniforms = {
	            u_time: {
	                type: "float",
	                value: timer.elapsedTime
	            },
	            color: {
	                type: "v4",
	                value: new THREE.Vector4(1., 1., 1., 1.)
	            },
	            light_vec: {
	                type: "v3",
	                value: new THREE.Vector3(light.position.x, light.position.y, light.position.z)
	            }
	        };
	
	        // noise-water material
	        var material = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(28),
	            fragmentShader: __webpack_require__(29)
	        });
	        // enable transparency of the material 
	        material.transparent = true;
	
	        // basic lambert material 
	        var basicMaterial = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(16),
	            fragmentShader: __webpack_require__(30)
	        });
	        // enable transparency of the material 
	        material.transparent = true;
	        material.side = THREE.DoubleSide;
	        // make a "base sphere"
	        // add this somewhere to the class? not sure 
	        var baseSphereGeom = new THREE.IcosahedronGeometry(6, 4); // new THREE.BoxGeometry(6,6,6); consider making a box
	        var geometry = new THREE.IcosahedronGeometry(6, 2); // adjust second parameter: low poly (2) or high poly!!! (>3)
	        baseSphereGeom.translate(position.x, position.y, position.z);
	        geometry.translate(position.x, position.y, position.z);
	        var baseMesh = new THREE.Mesh(geometry, material);
	
	        var _this = _possibleConstructorReturn(this, (WaterWorld.__proto__ || Object.getPrototypeOf(WaterWorld)).call(this, scene, timer, baseMesh, position));
	
	        _this.innerSphere = new THREE.Mesh(baseSphereGeom, basicMaterial);
	        _this.light = light;
	
	        //this.setMeshPosition(baseMesh, this.position.x, this.position.y, this.position.z);
	        // this.setMeshPosition(this.innerSphere, this.position.x, this.position.y, this.position.z);
	
	        // create seaweed assets!
	        for (var i = 0; i < 25; i++) {
	            var seaweed = new _seaweed2.default(scene, timer, _this);
	            _this.spawnAsset(seaweed);
	            seaweeds.push(seaweed);
	        }
	
	        // create koi assets
	        for (var i = 0; i < 10; i++) {
	            var koi = new _koi2.default(scene, timer, _this, koiGeo);
	            // koi.setAbsolutePosition(0,-.5,0); 
	            kois.push(koi);
	            _this.spawnAsset(koi);
	        }
	        return _this;
	    }
	
	    // remove the random base sphere from scene lol sad
	
	
	    _createClass(WaterWorld, [{
	        key: 'removeInnerSphere',
	        value: function removeInnerSphere(time) {
	            if (this.timer.elapsedTime >= time) {
	                this.scene.remove(this.innerSphere);
	            }
	        }
	    }, {
	        key: 'toggleDisplay',
	        value: function toggleDisplay(displayed) {
	            if (!this.displayed && displayed) {
	                this.scene.add(this.baseMesh);
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].show();
	                }
	                this.scene.add(this.innerSphere);
	            } else if (this.displayed && !displayed) {
	                this.scene.remove(this.baseMesh);
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].hide();
	                }
	                this.scene.remove(this.innerSphere);
	            }
	            this.displayed = displayed;
	        }
	
	        // to update the uniform in the frag shader, enables animation
	
	    }, {
	        key: 'updateWaterTime',
	        value: function updateWaterTime() {
	            this.baseMesh.material.uniforms.u_time.value = this.timer.elapsedTime;
	            for (var i = 0; i < seaweeds.length; i++) {
	                seaweeds[i].material.uniforms.u_time.value = this.timer.elapsedTime;
	            }
	            for (var i = 0; i < kois.length; i++) {
	                kois[i].material.uniforms.u_time.value = this.timer.elapsedTime;
	            }
	        }
	
	        // CALL TO ANIMATE ASSETS HERERERERERERER /////////
	
	    }, {
	        key: 'animateAsset',
	        value: function animateAsset(asset, spinningSpeed) {
	            var vertices = this.worldVertices();
	
	            var pos = asset.vertex;
	            //pos.addVectors(asset.vertex, asset.normal.clone().multiplyScalar(this.normalOffset));
	
	            var up = asset.normal.clone();
	            var newPos = new THREE.Vector3();
	            //newPos.addVectors ( pos, up.multiplyScalar(this.musicData[this.k] / 70) );
	            asset.setScale(this.musicData[this.k] / 100);
	            if (this.k < this.musicData.length) {
	                this.k++;
	            }
	            asset.position = pos;
	            asset.updatePositions();
	        }
	    }, {
	        key: 'animateAssetNoMusic',
	        value: function animateAssetNoMusic(asset, spinningSpeed) {
	            var vertices = this.worldVertices();
	
	            var pos = asset.vertex;
	            //pos.addVectors(asset.vertex, asset.normal.clone().multiplyScalar(this.normalOffset));
	
	            var up = asset.normal.clone();
	            var newPos = new THREE.Vector3();
	            //newPos.addVectors ( pos, up.multiplyScalar(this.musicData[this.k] / 70) );
	            // asset.setScale(this.musicData[this.k] / 100);
	            // if (this.k < this.musicData.length) {
	            // this.k++; 
	            // }
	            asset.position = pos;
	            asset.updatePositions();
	        }
	    }, {
	        key: 'spinIndefinitely',
	        value: function spinIndefinitely(speed) {
	            this.baseMesh.rotation.y = speed;
	            this.baseMesh.updateMatrix();
	            this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	            var bufferLength = this.analyser.frequencyBinCount;
	            this.musicData = new Uint8Array(bufferLength);
	            this.analyser.getByteFrequencyData(this.musicData);
	
	            for (var i = 0; i < 35; i++) {
	                var asset = this.assets[i];
	                if (i < 25) {
	                    this.animateAsset(asset, speed);
	                } else {
	                    this.animateAssetNoMusic(asset, speed);
	                }
	                this.baseMesh.geometry.computeFaceNormals();
	                this.baseMesh.geometry.computeVertexNormals();
	                asset.alignItemsWithNormal();
	            }
	
	            this.k = 0;
	        }
	    }, {
	        key: 'tick',
	        value: function tick() {
	            if (this.displayed) {
	                this.spinIndefinitely(this.rotateSpeed);
	                this.updateWaterTime();
	            }
	        }
	    }]);
	
	    return WaterWorld;
	}(_world2.default);
	
	exports.default = WaterWorld;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _item = __webpack_require__(11);
	
	var _item2 = _interopRequireDefault(_item);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var Seaweed = function (_Asset) {
	    _inherits(Seaweed, _Asset);
	
	    function Seaweed(scene, timer, world) {
	        _classCallCheck(this, Seaweed);
	
	        var _this = _possibleConstructorReturn(this, (Seaweed.__proto__ || Object.getPrototypeOf(Seaweed)).call(this, scene, timer, world));
	
	        _this.shaderUniforms = {
	            time: {
	                type: "float",
	                value: 0
	            },
	            u_time: {
	                type: "float",
	                value: timer.elapsedTime
	            },
	            light_vec: {
	                type: "v3",
	                value: new THREE.Vector3(world.light.position.x, world.light.position.y, world.light.position.z)
	            }
	        };
	
	        _this.material = new THREE.ShaderMaterial({
	            uniforms: _this.shaderUniforms,
	            vertexShader: __webpack_require__(23),
	            fragmentShader: __webpack_require__(24),
	            side: THREE.DoubleSide
	        });
	
	        // Create inside petals
	        for (var i = 0; i < 2; i++) {
	            var c = createSeaweed(timer, _this.shaderUniforms, _this.material);
	            var item = new _item2.default(c);
	            setAbsoluteRotation(c, 'Z', Math.PI / 13 * i - Math.PI * 2.1);
	            setAbsolutePosition(c, -i / 12, 0, 0);
	            setAbsoluteScale(c, 1.0, i / 2 + 1.0, 1.0);
	            //item.localPosition.y += 3;
	            _this.items.push(item);
	        }
	        return _this;
	    }
	
	    return Seaweed;
	}(_asset2.default);
	
	// Uses toolbox functions to create flower meshes
	
	
	exports.default = Seaweed;
	function createSeaweed(timer, shaderUniforms, material) {
	    shaderUniforms = {
	        time: {
	            type: "float",
	            value: 0
	        },
	        color: {
	            type: "v4",
	            value: new THREE.Vector4(1., 0., 0., 1.)
	        },
	        u_time: {
	            type: "float",
	            value: timer.elapsedTime
	        }
	
	    };
	
	    // make seaweed geometry 
	    var width = 0.17;
	    var height = 2.3;
	    var geometry = new THREE.PlaneGeometry(width, height, 1, 20);
	    var weed = new THREE.Mesh(geometry, material);
	
	    // make it wavy 
	    for (var i = 0; i < weed.geometry.vertices.length / 4; i++) {
	        var val = 0.1 * Math.sin(weed.geometry.vertices[2 * i].y * 7);
	        weed.geometry.vertices[2 * i].z = val;
	        weed.geometry.vertices[2 * i + 1].z = val;
	    }
	
	    // taper the ends of seaweed 
	    for (var i = 0; i < weed.geometry.vertices.length; i++) {
	        if (weed.geometry.vertices[i].x > width / 2.0) {
	            var taper = width - weed.geometry.vertices[i].y / 5.0; // / (height * width);//  easeInQuadratic(weed.geometry.vertices[i].y / (height * width)); 
	            weed.geometry.vertices[i].x = taper;
	        }
	    }
	    return weed;
	}
	
	// toolbox functions 
	function cos(a, b, c, x) {
	    return a * cos(b * x) + c;
	}
	
	function sin(a, b, c, x) {
	    return a * sin(b * x) + c;
	}
	
	function lerp(a0, a1, t) {
	    return t + a0 + (1 - t) * a1;
	}
	
	function bias(b, t) {
	    return Math.pow(t, Math.log(b) / Math.log(0.5));
	}
	
	function easeInQuadratic(t) {
	    return t * t;
	}
	
	function easeOutQuadratic(t) {
	    return 1 - easeInQuadratic(1 - t);
	}
	
	// Allows the mesh to assume it is untransformed
	function resetTransform(mesh) {
	    mesh.updateMatrix();
	    mesh.geometry.applyMatrix(mesh.matrix);
	    mesh.position.set(0, 0, 0);
	    mesh.rotation.set(0, 0, 0);
	    mesh.scale.set(1, 1, 1);
	    mesh.updateMatrix();
	}
	
	function setAbsolutePosition(mesh, x, y, z) {
	    mesh.position.set(x, y, z);
	    resetTransform(mesh);
	}
	
	function setAbsoluteRotation(mesh, axis, rotation) {
	    switch (axis) {
	        case 'X':
	            mesh.rotation.x = rotation;
	            break;
	
	        case 'Y':
	            mesh.rotation.y = rotation;
	            break;
	
	        case 'Z':
	            mesh.rotation.z = rotation;
	            break;
	    }
	    resetTransform(mesh);
	}
	
	function setAbsoluteScale(mesh, x, y, z) {
	    mesh.scale.set(x, y, z);
	    resetTransform(mesh);
	}

/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_position; \nvarying vec3 f_normal; \nuniform float u_time; \n\nvoid main() {\n\tf_position = position;\n\tf_normal = normal; \n    vUv = uv;\n\n    float timeMod; \n    if (f_position.x > 1.0 ) {\n    \ttimeMod = cos(u_time * 2.0); \n    } else {\n    \ttimeMod = sin(u_time * 2.0);\n    }\n    vec3 position = vec3(f_position.x , f_position.y, f_position.z * timeMod);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_position; \nvarying vec3 f_normal; \nvarying float noise;\nuniform sampler2D image;\nuniform float u_time; \nuniform vec3 light_vec; \n\n// cosine based palette from IQ \nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid main() {\n\n    // compute colors\n    float speed = 0.1; \n    vec3 col = palette(speed * u_time, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n\n  vec2 uv = vec2(1,1) - vUv;\n  vec3 lGreen = vec3(0.403, 0.552, 0.384);\n  vec3 dGreen = vec3(0.109, 0.360, 0.078); \n\n  // hardcoded light vector \n  // vec3 light_vec = vec3(1.0, 1.0, 2.0); \n  // simple lambertian lighting\n  vec3 d = normalize(light_vec - f_position);\n  float lambert = clamp(dot(d, f_normal), 0.0, 1.0); \n  float globalIllum = 0.2; \n\n  // out color\n  gl_FragColor = vec4( lambert * dGreen, 1.0) + globalIllum * vec4(dGreen, 1.0);\n}"

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _item = __webpack_require__(11);
	
	var _item2 = _interopRequireDefault(_item);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var Koi = function (_Asset) {
	    _inherits(Koi, _Asset);
	
	    function Koi(scene, timer, world, assetGeo) {
	        _classCallCheck(this, Koi);
	
	        // add basic cube mesh item as example asset
	        var _this = _possibleConstructorReturn(this, (Koi.__proto__ || Object.getPrototypeOf(Koi)).call(this, scene, timer, world));
	
	        _this.shaderUniforms = {
	            time: {
	                type: "float",
	                value: 0
	            },
	            u_time: {
	                type: "float",
	                value: timer.elapsedTime
	            },
	            light_vec: {
	                type: "v3",
	                value: new THREE.Vector3(_this.world.light.position.x, _this.world.light.position.y, _this.world.light.position.z)
	            }
	        };
	
	        _this.material = new THREE.ShaderMaterial({
	            uniforms: _this.shaderUniforms,
	            vertexShader: __webpack_require__(26),
	            fragmentShader: __webpack_require__(27)
	        });
	
	        var mesh = new THREE.Mesh(assetGeo, _this.material);
	        mesh.rotation.y = Math.PI / 2.0;
	        //var mesh = new THREE.Mesh(assetGeo, new THREE.MeshBasicMaterial( {color: 0xffffff }));
	        setAbsolutePosition(mesh, 0, -0.17, 0);
	        var koiItem = new _item2.default(mesh);
	
	        // The asset class must have a normal and a vertex assigned before alignment can occur
	        // Make sure to call updateRotations from the asset class to update the item rotations
	        // koiItem.localPosition = new THREE.Vector3(0, 0, 0);
	
	        _this.items.push(koiItem);
	        return _this;
	    }
	
	    return Koi;
	}(_asset2.default);
	
	exports.default = Koi;
	
	
	function resetTransform(mesh) {
	    mesh.updateMatrix();
	    mesh.geometry.applyMatrix(mesh.matrix);
	    mesh.position.set(0, 0, 0);
	    mesh.rotation.set(0, 0, 0);
	    mesh.scale.set(1, 1, 1);
	    mesh.updateMatrix();
	}
	
	function setAbsolutePosition(mesh, x, y, z) {
	    mesh.position.set(x, y, z);
	    resetTransform(mesh);
	}

/***/ },
/* 26 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_position; \nvarying vec3 f_normal; \nuniform float u_time; \n\nfloat noise(float x, float y, float z){\n    float value1 = fract(sin(dot(vec2(x, y) ,vec2(3427.9898, 9847.233))) * 202.5453);\n    float value2 = fract(cos(z) * 20247.5453);\n\n    return fract(dot(value1, value2)); \n}\n\nvoid main() {\n\tf_position = position;\n\tf_normal = normal; \n    vUv = uv;\n\n    // float noise = noise(f_position.x, f_position.y, f_position.z); \n\n    float timeMod = cos(u_time * 0.5); \n\n    vec3 position = vec3(f_position.x, f_position.y, f_position.z + timeMod);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_position; \nvarying vec3 f_normal; \nvarying float noise;\nuniform float u_time; \nuniform vec3 light_vec; \n\n// noise function \nfloat noiseValue(float x, float y, float z){\n  float value1 = fract(sin(dot(vec2(z, y) ,vec2(1027.9898, 29381.233))) * 333019.5453);\n  float value2 = fract(sin(x) * 43758.5453);\n  return dot(value1, value2); \n}\n\n// cosine based palette from IQ \nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid main() {\n    // compute colors\n    float speed = 0.1; \n    vec3 col = palette(speed * u_time, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n\n  vec2 uv = vec2(1,1) - vUv;\n  vec3 pink = vec3(0.898, 0.682, 0.866);\n  float randColR = noiseValue(f_position.x, f_position.y, f_position.z);\n\n  vec3 randCol = vec3(randColR,0.682 + randColR / 4.0, 0.866 + randColR / 2.0); \n\n  // hardcoded light vector \n  // vec3 light_vec = vec3(1.0, 1.0, 2.0); \n  // simple lambertian lighting\n  vec3 d = normalize(light_vec - f_position);\n  float lambert = clamp(dot(d, f_normal), 0.0, 1.0); \n  float globalIllum = 0.2; \n\n  // out color\n  gl_FragColor = vec4( lambert * randCol, 1.0) + globalIllum * vec4(pink, 1.0);\n}"

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_normal; \nvarying vec3 f_position;\nuniform float u_time; \n// noise function returns range [-1,1]\nfloat noise1(float x, float y, float z){\n\tfloat value1 = fract(sin(dot(vec2(z, y) ,vec2(1027.9898, 29381.233))) * 333019.5453);\n\tfloat value2 = fract(sin(x) * 43758.5453);\n\treturn dot(value1, value2); \n}\n\nfloat noise_3(float x, float y, float z) {\n\tfloat value1 = fract(sin(dot(vec2(x, y) ,vec2(12.9898, 78.233))) * 43758.5453);\n\tfloat value2 = fract(sin(z) * 202229.5453);\n\n\treturn dot(value1, value2); \n}\n\nfloat noise(float x, float y, float z){\n\tfloat value1 = fract(sin(dot(vec2(x, y) ,vec2(3427.9898, 9847.233))) * 202.5453);\n\tfloat value2 = fract(cos(z) * 20247.5453);\n\n\treturn fract(dot(value1, value2)); \n}\n\n\n// lerp\nfloat lerp(float a, float b, float t) {\n\treturn a * (1.0 - t) + b * t; \n}\n\n// cosine interp \nfloat cos_interp(float a, float b, float t) {\n\tfloat cos_t = (1.0 - cos(t * 3.14159265358979)) * 0.5;\n\treturn lerp(a , b , cos_t);\n}\n\n// Interpolate Noise function\n// Given a position, use surrounding lattice points to interpolate and find influence \n// takes in (x,y,z) position, and the current octave level\nfloat interpolateNoise(float x, float y, float z) {\n\t// define the lattice points surrounding the input position \n\tfloat x0 = floor(x);\n\tfloat x1 = x0 + 1.0; \n\tfloat y0 = floor(y);\n\tfloat y1 = y0 + 1.0;\n\tfloat z0 = floor(z);\n\tfloat z1 = z0 + 1.0; \n\n\t// VALUE BASED NOISE\n\tvec3 p0 = vec3(x0, y0, z0); vec3 p1 = vec3(x0, y0, z1);\n\tvec3 p2 = vec3(x0, y1, z0); vec3 p3 = vec3(x0, y1, z1);\n\tvec3 p4 = vec3(x1, y0, z0); vec3 p5 = vec3(x1, y0, z1);\n\tvec3 p6 = vec3(x1, y1, z0); vec3 p7 = vec3(x1, y1, z1);\n\n\t// use noise function to generate random value\n\t// depending on the current octave, sample noise using a different function \n\tfloat v0, v1, v2, v3, v4, v5, v6, v7;\n\tv0 = noise(p0.x, p0.y, p0.z); v1 = noise(p1.x, p1.y, p1.z);\n\tv2 = noise(p2.x, p2.y, p2.z); v3 = noise(p3.x, p3.y, p3.z);\n    v4 = noise(p4.x, p4.y, p4.z); v5 = noise(p5.x, p5.y, p5.z);\n\tv6 = noise(p6.x, p6.y, p6.z); v7 = noise(p7.x, p7.y, p7.z);\n\n\t// trilinear interpolation of all 8 values\n\t// coordinates in the unit cube: \n\tfloat unitX = x - x0;\n\tfloat unitY = y - y0;\n\tfloat unitZ = z - z0;\n\n\tfloat xCos1 = cos_interp(v0, v4, unitX);\n\tfloat xCos2 = cos_interp(v1, v5, unitX);\n\tfloat xCos3 = cos_interp(v2, v6, unitX);\n\tfloat xCos4 = cos_interp(v3, v7, unitX);\n\n\tfloat yCos1 = cos_interp(xCos1, xCos3, unitY);\n\tfloat yCos2 = cos_interp(xCos2, xCos4, unitY);\n\n\tfloat average = cos_interp(yCos1, yCos2, unitZ);\n\n\treturn average;\n}\n\n// multioctave\nfloat fbm(float x, float y, float z) {\n\tfloat total = 0.0; \n\t// make a little less fractal-y \n\t// total += interpolateNoise(x * 64.0, y * 64.0, z * 64.0) * 1.0;\n\t// total += interpolateNoise(x * 32.0, y * 32.0, z * 32.0) * 2.0; \n\t// total += interpolateNoise(x * 16.0, y * 16.0, z * 16.0) * 4.0; \n\ttotal += interpolateNoise(x * 8.0, y * 8.0, z * 8.0) * 8.0; \n\ttotal += interpolateNoise(x * 4.0, y * 4.0, z * 4.0) * 16.0; \n\ttotal += interpolateNoise(x * 2.0, y * 2.0, z * 2.0) * 32.0; \n\ttotal += interpolateNoise(x * 1.0, y * 1.0, z * 1.0) * 64.0; \n\n\treturn total;\n}\n\n// main \nvoid main() {\n\tfloat time = u_time / 2.0;\n\tfloat waveHeight = 2.0; // smaller values will give bigger waves \n\t// get noise height based on position \n\t// TO ANIMATE: add time to the x parameter of this function \n    float noiseHeight = fbm(float(position.x / waveHeight) + time, float(position.y / waveHeight), float(position.z / waveHeight));\n    vec3 noisePosition = (vec3(\n    \tposition.x + noiseHeight / 300.0 + normal.x * noiseHeight / 20.0 , \n    \tposition.y + noiseHeight / 300.0 + normal.y * noiseHeight/ 20.0 , \n    \tposition.z + noiseHeight / 300.0 + normal.z * noiseHeight/ 20.0)); \n\n\tf_normal = normal; \n\tf_position = position; \n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( noisePosition, 1.0 );\n}"

/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_normal; \nvarying vec3 f_position;\nuniform sampler2D image;\nuniform vec3 light_vec; \nuniform float u_time; \n\nvoid main() {\n  vec3 turquoise = vec3(27.0 / 255.0, 193.0 / 255.0, 163.0 / 255.0);\n  vec3 darkBlue = vec3(0.2,0.5,1.0);\n\n  // simple lambertian lighting\n  vec3 d = normalize(light_vec - f_position);\n  float lambert = clamp(dot(d, f_normal), 0.0, 1.0); \n  float globalIllum = 0.2; \n\n  // out color\n  gl_FragColor = vec4( lambert * turquoise, 0.2) + globalIllum * vec4(darkBlue, 1.0);\n\n  // set transparency \n  gl_FragColor.a = 0.6;\n}"

/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_normal; \nvarying vec3 f_position;\nuniform sampler2D image;\nuniform vec3 light_vec; \nuniform float u_time; \n\n// cosine based palette from IQ \nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid main() {\n    // compute colors\n    float speed = 0.2; \n    vec3 col = palette(speed * u_time, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n\n  vec3 turquoise = vec3(27.0 / 255.0, 193.0 / 255.0, 163.0 / 255.0);\n  vec3 darkBlue = vec3(0.2,0.5,1.0);\n\n  // simple lambertian lighting\n  vec3 d = normalize(light_vec - f_position);\n  float lambert = clamp(dot(d, f_normal), 0.0, 1.0); \n  float globalIllum = 0.2; \n\n  // out color\n  // gl_FragColor = vec4( lambert * turquoise, 0.2) + globalIllum * vec4(darkBlue, 1.0);\n  gl_FragColor = vec4(lambert * col, 0.2) + globalIllum * vec4(col, 1.0); \n\n  // set transparency \n  gl_FragColor.a = 0.6;\n}"

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _world = __webpack_require__(9);
	
	var _world2 = _interopRequireDefault(_world);
	
	var _crystal = __webpack_require__(32);
	
	var _crystal2 = _interopRequireDefault(_crystal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var CrystalWorld = function (_World) {
	    _inherits(CrystalWorld, _World);
	
	    function CrystalWorld(scene, camera, timer, light, position) {
	        _classCallCheck(this, CrystalWorld);
	
	        // initialize example uniform variables and store in list
	        var texloader = new THREE.TextureLoader();
	        var shaderUniforms = {
	            texture: {
	                type: "t",
	                value: texloader.load('./textures/iridescent.bmp')
	            },
	            u_useTexture: {
	                type: 'i',
	                value: true
	            },
	            u_albedo: {
	                type: 'v3',
	                value: new THREE.Color('#dddddd')
	            },
	            u_ambient: {
	                type: 'v3',
	                value: new THREE.Color('#111111')
	            },
	            u_lightPos: {
	                type: 'v3',
	                value: new THREE.Vector3(30, 50, 40)
	            },
	            u_lightCol: {
	                type: 'v3',
	                value: new THREE.Color('#ffffff')
	            },
	            u_lightIntensity: {
	                type: 'f',
	                value: 2
	            },
	            u_camPos: {
	                type: 'v3',
	                value: camera.position
	            },
	            time: {
	                type: 'float',
	                value: timer.elapsedTime
	            },
	            alpha: {
	                type: 'float',
	                value: 1.0
	            }
	        };
	
	        // initialize example shader and mesh
	        var material = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(35),
	            fragmentShader: __webpack_require__(36)
	        });
	        material.side = THREE.DoubleSide;
	        material.transparent = true;
	
	        var geometry = new THREE.IcosahedronGeometry(6, 1);
	        var baseMesh = new THREE.Mesh(geometry, material);
	
	        var _this = _possibleConstructorReturn(this, (CrystalWorld.__proto__ || Object.getPrototypeOf(CrystalWorld)).call(this, scene, timer, baseMesh, position));
	
	        _this.camera = camera;
	        _this.alpha = 0.9;
	        _this.normalOffset = -1;
	        _this.spawnAtEveryVertex();
	        return _this;
	    }
	
	    _createClass(CrystalWorld, [{
	        key: 'fadeIn',
	        value: function fadeIn(start, end) {
	            if (this.timer.elapsedTime >= start && this.timer.elapsedTime < end) {
	                var t = (this.timer.elapsedTime - start) / (end - start);
	                var delta = 1 / (end - start);
	                this.baseMesh.material.uniforms.alpha.value += delta * t * t;
	
	                if (this.baseMesh.material.uniforms.alpha.value > 0.9) {
	                    this.baseMesh.material.uniforms.alpha.value = 0.9;
	                }
	
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].material.uniforms.alpha.value = this.baseMesh.material.uniforms.alpha.value;
	                }
	            }
	        }
	    }, {
	        key: 'fadeOut',
	        value: function fadeOut(start, end) {
	            if (this.timer.elapsedTime >= start && this.timer.elapsedTime < end) {
	                var t = (this.timer.elapsedTime - start) / (end - start);
	                var delta = -1 / (end - start);
	                this.baseMesh.material.uniforms.alpha.value += delta * t * t;
	                if (this.baseMesh.material.uniforms.alpha.value < 0) {
	                    this.baseMesh.material.uniforms.alpha.value = 0;
	                }
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].material.uniforms.alpha.value = this.baseMesh.material.uniforms.alpha.value;
	                }
	            }
	        }
	    }, {
	        key: 'toggleDisplay',
	        value: function toggleDisplay(displayed) {
	            if (!this.displayed && displayed) {
	                this.scene.add(this.baseMesh);
	                this.baseMesh.material.uniforms.alpha.value = 1.0;
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].show();
	                }
	            } else if (this.displayed && !displayed) {
	                this.baseMesh.material.uniforms.alpha.value = 0.0;
	                this.scene.remove(this.baseMesh);
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].hide();
	                }
	            }
	
	            this.displayed = displayed;
	        }
	    }, {
	        key: 'spawnAtEveryVertex',
	        value: function spawnAtEveryVertex() {
	            var faces = this.worldFaces();
	            var vertices = this.worldVertices();
	            for (var i = 0; i < faces.length; i++) {
	                var face = faces[i];
	                var v0 = vertices[face.a];
	                var v1 = vertices[face.b];
	                var v2 = vertices[face.c];
	
	                var x = (v0.x + v1.x + v2.x) / 3;
	                var y = (v0.y + v1.y + v2.y) / 3;
	                var z = (v0.z + v1.z + v2.z) / 3;
	
	                var v = new THREE.Vector3(x, y, z);
	
	                var asset = new _crystal2.default(this.scene, this.camera, this.timer, this);
	
	                asset.normal = faces[i].vertexNormals[0];
	                asset.normal = face.normal;
	                asset.vertex = v;
	                asset.face = face;
	                this.addAsset(asset, v);
	
	                asset.alignItemsWithNormal();
	                //asset.up = asset.normal; 
	            }
	        }
	    }, {
	        key: 'spawnRing',
	        value: function spawnRing() {}
	    }, {
	        key: 'animateAsset',
	        value: function animateAsset(asset, spinningSpeed) {
	            var vertices = this.worldVertices();
	            var v0 = vertices[asset.face.a];
	            var v1 = vertices[asset.face.b];
	            var v2 = vertices[asset.face.c];
	
	            var x = (v0.x + v1.x + v2.x) / 3;
	            var y = (v0.y + v1.y + v2.y) / 3;
	            var z = (v0.z + v1.z + v2.z) / 3;
	
	            var v = new THREE.Vector3(x, y, z);
	            asset.vertex = v;
	
	            var pos = new THREE.Vector3();
	            pos.addVectors(v, asset.normal.clone().multiplyScalar(this.normalOffset));
	
	            var up = asset.normal.clone();
	            var newPos = new THREE.Vector3();
	            newPos.addVectors(pos, up.multiplyScalar(this.musicData[this.k] / 70));
	
	            if (this.k < this.musicData.length) {
	                this.k++;
	            }
	            asset.position = newPos;
	        }
	    }, {
	        key: 'spinIndefinitely',
	        value: function spinIndefinitely(speed) {
	            this.baseMesh.rotation.y = speed;
	            this.baseMesh.updateMatrix();
	            this.baseMesh.geometry.applyMatrix(this.baseMesh.matrix);
	            var bufferLength = this.analyser.frequencyBinCount;
	            this.musicData = new Uint8Array(bufferLength);
	            this.analyser.getByteFrequencyData(this.musicData);
	
	            for (var i = 0; i < this.assets.length; i++) {
	                var asset = this.assets[i];
	                this.animateAsset(asset, speed);
	                this.baseMesh.geometry.computeFaceNormals();
	                this.baseMesh.geometry.computeVertexNormals();
	                asset.alignItemsWithNormal();
	            }
	
	            this.k = 0;
	        }
	    }, {
	        key: 'tick',
	        value: function tick() {
	            if (this.displayed) {
	                this.spinIndefinitely(this.rotateSpeed);
	                this.updateShaderUniforms();
	
	                // assets tick
	                for (var i = 0; i < this.assets.length; i++) {
	                    this.assets[i].tick();
	                }
	            }
	        }
	    }]);
	
	    return CrystalWorld;
	}(_world2.default);
	
	exports.default = CrystalWorld;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _asset = __webpack_require__(10);
	
	var _asset2 = _interopRequireDefault(_asset);
	
	var _item = __webpack_require__(11);
	
	var _item2 = _interopRequireDefault(_item);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var THREE = __webpack_require__(6);
	
	// this class will mostly be unchanged from world to world. 
	// variation in worlds will mostly rely on the various assets.
	var Crystal = function (_Asset) {
	    _inherits(Crystal, _Asset);
	
	    function Crystal(scene, camera, timer, world) {
	        _classCallCheck(this, Crystal);
	
	        var _this = _possibleConstructorReturn(this, (Crystal.__proto__ || Object.getPrototypeOf(Crystal)).call(this, scene, timer, world));
	
	        _this.face;
	
	        var texloader = new THREE.TextureLoader();
	        var shaderUniforms = {
	            texture: {
	                type: "t",
	                value: texloader.load('./textures/iridescent.bmp')
	            },
	            u_useTexture: {
	                type: 'i',
	                value: true
	            },
	            u_albedo: {
	                type: 'v3',
	                value: new THREE.Color('#dddddd')
	            },
	            u_ambient: {
	                type: 'v3',
	                value: new THREE.Color('#111111')
	            },
	            u_lightPos: {
	                type: 'v3',
	                value: new THREE.Vector3(30, 50, 40)
	            },
	            u_lightCol: {
	                type: 'v3',
	                value: new THREE.Color('#ffffff')
	            },
	            u_lightIntensity: {
	                type: 'f',
	                value: 2
	            },
	            u_camPos: {
	                type: 'v3',
	                value: camera.position
	            },
	            time: {
	                type: 'float',
	                value: timer.elapsedTime
	            },
	            alpha: {
	                type: 'float',
	                value: 0.0
	            }
	        };
	
	        // initialize example shader and mesh
	        var material = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(33),
	            fragmentShader: __webpack_require__(34)
	        });
	
	        material.transparent = true;
	        material.shading = THREE.FlatShading;
	        _this.material = material;
	        var mesh = createMainCrystalMesh(material);
	        _this.items.push(new _item2.default(mesh));
	        return _this;
	    }
	
	    return Crystal;
	}(_asset2.default);
	
	// Allows the mesh to assume it is untransformed
	
	
	exports.default = Crystal;
	function resetTransform(mesh) {
	    mesh.updateMatrix();
	    mesh.geometry.applyMatrix(mesh.matrix);
	    mesh.position.set(0, 0, 0);
	    mesh.rotation.set(0, 0, 0);
	    mesh.scale.set(1, 1, 1);
	    mesh.updateMatrix();
	}
	
	function setAbsolutePosition(mesh, x, y, z) {
	    mesh.position.set(x, y, z);
	    resetTransform(mesh);
	}
	
	function setAbsoluteScale(mesh, x, y, z) {
	    mesh.scale.set(x, y, z);
	    resetTransform(mesh);
	}
	
	function setAbsoluteRotation(mesh, axis, rotation) {
	    switch (axis) {
	        case 'X':
	            mesh.rotation.x = rotation;
	            break;
	
	        case 'Y':
	            mesh.rotation.y = rotation;
	            break;
	
	        case 'Z':
	            mesh.rotation.z = rotation;
	            break;
	    }
	    resetTransform(mesh);
	}
	
	function createMainCrystalMesh(material) {
	    var thickness = 0.65;
	    var pts = [],
	        count = Math.floor(Math.random() * 5) + 3;
	
	    for (var i = 0; i < count; i++) {
	        var l = thickness;
	        var a = 2 * i / count * Math.PI;
	        pts.push(new THREE.Vector2(Math.cos(a) * l, Math.sin(a) * l));
	    }
	
	    var shape = new THREE.Shape(pts);
	
	    var length = thickness * Math.random() * 6;
	    var extrudeSettings = { amount: length,
	        bevelEnabled: true, bevelSegments: Math.floor(Math.random() * 2) + 1,
	        steps: 5, bevelSize: thickness, bevelThickness: thickness * 4 };
	    var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
	    material.needsUpdate = true;
	    var mesh = new THREE.Mesh(geometry, material);
	    mesh.geometry.dynamic = true;
	
	    setAbsoluteRotation(mesh, 'X', Math.PI / 2);
	    setAbsoluteRotation(mesh, 'Y', Math.PI / 2 * Math.random() / 10);
	    setAbsolutePosition(mesh, 0, -length / 2, 0);
	
	    return mesh;
	}
	
	function lerp(a0, a1, t) {
	    return t + a0 + (1 - t) * a1;
	}
	
	function bias(b, t) {
	    return Math.pow(t, Math.log(b) / Math.log(0.5));
	}
	
	function easeInQuadratic(t) {
	    return t * t;
	}
	
	function easeOutQuadratic(t) {
	    return 1 - easeInQuadratic(1 - t);
	}

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = "varying vec2 f_uv;\nvarying vec3 f_normal;\nvarying vec3 f_position;\nvarying float noise;\nuniform float time;\n\nfloat random(float a, float b, float c) {\n    return fract(sin(dot(vec3(a, b, c), vec3(12.9898, 78.233, 578.233)))*43758.5453);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a * (1.0 - t) + b * t;\n}\n\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return a * (1.0 - t) + b * t;\n}\n\nfloat cerp(float a, float b, float t) {\n    float cos_t = (1.0 - cos(t*3.14159)) * 0.5;\n    return lerp(a, b, cos_t);\n}\n\nfloat interpolateNoise(float x, float y, float z) {\n    float x0, y0, z0, x1, y1, z1;\n    \n    // Find the grid voxel that this point falls in\n    x0 = floor(x);\n    y0 = floor(y);\n    z0 = floor(z);\n    \n    x1 = x0 + 1.0;\n    y1 = y0 + 1.0;\n    z1 = z0 + 1.0;\n    \n    // Generate noise at each of the 8 points\n    float FUL, FUR, FLL, FLR, BUL, BUR, BLL, BLR;\n    \n    // front upper left\n    FUL = random(x0, y1, z1);\n    \n    // front upper right\n    FUR = random(x1, y1, z1);\n    \n    // front lower left\n    FLL = random(x0, y0, z1);\n    \n    // front lower right\n    FLR = random(x1, y0, z1);\n    \n    // back upper left\n    BUL = random(x0, y1, z0);\n    \n    // back upper right\n    BUR = random(x1, y1, z0);\n    \n    // back lower left\n    BLL = random(x0, y0, z0);\n    \n    // back lower right\n    BLR = random(x1, y0, z0);\n    \n    // Find the interpolate t values\n    float n0, n1, m0, m1, v;\n    float tx = fract(x - x0);\n    float ty = fract(y - y0);\n    float tz = fract(z - z0);\n    tx = (x - x0);\n    ty = (y - y0);\n    tz = (z - z0);\n    \n    // interpolate along x and y for back\n    n0 = cerp(BLL, BLR, tx);\n    n1 = cerp(BUL, BUR, tx);\n    m0 = cerp(n0, n1, ty);\n    \n    // interpolate along x and y for front\n    n0 = cerp(FLL, FLR, tx);\n    n1 = cerp(FUL, FUR, tx);\n    m1 = cerp(n0, n1, ty);\n    \n    // interpolate along z\n    v = cerp(m0, m1, tz);\n    \n    return v;\n}\n\nfloat generateNoise(float x, float y, float z) {\n    float total = 0.0;\n    float persistence = 1.0 / 2.0;\n    int its = 0;\n    for (int i = 0; i < 32; i++) {\n        float freq = pow(2.0, float(i));\n        float ampl = pow(persistence, float(i));\n        total += interpolateNoise(freq*x, freq*y, freq*z)*ampl;\n    }\n    return total;\n}\n\nvoid main() {\n    // Pass noise to the fragment shader\n    noise =  generateNoise(position.x + time, position.y + time, position.z + time);\n    f_uv = uv;\n    f_normal = normal;\n    vec3 a_position = position + vec3(noise);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D texture;\nuniform int u_useTexture;\nuniform vec3 u_albedo;\nuniform vec3 u_ambient;\nuniform vec3 u_lightPos;\nuniform vec3 u_lightCol;\nuniform float u_lightIntensity;\n\nuniform vec3 u_camPos;\nuniform float time;\n\nvarying vec3 f_position;\nvarying vec3 f_normal;\nvarying vec2 f_uv;\nvarying float noise;\n\nuniform float alpha;\n\n\nvoid main() {\n    vec4 color = vec4(0.0, 0.0, 1.0, 1.0);\n    float d = clamp(dot(f_normal, normalize(u_camPos - f_position)), 0.0, 1.0);\n\n    //Read from texture using relation to the view vector and a little bit of noise\n    if (u_useTexture == 1) {\n        color = texture2D(texture, vec2(noise) / f_uv);\n    }\n\n    vec4 ambient = color / 3.0;\n\n    gl_FragColor = vec4(d * color.rgb * u_lightCol * u_lightIntensity + ambient.rgb, alpha);\n    if (alpha > 0.9) {\n        gl_FragColor.a = 0.9;\n    }\n    //gl_FragColor.a = 0.2;\n}"

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = "varying vec2 f_uv;\nvarying vec3 f_normal;\nvarying vec3 f_position;\nvarying float noise;\nuniform float time;\n\nfloat random(float a, float b, float c) {\n    return fract(sin(dot(vec3(a, b, c), vec3(12.9898, 78.233, 578.233)))*43758.5453);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a * (1.0 - t) + b * t;\n}\n\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return a * (1.0 - t) + b * t;\n}\n\nfloat cerp(float a, float b, float t) {\n    float cos_t = (1.0 - cos(t*3.14159)) * 0.5;\n    return lerp(a, b, cos_t);\n}\n\nfloat interpolateNoise(float x, float y, float z) {\n    float x0, y0, z0, x1, y1, z1;\n    \n    // Find the grid voxel that this point falls in\n    x0 = floor(x);\n    y0 = floor(y);\n    z0 = floor(z);\n    \n    x1 = x0 + 1.0;\n    y1 = y0 + 1.0;\n    z1 = z0 + 1.0;\n    \n    // Generate noise at each of the 8 points\n    float FUL, FUR, FLL, FLR, BUL, BUR, BLL, BLR;\n    \n    // front upper left\n    FUL = random(x0, y1, z1);\n    \n    // front upper right\n    FUR = random(x1, y1, z1);\n    \n    // front lower left\n    FLL = random(x0, y0, z1);\n    \n    // front lower right\n    FLR = random(x1, y0, z1);\n    \n    // back upper left\n    BUL = random(x0, y1, z0);\n    \n    // back upper right\n    BUR = random(x1, y1, z0);\n    \n    // back lower left\n    BLL = random(x0, y0, z0);\n    \n    // back lower right\n    BLR = random(x1, y0, z0);\n    \n    // Find the interpolate t values\n    float n0, n1, m0, m1, v;\n    float tx = fract(x - x0);\n    float ty = fract(y - y0);\n    float tz = fract(z - z0);\n    tx = (x - x0);\n    ty = (y - y0);\n    tz = (z - z0);\n    \n    // interpolate along x and y for back\n    n0 = cerp(BLL, BLR, tx);\n    n1 = cerp(BUL, BUR, tx);\n    m0 = cerp(n0, n1, ty);\n    \n    // interpolate along x and y for front\n    n0 = cerp(FLL, FLR, tx);\n    n1 = cerp(FUL, FUR, tx);\n    m1 = cerp(n0, n1, ty);\n    \n    // interpolate along z\n    v = cerp(m0, m1, tz);\n    \n    return v;\n}\n\nfloat generateNoise(float x, float y, float z) {\n    float total = 0.0;\n    float persistence = 1.0 / 2.0;\n    int its = 0;\n    for (int i = 0; i < 32; i++) {\n        float freq = pow(2.0, float(i));\n        float ampl = pow(persistence, float(i));\n        total += interpolateNoise(freq*x, freq*y, freq*z)*ampl;\n    }\n    return total;\n}\n\nvoid main() {\n    // Pass noise to the fragment shader\n\tnoise =  generateNoise(position.x + time, position.y + time, position.z + time);\n    f_uv = uv;\n    f_normal = normal;\n    vec3 a_position = position + vec3(noise);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"

/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D texture;\nuniform int u_useTexture;\nuniform vec3 u_albedo;\nuniform vec3 u_ambient;\nuniform vec3 u_lightPos;\nuniform vec3 u_lightCol;\nuniform float u_lightIntensity;\nuniform vec3 u_camPos;\nuniform float time;\n\nvarying vec3 f_position;\nvarying vec3 f_normal;\nvarying vec2 f_uv;\nvarying float noise;\n\nuniform float alpha;\n\n\nvoid main() {\n    vec4 color = vec4(0.0, 0.0, 1.0, 1.0);\n    float d = clamp(dot(f_normal, normalize(u_camPos - f_position)), 0.0, 1.0);\n\n    //Read from texture using relation to the view vector and a little bit of noise\n    if (u_useTexture == 1) {\n        color = texture2D(texture, f_uv*vec2(noise));\n    }\n\n    gl_FragColor = vec4(d * color.rgb * u_lightCol * u_lightIntensity + u_ambient, alpha);\n\n    if (alpha > 0.9) {\n    \tgl_FragColor.a = 0.9;\n    }\n    //gl_FragColor.a = 0.2;\n}"

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var THREE = __webpack_require__(6);
	
	var GalaxyBackground = function () {
	    function GalaxyBackground(scene, timer, light) {
	        _classCallCheck(this, GalaxyBackground);
	
	        this.scene = scene;
	        this.timer = timer;
	        this.light = light;
	        this.planets = [];
	
	        // initialize example uniform variables and store in list
	        var shaderUniforms = {
	            u_time: {
	                type: "float",
	                value: timer.elapsedTime
	            },
	            color: {
	                type: "v4",
	                value: new THREE.Vector4(1., 1., 1., 1.)
	            },
	            light_vec: {
	                type: "v3",
	                value: new THREE.Vector3(light.position.x, light.position.y, light.position.z)
	            },
	            start_pos: {
	                type: "v3",
	                value: new THREE.Vector3(0, 0, 0)
	            }
	        };
	
	        this.material = new THREE.ShaderMaterial({
	            uniforms: shaderUniforms,
	            vertexShader: __webpack_require__(38),
	            fragmentShader: __webpack_require__(39)
	        });
	        this.material.transparent = true;
	    }
	
	    _createClass(GalaxyBackground, [{
	        key: "initializeBackground",
	        value: function initializeBackground() {
	            var points = new THREE.Geometry();
	
	            for (var i = 0; i < 10000; i++) {
	                var p = new THREE.Vector3();
	                p.x = THREE.Math.randFloatSpread(2000);
	                p.y = THREE.Math.randFloatSpread(2000);
	                p.z = THREE.Math.randFloatSpread(2000);
	                points.vertices.push(p);
	                points.lights = true;
	            }
	
	            var whiteCol = new THREE.PointsMaterial({ color: 0xffffff });
	
	            var starField = new THREE.Points(points, whiteCol);
	
	            this.scene.add(starField);
	
	            this.renderRando(0);
	        }
	    }, {
	        key: "renderRando",
	        value: function renderRando(time) {
	            if (this.timer.elapsedTime >= time) {
	                for (var i = -10; i < 20; i += 10) {
	                    if (i != 0) {
	                        var geometry = new THREE.SphereBufferGeometry(0.8, 32, 32);
	                        var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
	                        var sphere = new THREE.Mesh(geometry, this.material);
	                        sphere.position.set(0, i, 0);
	                        this.scene.add(sphere);
	                        this.planets.push(sphere);
	                    }
	                }
	            }
	        }
	    }, {
	        key: "tick",
	        value: function tick() {
	            for (var i = 0; i < this.planets.length; i++) {
	                this.planets[i].material.uniforms.u_time.value = this.timer.elapsedTime;
	            }
	        }
	    }]);
	
	    return GalaxyBackground;
	}();
	
	exports.default = GalaxyBackground;

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_normal; \nvarying vec3 f_position;\n\nuniform float u_time;\nuniform vec3 light_vec; \nuniform vec3 start_pos;\n\nvoid main() {\n    vUv = uv;\n    f_normal = normal;\n    f_position = position;\n    float scale = position.y;  \n    float timeMod = cos(u_time / (1.8 * scale)) * 15.0;\n    float timeMod2 = sin(u_time / (1.8 * scale)) * 15.0; \n    vec3 pos = vec3(position.x + timeMod, position.y, position.z - timeMod2); \n    gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}"

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nvarying vec3 f_normal; \nvarying vec3 f_position;\nuniform sampler2D image;\nuniform vec3 light_vec; \nuniform float u_time; \n\n// cosine based palette from IQ \nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid main() {\n    // compute colors\n    float speed = 0.2; \n    vec3 col = palette(speed * u_time, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30));\n\n\n  vec3 turquoise = vec3(27.0 / 255.0, 193.0 / 255.0, 163.0 / 255.0);\n  vec3 darkBlue = vec3(0.2,0.5,1.0);\n\n  // simple lambertian lighting\n  vec3 d = normalize(light_vec - f_position);\n  float lambert = clamp(dot(d, f_normal), 0.0, 1.0); \n  float globalIllum = 0.2; \n\n  // out color\n  // gl_FragColor = vec4( lambert * turquoise, 0.2) + globalIllum * vec4(darkBlue, 1.0);\n  gl_FragColor = vec4(lambert * col, 0.2) + globalIllum * vec4(col, 1.0); \n\n  // set transparency \n  gl_FragColor.a = 0.05;\n}"

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var THREE = __webpack_require__(6);
	var EffectComposer = __webpack_require__(41)(THREE);
	
	var on = false;
	function turnOn() {
	  on = true;
	}
	function turnOff() {
	  on = false;
	}
	function isOn() {
	  return on;
	}
	
	var shader = new EffectComposer.ShaderPass({
	  uniforms: {
	    tDiffuse: {
	      type: 't',
	      value: null
	    },
	    u_amount: {
	      type: 'f',
	      value: 1.0
	    },
	    rollSpeed: {
	      type: 'f',
	      value: 0.0
	    },
	    time: {
	      type: 'f',
	      value: 0.0
	    },
	    speed: {
	      type: 'f',
	      value: 0.2
	    },
	    distortion: {
	      type: 'f',
	      value: 0.0
	    },
	    distortion2: {
	      type: 'f',
	      value: 0.0
	    }
	  },
	  vertexShader: __webpack_require__(47),
	  fragmentShader: __webpack_require__(48)
	});
	
	exports.default = {
	  shader: shader,
	  turnOn: turnOn,
	  turnOff: turnOff,
	  isOn: isOn
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	module.exports = function(THREE) {
	  var CopyShader = EffectComposer.CopyShader = __webpack_require__(42)
	    , RenderPass = EffectComposer.RenderPass = __webpack_require__(43)(THREE)
	    , ShaderPass = EffectComposer.ShaderPass = __webpack_require__(44)(THREE, EffectComposer)
	    , MaskPass = EffectComposer.MaskPass = __webpack_require__(45)(THREE)
	    , ClearMaskPass = EffectComposer.ClearMaskPass = __webpack_require__(46)(THREE)
	
	  function EffectComposer( renderer, renderTarget ) {
	    this.renderer = renderer;
	
	    if ( renderTarget === undefined ) {
	      var width = window.innerWidth || 1;
	      var height = window.innerHeight || 1;
	      var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
	
	      renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
	    }
	
	    this.renderTarget1 = renderTarget;
	    this.renderTarget2 = renderTarget.clone();
	
	    this.writeBuffer = this.renderTarget1;
	    this.readBuffer = this.renderTarget2;
	
	    this.passes = [];
	
	    this.copyPass = new ShaderPass( CopyShader );
	  };
	
	  EffectComposer.prototype = {
	    swapBuffers: function() {
	
	      var tmp = this.readBuffer;
	      this.readBuffer = this.writeBuffer;
	      this.writeBuffer = tmp;
	
	    },
	
	    addPass: function ( pass ) {
	
	      this.passes.push( pass );
	
	    },
	
	    insertPass: function ( pass, index ) {
	
	      this.passes.splice( index, 0, pass );
	
	    },
	
	    render: function ( delta ) {
	
	      this.writeBuffer = this.renderTarget1;
	      this.readBuffer = this.renderTarget2;
	
	      var maskActive = false;
	
	      var pass, i, il = this.passes.length;
	
	      for ( i = 0; i < il; i ++ ) {
	
	        pass = this.passes[ i ];
	
	        if ( !pass.enabled ) continue;
	
	        pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );
	
	        if ( pass.needsSwap ) {
	
	          if ( maskActive ) {
	
	            var context = this.renderer.context;
	
	            context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
	
	            this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );
	
	            context.stencilFunc( context.EQUAL, 1, 0xffffffff );
	
	          }
	
	          this.swapBuffers();
	
	        }
	
	        if ( pass instanceof MaskPass ) {
	
	          maskActive = true;
	
	        } else if ( pass instanceof ClearMaskPass ) {
	
	          maskActive = false;
	
	        }
	
	      }
	
	    },
	
	    reset: function ( renderTarget ) {
	
	      if ( renderTarget === undefined ) {
	
	        renderTarget = this.renderTarget1.clone();
	
	        renderTarget.width = window.innerWidth;
	        renderTarget.height = window.innerHeight;
	
	      }
	
	      this.renderTarget1 = renderTarget;
	      this.renderTarget2 = renderTarget.clone();
	
	      this.writeBuffer = this.renderTarget1;
	      this.readBuffer = this.renderTarget2;
	
	    },
	
	    setSize: function ( width, height ) {
	
	      var renderTarget = this.renderTarget1.clone();
	
	      renderTarget.width = width;
	      renderTarget.height = height;
	
	      this.reset( renderTarget );
	
	    }
	
	  };
	
	  // shared ortho camera
	
	  EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	
	  EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
	
	  EffectComposer.scene = new THREE.Scene();
	  EffectComposer.scene.add( EffectComposer.quad );
	
	  return EffectComposer
	};

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Full-screen textured quad shader
	 */
	
	module.exports = {
	  uniforms: {
	    "tDiffuse": { type: "t", value: null },
	    "opacity":  { type: "f", value: 1.0 }
	  },
	  vertexShader: [
	    "varying vec2 vUv;",
	
	    "void main() {",
	
	      "vUv = uv;",
	      "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
	    "}"
	  ].join("\n"),
	  fragmentShader: [
	    "uniform float opacity;",
	
	    "uniform sampler2D tDiffuse;",
	
	    "varying vec2 vUv;",
	
	    "void main() {",
	
	      "vec4 texel = texture2D( tDiffuse, vUv );",
	      "gl_FragColor = opacity * texel;",
	
	    "}"
	  ].join("\n")
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	module.exports = function(THREE) {
	  function RenderPass( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
	    if (!(this instanceof RenderPass)) return new RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha);
	
	    this.scene = scene;
	    this.camera = camera;
	
	    this.overrideMaterial = overrideMaterial;
	
	    this.clearColor = clearColor;
	    this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;
	
	    this.oldClearColor = new THREE.Color();
	    this.oldClearAlpha = 1;
	
	    this.enabled = true;
	    this.clear = true;
	    this.needsSwap = false;
	
	  };
	
	  RenderPass.prototype = {
	
	    render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
	      this.scene.overrideMaterial = this.overrideMaterial;
	
	      if ( this.clearColor ) {
	
	        this.oldClearColor.copy( renderer.getClearColor() );
	        this.oldClearAlpha = renderer.getClearAlpha();
	
	        renderer.setClearColor( this.clearColor, this.clearAlpha );
	
	      }
	
	      renderer.render( this.scene, this.camera, readBuffer, this.clear );
	
	      if ( this.clearColor ) {
	
	        renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );
	
	      }
	
	      this.scene.overrideMaterial = null;
	
	    }
	
	  };
	
	  return RenderPass;
	
	};


/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	module.exports = function(THREE, EffectComposer) {
	  function ShaderPass( shader, textureID ) {
	    if (!(this instanceof ShaderPass)) return new ShaderPass(shader, textureID);
	
	    this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";
	
	    this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
	    this.material = new THREE.ShaderMaterial( {
	
	      uniforms: this.uniforms,
	      vertexShader: shader.vertexShader,
	      fragmentShader: shader.fragmentShader
	
	    } );
	
	    this.renderToScreen = false;
	
	    this.enabled = true;
	    this.needsSwap = true;
	    this.clear = false;
	
	  };
	
	  ShaderPass.prototype = {
	
	    render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
	      if ( this.uniforms[ this.textureID ] ) {
	
	        this.uniforms[ this.textureID ].value = readBuffer;
	
	      }
	
	      EffectComposer.quad.material = this.material;
	
	      if ( this.renderToScreen ) {
	
	        renderer.render( EffectComposer.scene, EffectComposer.camera );
	
	      } else {
	
	        renderer.render( EffectComposer.scene, EffectComposer.camera, writeBuffer, this.clear );
	
	      }
	
	    }
	
	  };
	
	  return ShaderPass;
	
	};

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	module.exports = function(THREE) {
	  function MaskPass( scene, camera ) {
	    if (!(this instanceof MaskPass)) return new MaskPass(scene, camera);
	
	    this.scene = scene;
	    this.camera = camera;
	
	    this.enabled = true;
	    this.clear = true;
	    this.needsSwap = false;
	
	    this.inverse = false;
	  };
	
	  MaskPass.prototype = {
	
	    render: function ( renderer, writeBuffer, readBuffer, delta ) {
	
	      var context = renderer.context;
	
	      // don't update color or depth
	
	      context.colorMask( false, false, false, false );
	      context.depthMask( false );
	
	      // set up stencil
	
	      var writeValue, clearValue;
	
	      if ( this.inverse ) {
	
	        writeValue = 0;
	        clearValue = 1;
	
	      } else {
	
	        writeValue = 1;
	        clearValue = 0;
	
	      }
	
	      context.enable( context.STENCIL_TEST );
	      context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
	      context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
	      context.clearStencil( clearValue );
	
	      // draw into the stencil buffer
	
	      renderer.render( this.scene, this.camera, readBuffer, this.clear );
	      renderer.render( this.scene, this.camera, writeBuffer, this.clear );
	
	      // re-enable update of color and depth
	
	      context.colorMask( true, true, true, true );
	      context.depthMask( true );
	
	      // only render where stencil is set to 1
	
	      context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
	      context.stencilOp( context.KEEP, context.KEEP, context.KEEP );
	
	    }
	
	  };
	
	  return MaskPass
	};


/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	module.exports = function(THREE) {
	  function ClearMaskPass() {
	    if (!(this instanceof ClearMaskPass)) return new ClearMaskPass(scene, camera);
	    this.enabled = true;
	  };
	
	  ClearMaskPass.prototype = {
	    render: function ( renderer, writeBuffer, readBuffer, delta ) {
	      var context = renderer.context;
	      context.disable( context.STENCIL_TEST );
	    }
	  };
	
	  return ClearMaskPass
	};

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = "// we use this vertex shader for the post process steps. All we do is copy the uv value and set position appropriately\n\nvarying vec2 f_uv;\n\nvoid main() {\n    f_uv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D tDiffuse;\nuniform float u_amount;\nuniform float speed;\nuniform float time;\nuniform float rollSpeed;\nuniform float distortion;\nuniform float distortion2;\nvarying vec2 f_uv;\n\n// Noise directly from https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// Influence from https://github.com/felixturner/bad-tv-shader/blob/master/BadTVShader.js\nvoid main() {\n    float roll = f_uv.y - time * speed;\n\n    float offset = snoise(vec2(roll * 3.0, 0.0)) * 0.2;\n    offset *= distortion * distortion * offset * offset;\n    offset += snoise(vec2(roll * 50.0, 0.0) * 0.001);\n\n    vec4 col = texture2D(tDiffuse, vec2( fract(f_uv.x + offset), fract(f_uv.y - time * rollSpeed)));\n\n    gl_FragColor = col;\n}\n"

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var THREE = __webpack_require__(6);
	var EffectComposer = __webpack_require__(41)(THREE);
	
	var on = false;
	function turnOn() {
	  on = true;
	}
	function turnOff() {
	  on = false;
	}
	function isOn() {
	  return on;
	}
	
	var shader = new EffectComposer.ShaderPass({
	  uniforms: {
	    tDiffuse: {
	      type: 't',
	      value: null
	    },
	    u_amount: {
	      type: 'f',
	      value: 1.0
	    },
	    aberration: {
	      type: 'f',
	      value: 0.0
	    }
	  },
	  vertexShader: __webpack_require__(47),
	  fragmentShader: __webpack_require__(50)
	});
	
	exports.default = {
	  shader: shader,
	  turnOn: turnOn,
	  turnOff: turnOff,
	  isOn: isOn
	};

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D tDiffuse;\nuniform float u_amount;\nuniform float aberration;\nvarying vec2 f_uv;\n\n// Influence from https://forum.unity3d.com/threads/rgb-split-shader.220068/\n// Chromatic aberration!!!!!! Fun\nvoid main() {\n\n  float r = texture2D(tDiffuse, vec2(f_uv.x - aberration, f_uv.y)).r;\n  float g = texture2D(tDiffuse, f_uv).g;\n  float b = texture2D(tDiffuse, vec2(f_uv.x + aberration, f_uv.y)).b;\n\n  gl_FragColor = vec4(r, g, b, 1.0);\n}\n"

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var THREE = __webpack_require__(6);
	var EffectComposer = __webpack_require__(41)(THREE);
	
	var on = false;
	function turnOn() {
	  on = true;
	}
	function turnOff() {
	  on = false;
	}
	function isOn() {
	  return on;
	}
	
	var shader = new EffectComposer.ShaderPass({
	  uniforms: {
	    tDiffuse: {
	      type: 't',
	      value: null
	    },
	    u_amount: {
	      type: 'f',
	      value: 1.0
	    },
	    scale: {
	      type: 'f',
	      value: 1.0
	    }
	  },
	  vertexShader: __webpack_require__(47),
	  fragmentShader: __webpack_require__(52)
	});
	
	exports.default = {
	  shader: shader,
	  turnOn: turnOn,
	  turnOff: turnOff,
	  isOn: isOn
	};

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D tDiffuse;\nuniform float u_amount;\nuniform float scale;\nvarying vec2 f_uv;\n\nfloat gray(vec4 col) {\n  return col.r * 0.3 + col.g * 0.59 + col.b * 0.11;\n}\n\n// Influence from https://threejs.org/examples/webgl_postprocessing.html\nfloat pattern() {\n  vec2 center = vec2(0.5, 0.5);\n  vec2 tSize = vec2(256,256);\n  float pScale = 4.0;\n\n  float s = sin(1.5);\n  float c = cos(1.5);\n  vec2 tex = f_uv * tSize - center;\n  vec2 point = vec2(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * pScale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main() {\n    vec4 col = texture2D(tDiffuse, f_uv);\n    float pat = pattern();\n    float brightness = 1.1;\n\n    float r = col.r * pat * brightness;\n    float g = col.g * pat * brightness;\n    float b = col.b * pat * brightness;\n\n    gl_FragColor = vec4(r, g, b, 1.0);\n}\n"

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var THREE = __webpack_require__(6);
	var EffectComposer = __webpack_require__(41)(THREE);
	
	var on = false;
	function turnOn() {
	  on = true;
	}
	function turnOff() {
	  on = false;
	}
	function isOn() {
	  return on;
	}
	
	var shader = new EffectComposer.ShaderPass({
	  uniforms: {
	    tDiffuse: {
	      type: 't',
	      value: null
	    },
	    u_amount: {
	      type: 'f',
	      value: 1.0
	    },
	    scale: {
	      type: 'f',
	      value: 1.0
	    }
	  },
	  vertexShader: __webpack_require__(47),
	  fragmentShader: __webpack_require__(54)
	});
	
	exports.default = {
	  shader: shader,
	  turnOn: turnOn,
	  turnOff: turnOff,
	  isOn: isOn
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D tDiffuse;\nuniform float u_amount;\nuniform float scale;\nvarying vec2 f_uv;\n\nfloat gray(vec4 col) {\n  return col.r * 0.3 + col.g * 0.59 + col.b * 0.11;\n}\n\n// Influence from https://threejs.org/examples/webgl_postprocessing.html\nfloat pattern() {\n  vec2 center = vec2(0.5, 0.5);\n  vec2 tSize = vec2(256, 256);\n  float pScale = 4.0 + scale * 0.01;\n\n  float s = sin(1.5);\n  float c = cos(1.5);\n  vec2 tex = f_uv * tSize - center;\n  vec2 point = vec2(c * tex.x - s * tex.y, s * tex.x + c * tex.y) * pScale;\n  return (sin(point.x) * sin(point.y)) * 4.0;\n}\n\nvoid main() {\n    vec4 col = texture2D(tDiffuse, f_uv);\n    float pat = pattern();\n    float brightness = 1.1;\n\n    float avg = (col.r + col.g + col.b) / 3.0;\n    gl_FragColor = vec4(vec3(avg * 10.0 - 5.0 + pat), 1.0);\n}\n"

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var THREE = __webpack_require__(6);
	var EffectComposer = __webpack_require__(41)(THREE);
	
	var on = false;
	function turnOn() {
	  on = true;
	}
	function turnOff() {
	  on = false;
	}
	function isOn() {
	  return on;
	}
	
	var shader = new EffectComposer.ShaderPass({
	  uniforms: {
	    tDiffuse: {
	      type: 't',
	      value: null
	    },
	    u_amount: {
	      type: 'f',
	      value: 1.0
	    }
	  },
	  vertexShader: __webpack_require__(47),
	  fragmentShader: __webpack_require__(56)
	});
	
	exports.default = {
	  shader: shader,
	  turnOn: turnOn,
	  turnOff: turnOff,
	  isOn: isOn
	};

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D tDiffuse;\nuniform float u_amount;\nvarying vec2 f_uv;\n\nfloat gray(vec4 col) {\n  return col.r * 0.3 + col.g * 0.59 + col.b * 0.11;\n}\n\nvoid main() {\n    vec4 col = texture2D(tDiffuse, f_uv);\n\n    float sat = 5.0;\n    float gray = gray(col);\n\n    float r = sat * col.r + (1.0 - sat) * (col.r + (gray - col.r));\n    float g = sat * col.g + (1.0 - sat) * (col.g + (gray - col.g));\n    float b = sat * col.b + (1.0 - sat) * (col.b + (gray - col.b));\n\n    gl_FragColor = col;//vec4(r, g, b, 1.0);\n}\n"

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var THREE = __webpack_require__(6);
	var EffectComposer = __webpack_require__(41)(THREE);
	
	var on = false;
	function turnOn() {
	  on = true;
	}
	function turnOff() {
	  on = false;
	}
	function isOn() {
	  return on;
	}
	
	var shader = new EffectComposer.ShaderPass({
	  uniforms: {
	    tDiffuse: {
	      type: 't',
	      value: null
	    },
	    u_amount: {
	      type: 'f',
	      value: 1.0
	    },
	    warmth: {
	      type: 'f',
	      value: 1.0
	    },
	    time: {
	      type: 'f',
	      value: 0.0
	    },
	    size: {
	      type: 'f',
	      value: 0.0
	    }
	  },
	  vertexShader: __webpack_require__(47),
	  fragmentShader: __webpack_require__(58)
	});
	
	exports.default = {
	  shader: shader,
	  turnOn: turnOn,
	  turnOff: turnOff,
	  isOn: isOn
	};

/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "uniform sampler2D tDiffuse;\nuniform float u_amount;\nuniform float warmth;\nuniform float time;\nuniform float size;\nvarying vec2 f_uv;\n\n// noise function returns range [-1,1]\nfloat noise1(float x, float y, float z){\n\tfloat value1 = fract(sin(dot(vec2(z, y) ,vec2(1027.9898, 29381.233))) * 333019.5453);\n\tfloat value2 = fract(sin(x) * 43758.5453);\n\treturn dot(value1, value2);\n}\n\nvoid main() {\n    vec4 col = texture2D(tDiffuse, f_uv);\n    float brightness = 0.7;\n    float lightness = 0.7;\n    float red = warmth + 0.2;\n    float yel = warmth;\n\n    // grain - https://www.reddit.com/r/opengl/comments/1rr4fy/any_good_ways_of_generating_film_grain_noise/\n    float strength = 50.0;\n    float x = (f_uv.x + 4.0) * (f_uv.y + 4.0) * (time * 10.0);\n    vec3 grain = vec3(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005);\n    grain *= strength;\n\n    float offset2 = 0.01;\n    float offsetSz = 25.0;\n    if (size > 90.0) {\n      offset2 = 0.03;\n      offsetSz = 6.0;\n    }\n\n    if (mod(floor(f_uv.y * offsetSz * 2.0) - offsetSz, 7.0) == 0.0) {\n      vec2 p = vec2(f_uv.x, f_uv.y + offset2);\n      col = texture2D(tDiffuse, p);\n      brightness *= 2.0;\n    }\n\n    col.r += grain.x;\n    col.g += grain.y;\n    col.b += grain.z;\n\n    col.r = col.r * brightness + lightness + red;\n    col.g = col.g * brightness + lightness;\n    col.b = col.b * brightness + lightness - yel;\n\n    // CRT scanlines https://gamedev.stackexchange.com/questions/64036/how-can-i-implement-a-scanline-effect\n    float y = f_uv.y * 500.0;\n    float d = floor(y) - y;\n    float d_sq = d * d;\n\n    if (d_sq > 0.1) {\n      col.r *= 0.5;\n      col.g *= 0.5;\n      col.b *= 0.5;\n    }\n\n    gl_FragColor = col;\n\n}\n"

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _pitchHelper = __webpack_require__(60);
	
	var _pitchHelper2 = _interopRequireDefault(_pitchHelper);
	
	var _webAudioBeatDetector = __webpack_require__(61);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var THREE = __webpack_require__(6);
	
	var playing = false;
	var context;
	var sourceNode, sourceJs;
	var gainNode;
	var analyser;
	var buffer;
	var jsNode;
	var splitter;
	var array = new Array();
	var reset = true;
	var tempo = 0;
	function init(path, initWorlds) {
	  if (!window.AudioContext) {
	    // check if the default naming is enabled, if not use the chrome one.
	    if (!window.webkitAudioContext) alert('no audiocontext found');
	    window.AudioContext = window.webkitAudioContext;
	  }
	  context = new AudioContext();
	  loadSound(path, initWorlds);
	}
	
	// load the specified sound
	function loadSound(url, initWorlds) {
	  var request = new XMLHttpRequest();
	  request.open('GET', url, true);
	  request.responseType = 'arraybuffer';
	  request.onload = function () {
	    context.decodeAudioData(request.response, function (buffer) {
	      if (!buffer) {
	        // Error decoding file data
	        return;
	      }
	      sourceNode = context.createBufferSource();
	      sourceNode.buffer = buffer;
	
	      sourceJs = context.createScriptProcessor(2048, 1, 1);
	      sourceJs.buffer = buffer;
	
	      analyser = context.createAnalyser();
	      analyser.smoothingTimeConstant = 0.3;
	      analyser.fftSize = 512;
	
	      sourceNode.connect(analyser);
	      analyser.connect(sourceJs);
	
	      gainNode = context.createGain();
	      sourceNode.connect(gainNode);
	      sourceJs.connect(gainNode);
	      gainNode.connect(context.destination);
	      reset = true;
	
	      detectBeat();
	      initWorlds();
	      playing = true;
	    }, function (e) {
	      console.log(e);
	    });
	  };
	  request.send();
	}
	
	function playOnLoad(url, updateAnalysers) {
	  var request = new XMLHttpRequest();
	  request.open('GET', url, true);
	  request.responseType = 'arraybuffer';
	  request.onload = function () {
	    context.decodeAudioData(request.response, function (buffer) {
	      if (!buffer) {
	        // Error decoding file data
	        return;
	      }
	      sourceNode = context.createBufferSource();
	      sourceNode.buffer = buffer;
	
	      sourceJs = context.createScriptProcessor(2048, 1, 1);
	      sourceJs.buffer = buffer;
	
	      analyser = context.createAnalyser();
	      analyser.smoothingTimeConstant = 0.3;
	      analyser.fftSize = 512;
	
	      sourceNode.connect(analyser);
	      analyser.connect(sourceJs);
	
	      gainNode = context.createGain();
	      sourceNode.connect(gainNode);
	      sourceJs.connect(gainNode);
	      gainNode.connect(context.destination);
	
	      detectBeat();
	
	      playSound();
	      updateAnalysers();
	    }, function (e) {
	      console.log(e);
	    });
	  };
	  request.send();
	}
	
	function stopSound() {
	  sourceNode.stop();
	  playing = false;
	}
	
	function mute() {
	  gainNode.gain.value = 0;
	}
	
	function unmute() {
	  gainNode.gain.value = 1;
	}
	
	function isPlaying() {
	  return playing;
	}
	
	function setMusic(name, updateAnalysers) {
	  stopSound();
	  playOnLoad('./audio/' + name + '.mp3', updateAnalysers);
	}
	
	function playSound() {
	  sourceNode.start(0);
	  playing = true;
	}
	
	function getAverageVolume(array) {
	  var values = 0;
	  for (var i = 0; i < array.length; i++) {
	    values += array[i];
	  }
	  return values / array.length;
	}
	
	// Calculated based on the volume / amplitude
	function getSizeFromSound() {
	  var arr = new Uint8Array(analyser.frequencyBinCount);
	  analyser.getByteFrequencyData(arr);
	  return getAverageVolume(arr);
	}
	
	function detectPitch() {
	  var buffer = new Uint8Array(analyser.fftSize);
	  analyser.getByteTimeDomainData(buffer);
	
	  var fundamentalFreq = _pitchHelper2.default.findFundamentalFreq(buffer, context.sampleRate);
	
	  if (fundamentalFreq !== -1) {
	    return fundamentalFreq;
	  }
	}
	
	// Returns a new color based on the given color
	// Calculated based on the pitch of the audio
	function getColorFromSound(oldColor) {
	  var color = oldColor;
	  var pitch = detectPitch();
	  if (pitch) {
	    var hex = Math.floor(pitch).toString(16);
	    hex = ("000" + hex).substr(-3);
	    color = new THREE.Color("#" + hex);
	
	    var r = 0.9 * oldColor.r + 0.1 * color.r;
	    var g = 0.9 * oldColor.g + 0.1 * color.g;
	    var b = 0.9 * oldColor.b + 0.1 * color.b;
	    color = new THREE.Color(r / 1.1, g / 1.2, b);
	    // console.log(color);
	  }
	  return color;
	}
	
	// Detects the bpm and returns it (tempo)
	// Only needs to be called once per song
	function detectBeat() {
	  (0, _webAudioBeatDetector.analyze)(sourceNode.buffer).then(function (tmp) {
	    console.log("Tempo: " + tmp);
	    tempo = tmp;
	    return tmp;
	  }).catch(function (err) {
	    console.log(err);
	  });
	}
	
	function getRateFromSound() {
	  // var offset = (tempo - 140) / 2000
	  // return offset;
	  return tempo;
	}
	
	function getArray() {
	  return array;
	}
	function getSourceJS() {
	  return sourceJs;
	}
	function getAnalyser() {
	  return analyser;
	}
	
	exports.default = {
	  playSound: playSound,
	  getAnalyser: getAnalyser,
	  getSourceJS: getSourceJS,
	  getArray: getArray,
	  init: init,
	  mute: mute,
	  unmute: unmute,
	  setMusic: setMusic,
	  isPlaying: isPlaying,
	  getSizeFromSound: getSizeFromSound,
	  getColorFromSound: getColorFromSound,
	  getRateFromSound: getRateFromSound
	};

/***/ },
/* 60 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	// Autocorrelation
	// https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/webaudiotuner/
	function findFundamentalFreq(buffer, sampleRate) {
		var n = 1024,
		    // number of samples for each k
		bestR = 0,
		    // correlation
		bestK = -1; // period we are trying to find
	
		// Time delay k
		for (var k = 8; k <= 1000; k++) {
			var sum = 0;
			for (var t = 0; t < n; t++) {
				//Check values at times t and t + k
				if (buffer[t] && buffer[t + k]) {
					sum += (buffer[t] - 128) / 128 * ((buffer[t + k] - 128) / 128);
				}
			}
			var r = sum / (n + k);
			if (r > bestR) {
				// if the correlation is better, set bestR and bestK
				bestR = r;
				bestK = k;
			}
			if (r > 0.9) break;
		}
	
		if (bestR > 0.0025) {
			// if high enough correlation
			return sampleRate / bestK; // get the fundamental freq from the period
		} else {
			return -1;
		}
	}
	
	exports.default = {
		findFundamentalFreq: findFundamentalFreq
	};

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(62)) :
		typeof define === 'function' && define.amd ? define(['exports', 'standardized-audio-context'], factory) :
		(factory((global.webAudioBeatDetector = global.webAudioBeatDetector || {}),global.standardizedAudioContext));
	}(this, (function (exports,standardizedAudioContext) { 'use strict';
	
	var _this = undefined;
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) {
	            try {
	                step(generator.next(value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function rejected(value) {
	            try {
	                step(generator["throw"](value));
	            } catch (e) {
	                reject(e);
	            }
	        }
	        function step(result) {
	            result.done ? resolve(result.value) : new P(function (resolve) {
	                resolve(result.value);
	            }).then(fulfilled, rejected);
	        }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var INITIAL_THRESHOLD = 0.9;
	var MINUMUM_NUMBER_OF_PEAKS = 30;
	var MINIMUM_THRESHOLD = 0.3;
	var countIntervalsBetweenNearbyPeaks = function countIntervalsBetweenNearbyPeaks(peaks) {
	    var intervalBuckets = [];
	    peaks.forEach(function (peak, index) {
	        var length = Math.min(peaks.length - index, 10);
	
	        var _loop = function _loop(i) {
	            var interval = peaks[index + i] - peak;
	            var foundInterval = intervalBuckets.some(function (intervalBucket) {
	                if (intervalBucket.interval === interval) {
	                    intervalBucket.peaks.push(peak);
	                    return true;
	                }
	                return false;
	            });
	            if (!foundInterval) {
	                intervalBuckets.push({
	                    peaks: [peak],
	                    interval: interval
	                });
	            }
	        };
	
	        for (var i = 1; i < length; i += 1) {
	            _loop(i);
	        }
	    });
	    return intervalBuckets;
	};
	var getPeaksAtThreshold = function getPeaksAtThreshold(channelData, threshold, sampleRate) {
	    var peaks = [];
	    var length = channelData.length;
	    for (var i = 0; i < length; i += 1) {
	        if (channelData[i] > threshold) {
	            peaks.push(i);
	            // Skip 0.25 seconds forward to get past this peak.
	            i += sampleRate / 4 - 1;
	        }
	    }
	    return peaks;
	};
	var groupNeighborsByTempo = function groupNeighborsByTempo(intervalBuckets, sampleRate) {
	    var tempoBuckets = [];
	    intervalBuckets.forEach(function (intervalBucket) {
	        // Convert an interval to a tempo (aka BPM).
	        var theoreticalTempo = 60 / (intervalBucket.interval / sampleRate);
	        // Adjust the tempo to fit within the 90-180 BPM range.
	        while (theoreticalTempo < 90) {
	            theoreticalTempo *= 2;
	        }
	        while (theoreticalTempo > 180) {
	            theoreticalTempo /= 2;
	        }
	        var foundTempo = tempoBuckets.some(function (tempoCount) {
	            if (tempoCount.tempo === theoreticalTempo) {
	                tempoCount.peaks = [].concat(_toConsumableArray(tempoCount.peaks), _toConsumableArray(intervalBucket.peaks));
	                return true;
	            }
	            return false;
	        });
	        if (!foundTempo) {
	            tempoBuckets.push({
	                peaks: intervalBucket.peaks,
	                tempo: theoreticalTempo
	            });
	        }
	    });
	    return tempoBuckets;
	};
	var computeTempoBuckets = function computeTempoBuckets(audioBuffer, offset, duration) {
	    var offlineAudioContext = new standardizedAudioContext.OfflineAudioContext(audioBuffer.numberOfChannels, duration * audioBuffer.sampleRate, audioBuffer.sampleRate);
	    var biquadFilter = offlineAudioContext.createBiquadFilter();
	    var bufferSourceNode = offlineAudioContext.createBufferSource();
	    biquadFilter.frequency.value = 200;
	    biquadFilter.type = 'lowpass';
	    bufferSourceNode.buffer = audioBuffer;
	    bufferSourceNode.connect(biquadFilter).connect(offlineAudioContext.destination);
	    bufferSourceNode.start(0, offset, duration);
	    return offlineAudioContext.startRendering().then(function (renderedBuffer) {
	        var peaks = [];
	        var threshold = INITIAL_THRESHOLD;
	        var channelData = new Float32Array(renderedBuffer.length);
	        renderedBuffer.copyFromChannel(channelData, 0);
	        while (peaks.length < MINUMUM_NUMBER_OF_PEAKS && threshold >= MINIMUM_THRESHOLD) {
	            peaks = getPeaksAtThreshold(channelData, threshold, renderedBuffer.sampleRate);
	            threshold -= 0.05;
	        }
	        var intervalBuckets = countIntervalsBetweenNearbyPeaks(peaks);
	        var tempoBuckets = groupNeighborsByTempo(intervalBuckets, renderedBuffer.sampleRate);
	        tempoBuckets.sort(function (a, b) {
	            return b.peaks.length - a.peaks.length;
	        });
	        return tempoBuckets;
	    });
	};
	var analyze = function analyze(audioBuffer) {
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : audioBuffer.duration - offset;
	    return __awaiter(_this, void 0, void 0, regeneratorRuntime.mark(function _callee() {
	        var tempoBuckets;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	            while (1) {
	                switch (_context.prev = _context.next) {
	                    case 0:
	                        _context.next = 2;
	                        return computeTempoBuckets(audioBuffer, offset, duration);
	
	                    case 2:
	                        tempoBuckets = _context.sent;
	                        return _context.abrupt('return', tempoBuckets[0].tempo);
	
	                    case 4:
	                    case 'end':
	                        return _context.stop();
	                }
	            }
	        }, _callee, this);
	    }));
	};
	var guess = function guess(audioBuffer) {
	    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : audioBuffer.duration - offset;
	    return __awaiter(_this, void 0, void 0, regeneratorRuntime.mark(function _callee2() {
	        var tempoBuckets, _tempoBuckets$, peaks, tempo, bpm, secondsPerBeat;
	
	        return regeneratorRuntime.wrap(function _callee2$(_context2) {
	            while (1) {
	                switch (_context2.prev = _context2.next) {
	                    case 0:
	                        _context2.next = 2;
	                        return computeTempoBuckets(audioBuffer, offset, duration);
	
	                    case 2:
	                        tempoBuckets = _context2.sent;
	                        _tempoBuckets$ = tempoBuckets[0], peaks = _tempoBuckets$.peaks, tempo = _tempoBuckets$.tempo;
	                        bpm = Math.round(tempo);
	                        secondsPerBeat = 60 / bpm;
	
	                        peaks.sort(function (a, b) {
	                            return a - b;
	                        });
	                        offset = peaks[0] / audioBuffer.sampleRate;
	                        while (offset > secondsPerBeat) {
	                            offset -= secondsPerBeat;
	                        }
	                        return _context2.abrupt('return', {
	                            bpm: bpm,
	                            offset: offset
	                        });
	
	                    case 10:
	                    case 'end':
	                        return _context2.stop();
	                }
	            }
	        }, _callee2, this);
	    }));
	};
	
	exports.analyze = analyze;
	exports.guess = guess;
	exports.isSupported = standardizedAudioContext.isSupported;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(63), __webpack_require__(144)) :
		typeof define === 'function' && define.amd ? define(['exports', 'core-js/es7/reflect', '@angular/core'], factory) :
		(factory((global.standardizedAudioContext = global.standardizedAudioContext || {}),null,global._angular_core));
	}(this, (function (exports,coreJs_es7_reflect,_angular_core) { 'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DataCloneErrorFactory = function () {
	    function DataCloneErrorFactory() {
	        _classCallCheck(this, DataCloneErrorFactory);
	    }
	
	    _createClass(DataCloneErrorFactory, [{
	        key: 'create',
	        value: function create() {
	            try {
	                return new DOMException('', 'DataCloneError');
	            } catch (err) {
	                var exception = new Error();
	                exception.code = 25;
	                exception.name = 'DataCloneError';
	                return exception;
	            }
	        }
	    }]);
	
	    return DataCloneErrorFactory;
	}();
	
	var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var EncodingErrorFactory = function () {
	    function EncodingErrorFactory() {
	        _classCallCheck$1(this, EncodingErrorFactory);
	    }
	
	    _createClass$1(EncodingErrorFactory, [{
	        key: 'create',
	        value: function create() {
	            try {
	                return new DOMException('', 'EncodingError');
	            } catch (err) {
	                var exception = new Error();
	                exception.code = 0;
	                exception.name = 'EncodingError';
	                return exception;
	            }
	        }
	    }]);
	
	    return EncodingErrorFactory;
	}();
	
	var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var IndexSizeErrorFactory = function () {
	    function IndexSizeErrorFactory() {
	        _classCallCheck$2(this, IndexSizeErrorFactory);
	    }
	
	    _createClass$2(IndexSizeErrorFactory, [{
	        key: 'create',
	        value: function create() {
	            try {
	                return new DOMException('', 'IndexSizeError');
	            } catch (err) {
	                var exception = new Error();
	                exception.code = 1;
	                exception.name = 'IndexSizeError';
	                return exception;
	            }
	        }
	    }]);
	
	    return IndexSizeErrorFactory;
	}();
	
	var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var InvalidAccessErrorFactory = function () {
	    function InvalidAccessErrorFactory() {
	        _classCallCheck$3(this, InvalidAccessErrorFactory);
	    }
	
	    _createClass$3(InvalidAccessErrorFactory, [{
	        key: 'create',
	        value: function create() {
	            try {
	                return new DOMException('', 'InvalidAccessError');
	            } catch (err) {
	                var exception = new Error();
	                exception.code = 15;
	                exception.name = 'InvalidAccessError';
	                return exception;
	            }
	        }
	    }]);
	
	    return InvalidAccessErrorFactory;
	}();
	
	var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var InvalidStateErrorFactory = function () {
	    function InvalidStateErrorFactory() {
	        _classCallCheck$4(this, InvalidStateErrorFactory);
	    }
	
	    _createClass$4(InvalidStateErrorFactory, [{
	        key: 'create',
	        value: function create() {
	            try {
	                return new DOMException('', 'InvalidStateError');
	            } catch (err) {
	                var exception = new Error();
	                exception.code = 11;
	                exception.name = 'InvalidStateError';
	                return exception;
	            }
	        }
	    }]);
	
	    return InvalidStateErrorFactory;
	}();
	
	var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NotSupportedErrorFactory = function () {
	    function NotSupportedErrorFactory() {
	        _classCallCheck$5(this, NotSupportedErrorFactory);
	    }
	
	    _createClass$5(NotSupportedErrorFactory, [{
	        key: 'create',
	        value: function create() {
	            try {
	                return new DOMException('', 'NotSupportedError');
	            } catch (err) {
	                var exception = new Error();
	                exception.code = 9;
	                exception.name = 'NotSupportedError';
	                return exception;
	            }
	        }
	    }]);
	
	    return NotSupportedErrorFactory;
	}();
	
	var _createClass$7 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OfflineAudioNodeProxy = function () {
	    function OfflineAudioNodeProxy(_ref) {
	        var channelCountMode = _ref.channelCountMode,
	            channelInterpretation = _ref.channelInterpretation,
	            fakeNodeStore = _ref.fakeNodeStore,
	            numberOfInputs = _ref.numberOfInputs,
	            numberOfOutputs = _ref.numberOfOutputs;
	
	        _classCallCheck$7(this, OfflineAudioNodeProxy);
	
	        this._channelCountMode = channelCountMode;
	        this._channelInterpretation = channelInterpretation;
	        this._fakeNodeStore = fakeNodeStore;
	        this._numberOfInputs = numberOfInputs;
	        this._numberOfOutputs = numberOfOutputs;
	    }
	
	    _createClass$7(OfflineAudioNodeProxy, [{
	        key: 'connect',
	        value: function connect(destination) {
	            var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	            var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	            var faker = this._fakeNodeStore.get(destination);
	            if (faker === undefined) {
	                var exception = void 0;
	                try {
	                    exception = new DOMException('', 'InvalidAccessError');
	                } catch (err) {
	                    exception = new Error();
	                    exception.code = 15;
	                    exception.name = 'InvalidAccessError';
	                }
	                throw exception;
	            }
	            return faker.wire(this._fakeNodeStore.get(this), output, input);
	        }
	    }, {
	        key: 'disconnect',
	        value: function disconnect(destination) {
	            var faker = this._fakeNodeStore.get(destination);
	            return faker.unwire(this._fakeNodeStore.get(this));
	        }
	    }, {
	        key: 'channelCountMode',
	        get: function get() {
	            return this._channelCountMode;
	        },
	        set: function set(value) {
	            this._channelCountMode = value;
	        }
	    }, {
	        key: 'channelInterpretation',
	        get: function get() {
	            return this._channelInterpretation;
	        },
	        set: function set(value) {
	            this._channelInterpretation = value;
	        }
	    }, {
	        key: 'numberOfInputs',
	        get: function get() {
	            return this._numberOfInputs;
	        },
	        set: function set(value) {
	            this._numberOfInputs = value;
	        }
	    }, {
	        key: 'numberOfOutputs',
	        get: function get() {
	            return this._numberOfOutputs;
	        },
	        set: function set(value) {
	            this._numberOfOutputs = value;
	        }
	    }]);
	
	    return OfflineAudioNodeProxy;
	}();
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OfflineAudioBufferSourceNodeFakerProxy = function (_OfflineAudioNodeProx) {
	    _inherits(OfflineAudioBufferSourceNodeFakerProxy, _OfflineAudioNodeProx);
	
	    function OfflineAudioBufferSourceNodeFakerProxy(_ref) {
	        var fakeNodeStore = _ref.fakeNodeStore;
	
	        _classCallCheck$6(this, OfflineAudioBufferSourceNodeFakerProxy);
	
	        var _this = _possibleConstructorReturn(this, (OfflineAudioBufferSourceNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineAudioBufferSourceNodeFakerProxy)).call(this, { fakeNodeStore: fakeNodeStore }));
	
	        _this._buffer = undefined;
	        _this._ownFakeNodeStore = fakeNodeStore;
	        return _this;
	    }
	
	    _createClass$6(OfflineAudioBufferSourceNodeFakerProxy, [{
	        key: 'start',
	        value: function start() {
	            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	            var duration = arguments[2];
	
	            var faker = this._ownFakeNodeStore.get(this);
	            faker.start = { duration: duration, offset: offset, when: when };
	        }
	    }, {
	        key: 'buffer',
	        get: function get() {
	            return this._buffer;
	        },
	        set: function set(value) {
	            // @todo Allow to set the buffer only onces.
	            this._buffer = value;
	        }
	    }]);
	
	    return OfflineAudioBufferSourceNodeFakerProxy;
	}(OfflineAudioNodeProxy);
	
	var OfflineAudioBufferSourceNodeFaker = function () {
	    function OfflineAudioBufferSourceNodeFaker(_ref2) {
	        var fakeNodeStore = _ref2.fakeNodeStore;
	
	        _classCallCheck$6(this, OfflineAudioBufferSourceNodeFaker);
	
	        this._node = null;
	        this._proxy = new OfflineAudioBufferSourceNodeFakerProxy({ fakeNodeStore: fakeNodeStore });
	        this._sources = new Map();
	        this._start = null;
	        fakeNodeStore.set(this._proxy, this);
	    }
	
	    _createClass$6(OfflineAudioBufferSourceNodeFaker, [{
	        key: 'render',
	        value: function render(offlineAudioContext) {
	            var _this2 = this;
	
	            if (this._node !== null) {
	                return Promise.resolve(this._node);
	            }
	            var promises = [];
	            this._node = offlineAudioContext.createBufferSource();
	            this._node.buffer = this._proxy.buffer;
	            if (this._start !== null) {
	                var _start = this._start,
	                    duration = _start.duration,
	                    offset = _start.offset,
	                    when = _start.when;
	
	                if (duration === undefined) {
	                    this._node.start(when, offset);
	                } else {
	                    this._node.start(when, offset, duration);
	                }
	            }
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                var _loop = function _loop() {
	                    var _step$value = _slicedToArray(_step.value, 2),
	                        source = _step$value[0],
	                        _step$value$ = _step$value[1],
	                        input = _step$value$.input,
	                        output = _step$value$.output;
	
	                    promises.push(source.render(offlineAudioContext).then(function (node) {
	                        return node.connect(_this2._node, output, input);
	                    }));
	                };
	
	                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    _loop();
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return Promise.all(promises).then(function () {
	                return _this2._node;
	            });
	        }
	    }, {
	        key: 'wire',
	        value: function wire(source, output, input) {
	            this._sources.set(source, { input: input, output: output });
	            return this._proxy;
	        }
	    }, {
	        key: 'proxy',
	        get: function get() {
	            return this._proxy;
	        }
	    }, {
	        key: 'start',
	        set: function set(value) {
	            this._start = value;
	        }
	    }]);
	
	    return OfflineAudioBufferSourceNodeFaker;
	}();
	var OfflineAudioBufferSourceNodeFakerFactory = function () {
	    function OfflineAudioBufferSourceNodeFakerFactory() {
	        _classCallCheck$6(this, OfflineAudioBufferSourceNodeFakerFactory);
	    }
	
	    _createClass$6(OfflineAudioBufferSourceNodeFakerFactory, [{
	        key: 'create',
	        value: function create(_ref3) {
	            var fakeNodeStore = _ref3.fakeNodeStore;
	
	            return new OfflineAudioBufferSourceNodeFaker({ fakeNodeStore: fakeNodeStore });
	        }
	    }]);
	
	    return OfflineAudioBufferSourceNodeFakerFactory;
	}();
	
	var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass$8 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OfflineAudioDestinationNodeFakerProxy = function (_OfflineAudioNodeProx) {
	    _inherits$1(OfflineAudioDestinationNodeFakerProxy, _OfflineAudioNodeProx);
	
	    function OfflineAudioDestinationNodeFakerProxy(_ref) {
	        var fakeNodeStore = _ref.fakeNodeStore;
	
	        _classCallCheck$8(this, OfflineAudioDestinationNodeFakerProxy);
	
	        return _possibleConstructorReturn$1(this, (OfflineAudioDestinationNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineAudioDestinationNodeFakerProxy)).call(this, {
	            channelCountMode: 'max',
	            channelInterpretation: 'speakers',
	            fakeNodeStore: fakeNodeStore,
	            numberOfInputs: 1,
	            numberOfOutputs: 0
	        }));
	    }
	
	    _createClass$8(OfflineAudioDestinationNodeFakerProxy, [{
	        key: 'maxChannelCount',
	        get: function get() {
	            // @todo
	            return 2;
	        }
	    }]);
	
	    return OfflineAudioDestinationNodeFakerProxy;
	}(OfflineAudioNodeProxy);
	
	var OfflineAudioDestinationNodeFaker = function () {
	    function OfflineAudioDestinationNodeFaker(_ref2) {
	        var fakeNodeStore = _ref2.fakeNodeStore;
	
	        _classCallCheck$8(this, OfflineAudioDestinationNodeFaker);
	
	        this._node = null;
	        this._proxy = new OfflineAudioDestinationNodeFakerProxy({ fakeNodeStore: fakeNodeStore });
	        this._sources = new Map();
	        fakeNodeStore.set(this._proxy, this);
	    }
	
	    _createClass$8(OfflineAudioDestinationNodeFaker, [{
	        key: 'render',
	        value: function render(offlineAudioContext) {
	            var _this2 = this;
	
	            if (this._node !== null) {
	                return Promise.resolve(this._node);
	            }
	            var promises = [];
	            this._node = offlineAudioContext.destination;
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                var _loop = function _loop() {
	                    var _step$value = _slicedToArray$1(_step.value, 2),
	                        source = _step$value[0],
	                        _step$value$ = _step$value[1],
	                        input = _step$value$.input,
	                        output = _step$value$.output;
	
	                    promises.push(source.render(offlineAudioContext).then(function (node) {
	                        return node.connect(_this2._node, output, input);
	                    }));
	                };
	
	                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    _loop();
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return Promise.all(promises).then(function () {
	                return _this2._node;
	            });
	        }
	    }, {
	        key: 'wire',
	        value: function wire(source, output, input) {
	            this._sources.set(source, { input: input, output: output });
	            return this._proxy;
	        }
	    }, {
	        key: 'proxy',
	        get: function get() {
	            return this._proxy;
	        }
	    }]);
	
	    return OfflineAudioDestinationNodeFaker;
	}();
	var OfflineAudioDestinationNodeFakerFactory = function () {
	    function OfflineAudioDestinationNodeFakerFactory() {
	        _classCallCheck$8(this, OfflineAudioDestinationNodeFakerFactory);
	    }
	
	    _createClass$8(OfflineAudioDestinationNodeFakerFactory, [{
	        key: 'create',
	        value: function create(_ref3) {
	            var fakeNodeStore = _ref3.fakeNodeStore;
	
	            return new OfflineAudioDestinationNodeFaker({ fakeNodeStore: fakeNodeStore });
	        }
	    }]);
	
	    return OfflineAudioDestinationNodeFakerFactory;
	}();
	
	var _slicedToArray$2 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass$9 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OfflineBiquadFilterNodeFakerProxy = function (_OfflineAudioNodeProx) {
	    _inherits$2(OfflineBiquadFilterNodeFakerProxy, _OfflineAudioNodeProx);
	
	    function OfflineBiquadFilterNodeFakerProxy(_ref) {
	        var fakeNodeStore = _ref.fakeNodeStore,
	            nativeNode = _ref.nativeNode;
	
	        _classCallCheck$9(this, OfflineBiquadFilterNodeFakerProxy);
	
	        var _this = _possibleConstructorReturn$2(this, (OfflineBiquadFilterNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineBiquadFilterNodeFakerProxy)).call(this, {
	            channelCountMode: 'max',
	            channelInterpretation: 'speakers',
	            fakeNodeStore: fakeNodeStore,
	            numberOfInputs: 1,
	            numberOfOutputs: 1
	        }));
	
	        _this._nativeNode = nativeNode;
	        _this._type = nativeNode.type;
	        return _this;
	    }
	
	    _createClass$9(OfflineBiquadFilterNodeFakerProxy, [{
	        key: 'getFrequencyResponse',
	        value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
	            return this._nativeNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
	        }
	    }, {
	        key: 'detune',
	        get: function get() {
	            // @todo Fake a proper AudioParam.
	            return {
	                cancelScheduledValues: function cancelScheduledValues() {},
	                defaultValue: 0,
	                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
	                linearRampToValueAtTime: function linearRampToValueAtTime() {},
	                setTargetAtTime: function setTargetAtTime() {},
	                setValueCurveAtTime: function setValueCurveAtTime() {},
	                value: 0
	            };
	        }
	    }, {
	        key: 'frequency',
	        get: function get() {
	            // @todo Fake a proper AudioParam.
	            return {
	                cancelScheduledValues: function cancelScheduledValues() {},
	                defaultValue: 350,
	                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
	                linearRampToValueAtTime: function linearRampToValueAtTime() {},
	                setTargetAtTime: function setTargetAtTime() {},
	                setValueCurveAtTime: function setValueCurveAtTime() {},
	                value: 350
	            };
	        }
	    }, {
	        key: 'gain',
	        get: function get() {
	            // @todo Fake a proper AudioParam.
	            return {
	                cancelScheduledValues: function cancelScheduledValues() {},
	                defaultValue: 0,
	                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
	                linearRampToValueAtTime: function linearRampToValueAtTime() {},
	                setTargetAtTime: function setTargetAtTime() {},
	                setValueCurveAtTime: function setValueCurveAtTime() {},
	                value: 0
	            };
	        }
	    }, {
	        key: 'Q',
	        get: function get() {
	            // @todo Fake a proper AudioParam.
	            return {
	                cancelScheduledValues: function cancelScheduledValues() {},
	                defaultValue: 1,
	                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
	                linearRampToValueAtTime: function linearRampToValueAtTime() {},
	                setTargetAtTime: function setTargetAtTime() {},
	                setValueCurveAtTime: function setValueCurveAtTime() {},
	                value: 1
	            };
	        }
	    }, {
	        key: 'type',
	        get: function get() {
	            return this._type;
	        },
	        set: function set(value) {
	            this._type = value;
	        }
	    }]);
	
	    return OfflineBiquadFilterNodeFakerProxy;
	}(OfflineAudioNodeProxy);
	
	var OfflineBiquadFilterNodeFaker = function () {
	    function OfflineBiquadFilterNodeFaker(_ref2) {
	        var fakeNodeStore = _ref2.fakeNodeStore,
	            nativeNode = _ref2.nativeNode;
	
	        _classCallCheck$9(this, OfflineBiquadFilterNodeFaker);
	
	        this._node = null;
	        this._proxy = new OfflineBiquadFilterNodeFakerProxy({ fakeNodeStore: fakeNodeStore, nativeNode: nativeNode });
	        this._sources = new Map();
	        fakeNodeStore.set(this._proxy, this);
	    }
	
	    _createClass$9(OfflineBiquadFilterNodeFaker, [{
	        key: 'render',
	        value: function render(offlineAudioContext) {
	            var _this2 = this;
	
	            if (this._node !== null) {
	                return Promise.resolve(this._node);
	            }
	            var promises = [];
	            this._node = offlineAudioContext.createBiquadFilter();
	            this._node.type = this._proxy.type;
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                var _loop = function _loop() {
	                    var _step$value = _slicedToArray$2(_step.value, 2),
	                        source = _step$value[0],
	                        _step$value$ = _step$value[1],
	                        input = _step$value$.input,
	                        output = _step$value$.output;
	
	                    promises.push(source.render(offlineAudioContext).then(function (node) {
	                        return node.connect(_this2._node, output, input);
	                    }));
	                };
	
	                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    _loop();
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return Promise.all(promises).then(function () {
	                return _this2._node;
	            });
	        }
	    }, {
	        key: 'wire',
	        value: function wire(source, output, input) {
	            this._sources.set(source, { input: input, output: output });
	            return this._proxy;
	        }
	    }, {
	        key: 'unwire',
	        value: function unwire(source) {
	            this._sources.delete(source);
	        }
	    }, {
	        key: 'proxy',
	        get: function get() {
	            return this._proxy;
	        }
	    }]);
	
	    return OfflineBiquadFilterNodeFaker;
	}();
	var OfflineBiquadFilterNodeFakerFactory = function () {
	    function OfflineBiquadFilterNodeFakerFactory() {
	        _classCallCheck$9(this, OfflineBiquadFilterNodeFakerFactory);
	    }
	
	    _createClass$9(OfflineBiquadFilterNodeFakerFactory, [{
	        key: 'create',
	        value: function create(_ref3) {
	            var fakeNodeStore = _ref3.fakeNodeStore,
	                nativeNode = _ref3.nativeNode;
	
	            return new OfflineBiquadFilterNodeFaker({
	                fakeNodeStore: fakeNodeStore,
	                nativeNode: nativeNode
	            });
	        }
	    }]);
	
	    return OfflineBiquadFilterNodeFakerFactory;
	}();
	
	var _slicedToArray$3 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass$10 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$10(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var OfflineGainNodeFakerProxy = function (_OfflineAudioNodeProx) {
	    _inherits$3(OfflineGainNodeFakerProxy, _OfflineAudioNodeProx);
	
	    function OfflineGainNodeFakerProxy(_ref) {
	        var fakeNodeStore = _ref.fakeNodeStore;
	
	        _classCallCheck$10(this, OfflineGainNodeFakerProxy);
	
	        return _possibleConstructorReturn$3(this, (OfflineGainNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineGainNodeFakerProxy)).call(this, {
	            channelCountMode: 'max',
	            channelInterpretation: 'speakers',
	            fakeNodeStore: fakeNodeStore,
	            numberOfInputs: 1,
	            numberOfOutputs: 1
	        }));
	    }
	
	    _createClass$10(OfflineGainNodeFakerProxy, [{
	        key: 'gain',
	        get: function get() {
	            // @todo Fake a proper AudioParam.
	            return {
	                cancelScheduledValues: function cancelScheduledValues() {},
	                defaultValue: 1,
	                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
	                linearRampToValueAtTime: function linearRampToValueAtTime() {},
	                setTargetAtTime: function setTargetAtTime() {},
	                setValueCurveAtTime: function setValueCurveAtTime() {},
	                value: 1
	            };
	        }
	    }]);
	
	    return OfflineGainNodeFakerProxy;
	}(OfflineAudioNodeProxy);
	
	var OfflineGainNodeFaker = function () {
	    function OfflineGainNodeFaker(_ref2) {
	        var fakeNodeStore = _ref2.fakeNodeStore;
	
	        _classCallCheck$10(this, OfflineGainNodeFaker);
	
	        this._node = null;
	        this._proxy = new OfflineGainNodeFakerProxy({ fakeNodeStore: fakeNodeStore });
	        this._sources = new Map();
	        fakeNodeStore.set(this._proxy, this);
	    }
	
	    _createClass$10(OfflineGainNodeFaker, [{
	        key: 'render',
	        value: function render(offlineAudioContext) {
	            var _this2 = this;
	
	            if (this._node !== null) {
	                return Promise.resolve(this._node);
	            }
	            var promises = [];
	            this._node = offlineAudioContext.createGain();
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;
	
	            try {
	                var _loop = function _loop() {
	                    var _step$value = _slicedToArray$3(_step.value, 2),
	                        source = _step$value[0],
	                        _step$value$ = _step$value[1],
	                        input = _step$value$.input,
	                        output = _step$value$.output;
	
	                    promises.push(source.render(offlineAudioContext).then(function (node) {
	                        return node.connect(_this2._node, output, input);
	                    }));
	                };
	
	                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    _loop();
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	
	            return Promise.all(promises).then(function () {
	                return _this2._node;
	            });
	        }
	    }, {
	        key: 'wire',
	        value: function wire(source, output, input) {
	            this._sources.set(source, { input: input, output: output });
	            return this._proxy;
	        }
	    }, {
	        key: 'unwire',
	        value: function unwire(source) {
	            this._sources.delete(source);
	        }
	    }, {
	        key: 'proxy',
	        get: function get() {
	            return this._proxy;
	        }
	    }]);
	
	    return OfflineGainNodeFaker;
	}();
	var OfflineGainNodeFakerFactory = function () {
	    function OfflineGainNodeFakerFactory() {
	        _classCallCheck$10(this, OfflineGainNodeFakerFactory);
	    }
	
	    _createClass$10(OfflineGainNodeFakerFactory, [{
	        key: 'create',
	        value: function create(_ref3) {
	            var fakeNodeStore = _ref3.fakeNodeStore;
	
	            return new OfflineGainNodeFaker({ fakeNodeStore: fakeNodeStore });
	        }
	    }]);
	
	    return OfflineGainNodeFakerFactory;
	}();
	
	var Window = new _angular_core.OpaqueToken('WINDOW'); // tslint:disable-line:variable-name
	// tslint:disable-line:variable-name
	var WINDOW_PROVIDER = { provide: Window, useValue: window };
	
	var unpatchedOfflineAudioContextConstructor = new _angular_core.OpaqueToken('UNPATCHED_OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR');
	var UNPATCHED_OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
	    deps: [Window],
	    provide: unpatchedOfflineAudioContextConstructor,
	    useFactory: function useFactory(window) {
	        return window.hasOwnProperty('OfflineAudioContext') ? window.OfflineAudioContext : window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;
	    }
	};
	
	var _createClass$12 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$12(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PromiseSupportTester = function () {
	    function PromiseSupportTester() {
	        _classCallCheck$12(this, PromiseSupportTester);
	    }
	
	    _createClass$12(PromiseSupportTester, [{
	        key: "test",
	        value: function test(audioContext) {
	            // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.
	            var uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
	            try {
	                // Bug #1: Chrome Canary & Safari requires a successCallback.
	                var promise = audioContext.decodeAudioData(uint32Array.buffer, function () {
	                    // Ignore the success callback.
	                });
	                if (promise === undefined) {
	                    return false;
	                }
	                promise.catch(function () {
	                    // Ignore rejected errors.
	                });
	                return true;
	            } catch (err) {
	                // Ignore thrown errors.
	            }
	            return false;
	        }
	    }]);
	
	    return PromiseSupportTester;
	}();
	
	var _slicedToArray$4 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass$11 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$11(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	function divide(a, b) {
	    var denominator = b[0] * b[0] + b[1] * b[1];
	    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
	}
	function multiply(a, b) {
	    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
	}
	function evaluatePolynomial(coefficient, z) {
	    var result = [0, 0];
	    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
	        result = multiply(result, z);
	        result[0] += coefficient[i];
	    }
	    return result;
	}
	
	var OfflineIIRFilterNodeProxy = function (_OfflineAudioNodeProx) {
	    _inherits$4(OfflineIIRFilterNodeProxy, _OfflineAudioNodeProx);
	
	    function OfflineIIRFilterNodeProxy(_ref) {
	        var fakeNodeStore = _ref.fakeNodeStore,
	            feedback = _ref.feedback,
	            feedforward = _ref.feedforward,
	            nativeNode = _ref.nativeNode,
	            notSupportedErrorFactory = _ref.notSupportedErrorFactory,
	            sampleRate = _ref.sampleRate;
	
	        _classCallCheck$11(this, OfflineIIRFilterNodeProxy);
	
	        var _this = _possibleConstructorReturn$4(this, (OfflineIIRFilterNodeProxy.__proto__ || Object.getPrototypeOf(OfflineIIRFilterNodeProxy)).call(this, {
	            channelCountMode: 'max',
	            channelInterpretation: 'speakers',
	            fakeNodeStore: fakeNodeStore,
	            numberOfInputs: 1,
	            numberOfOutputs: 1
	        }));
	
	        _this._feedback = feedback;
	        _this._feedforward = feedforward;
	        _this._nativeNode = nativeNode;
	        _this._notSupportedErrorFactory = notSupportedErrorFactory;
	        _this._nyquist = sampleRate / 2;
	        return _this;
	    }
	
	    _createClass$11(OfflineIIRFilterNodeProxy, [{
	        key: "getFrequencyResponse",
	        value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
	            // Bug #9: Safari does not support IIRFilterNodes.
	            if (this._nativeNode) {
	                return this._nativeNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
	            }
	            if (magResponse.length === 0 || phaseResponse.length === 0) {
	                throw this._notSupportedErrorFactory.create();
	            }
	            var length = frequencyHz.length;
	            for (var i = 0; i < length; i += 1) {
	                var omega = -Math.PI * (frequencyHz[i] / this._nyquist);
	                var z = [Math.cos(omega), Math.sin(omega)];
	                var numerator = evaluatePolynomial(this._feedforward, z);
	                var denominator = evaluatePolynomial(this._feedback, z);
	                var response = divide(numerator, denominator);
	                magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
	                phaseResponse[i] = Math.atan2(response[1], response[0]);
	            }
	        }
	    }]);
	
	    return OfflineIIRFilterNodeProxy;
	}(OfflineAudioNodeProxy);
	
	var OfflineIIRFilterNodeFaker = function () {
	    function OfflineIIRFilterNodeFaker(_ref2) {
	        var fakeNodeStore = _ref2.fakeNodeStore,
	            feedback = _ref2.feedback,
	            feedforward = _ref2.feedforward,
	            invalidStateErrorFactory = _ref2.invalidStateErrorFactory,
	            length = _ref2.length,
	            nativeNode = _ref2.nativeNode,
	            notSupportedErrorFactory = _ref2.notSupportedErrorFactory,
	            numberOfChannels = _ref2.numberOfChannels,
	            promiseSupportTester = _ref2.promiseSupportTester,
	            sampleRate = _ref2.sampleRate,
	            UnpatchedOfflineAudioContext = _ref2.UnpatchedOfflineAudioContext;
	
	        _classCallCheck$11(this, OfflineIIRFilterNodeFaker);
	
	        if (feedback.length === 0 || feedback.length > 20) {
	            throw notSupportedErrorFactory.create();
	        }
	        if (feedback[0] === 0) {
	            throw invalidStateErrorFactory.create();
	        }
	        if (feedforward.length === 0 || feedforward.length > 20) {
	            throw notSupportedErrorFactory.create();
	        }
	        if (feedforward[0] === 0) {
	            throw invalidStateErrorFactory.create();
	        }
	        this._feedback = feedback;
	        this._feedforward = feedforward;
	        this._invalidStateErrorFactory = invalidStateErrorFactory;
	        this._length = length;
	        this._nativeNode = nativeNode;
	        this._node = null;
	        this._notSupportedErrorFactory = notSupportedErrorFactory;
	        this._numberOfChannels = numberOfChannels;
	        this._promiseSupportTester = promiseSupportTester;
	        this._proxy = new OfflineIIRFilterNodeProxy({
	            fakeNodeStore: fakeNodeStore,
	            feedback: feedback,
	            feedforward: feedforward,
	            nativeNode: nativeNode,
	            notSupportedErrorFactory: notSupportedErrorFactory,
	            sampleRate: sampleRate
	        });
	        this._sources = new Map();
	        this._UnpatchedOfflineAudioContext = UnpatchedOfflineAudioContext;
	        fakeNodeStore.set(this._proxy, this);
	    }
	
	    _createClass$11(OfflineIIRFilterNodeFaker, [{
	        key: "_applyFilter",
	        value: function _applyFilter(renderedBuffer, offlineAudioContext) {
	            var bufferIndex = 0;
	            var bufferLength = 32;
	            var feedback = this._feedback;
	            var feedbackLength = this._feedback.length;
	            var feedforward = this._feedforward;
	            var feedforwardLength = this._feedforward.length;
	            if (feedforward.length === 0 || feedforward.length > 20 || feedback.length === 0 || feedback.length > 20) {
	                throw this._notSupportedErrorFactory.create();
	            }
	            if (feedforward[0] === 0 || feedback[0] === 0) {
	                throw this._invalidStateErrorFactory.create();
	            }
	            if (feedback[0] !== 1) {
	                for (var i = 0; i < feedbackLength; i += 1) {
	                    feedforward[i] /= feedback[0];
	                }
	                for (var _i = 1; _i < feedforwardLength; _i += 1) {
	                    feedback[_i] /= feedback[0];
	                }
	            }
	            var xBuffer = new Float32Array(bufferLength);
	            var yBuffer = new Float32Array(bufferLength);
	            var minLength = Math.min(feedbackLength, feedforwardLength);
	            var filteredBuffer = offlineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
	            // This implementation as shamelessly inspired by source code of
	            // tslint:disable-next-line:max-line-length
	            // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
	            var numberOfChannels = renderedBuffer.numberOfChannels;
	            for (var _i2 = 0; _i2 < numberOfChannels; _i2 += 1) {
	                var input = renderedBuffer.getChannelData(_i2);
	                var output = filteredBuffer.getChannelData(_i2);
	                // @todo Use TypedArray.prototype.fill() once it lands in Safari.
	                for (var j = 0; j < bufferLength; j += 1) {
	                    xBuffer[j] = 0;
	                    yBuffer[j] = 0;
	                }
	                var inputLength = input.length;
	                for (var _j = 0; _j < inputLength; _j += 1) {
	                    var y = feedforward[0] * input[_j];
	                    for (var k = 1; k < minLength; k += 1) {
	                        var x = bufferIndex - k & bufferLength - 1; // tslint:disable-line:no-bitwise
	                        y += feedforward[k] * xBuffer[x];
	                        y -= feedback[k] * yBuffer[x];
	                    }
	                    for (var _k = minLength; _k < feedforwardLength; _k += 1) {
	                        y += feedforward[_k] * xBuffer[bufferIndex - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise
	                    }
	                    for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {
	                        y -= feedback[_k2] * yBuffer[bufferIndex - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise
	                    }
	                    xBuffer[bufferIndex] = input[_j];
	                    yBuffer[bufferIndex] = y;
	                    bufferIndex = bufferIndex + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise
	                    output[_j] = y;
	                }
	            }
	            return filteredBuffer;
	        }
	    }, {
	        key: "render",
	        value: function render(offlineAudioContext) {
	            var _this2 = this;
	
	            if (this._node !== null) {
	                return Promise.resolve(this._node);
	            }
	            var promises = [];
	            // Bug #9: Safari does not support IIRFilterNodes.
	            if (this._nativeNode) {
	                this._node = offlineAudioContext.createIIRFilter(this._feedforward, this._feedback);
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;
	
	                try {
	                    var _loop = function _loop() {
	                        var _step$value = _slicedToArray$4(_step.value, 2),
	                            source = _step$value[0],
	                            _step$value$ = _step$value[1],
	                            input = _step$value$.input,
	                            output = _step$value$.output;
	
	                        promises.push(source.render(offlineAudioContext).then(function (node) {
	                            return node.connect(_this2._node, output, input);
	                        }));
	                    };
	
	                    for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                        _loop();
	                    }
	                } catch (err) {
	                    _didIteratorError = true;
	                    _iteratorError = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion && _iterator.return) {
	                            _iterator.return();
	                        }
	                    } finally {
	                        if (_didIteratorError) {
	                            throw _iteratorError;
	                        }
	                    }
	                }
	
	                return Promise.all(promises).then(function () {
	                    return _this2._node;
	                });
	            }
	            // @todo Somehow retrieve the number of channels.
	            var partialOfflineAudioContext = new this._UnpatchedOfflineAudioContext(this._numberOfChannels, this._length, offlineAudioContext.sampleRate);
	            var _iteratorNormalCompletion2 = true;
	            var _didIteratorError2 = false;
	            var _iteratorError2 = undefined;
	
	            try {
	                var _loop2 = function _loop2() {
	                    var _step2$value = _slicedToArray$4(_step2.value, 2),
	                        source = _step2$value[0],
	                        _step2$value$ = _step2$value[1],
	                        input = _step2$value$.input,
	                        output = _step2$value$.output;
	
	                    promises.push(source.render(partialOfflineAudioContext).then(function (node) {
	                        return node.connect(partialOfflineAudioContext.destination, output, input);
	                    }));
	                };
	
	                for (var _iterator2 = this._sources[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                    _loop2();
	                }
	            } catch (err) {
	                _didIteratorError2 = true;
	                _iteratorError2 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                        _iterator2.return();
	                    }
	                } finally {
	                    if (_didIteratorError2) {
	                        throw _iteratorError2;
	                    }
	                }
	            }
	
	            return Promise.all(promises).then(function () {
	                // Bug #21: Safari does not support promises yet.
	                if (_this2._promiseSupportTester.test(partialOfflineAudioContext)) {
	                    return partialOfflineAudioContext.startRendering();
	                }
	                return new Promise(function (resolve) {
	                    partialOfflineAudioContext.oncomplete = function (event) {
	                        return resolve(event.renderedBuffer);
	                    };
	                    partialOfflineAudioContext.startRendering();
	                });
	            }).then(function (renderedBuffer) {
	                _this2._node = offlineAudioContext.createBufferSource();
	                _this2._node.buffer = _this2._applyFilter(renderedBuffer, offlineAudioContext);
	                _this2._node.start(0);
	                return _this2._node;
	            });
	        }
	    }, {
	        key: "wire",
	        value: function wire(source, output, input) {
	            this._sources.set(source, { input: input, output: output });
	            return this._proxy;
	        }
	    }, {
	        key: "unwire",
	        value: function unwire(source) {
	            this._sources.delete(source);
	        }
	    }, {
	        key: "proxy",
	        get: function get() {
	            return this._proxy;
	        }
	    }]);
	
	    return OfflineIIRFilterNodeFaker;
	}();
	var OfflineIIRFilterNodeFakerFactory = function () {
	    function OfflineIIRFilterNodeFakerFactory(_UnpatchedOfflineAudioContext, _invalidStateErrorFactory, _notSupportedErrorFactory, _promiseSupportTester) {
	        _classCallCheck$11(this, OfflineIIRFilterNodeFakerFactory);
	
	        this._UnpatchedOfflineAudioContext = _UnpatchedOfflineAudioContext;
	        this._invalidStateErrorFactory = _invalidStateErrorFactory;
	        this._notSupportedErrorFactory = _notSupportedErrorFactory;
	        this._promiseSupportTester = _promiseSupportTester;
	    }
	
	    _createClass$11(OfflineIIRFilterNodeFakerFactory, [{
	        key: "create",
	        value: function create(_ref3) {
	            var fakeNodeStore = _ref3.fakeNodeStore,
	                feedback = _ref3.feedback,
	                feedforward = _ref3.feedforward,
	                length = _ref3.length,
	                nativeNode = _ref3.nativeNode,
	                numberOfChannels = _ref3.numberOfChannels,
	                sampleRate = _ref3.sampleRate;
	
	            return new OfflineIIRFilterNodeFaker({
	                UnpatchedOfflineAudioContext: this._UnpatchedOfflineAudioContext,
	                fakeNodeStore: fakeNodeStore,
	                feedback: feedback,
	                feedforward: feedforward,
	                invalidStateErrorFactory: this._invalidStateErrorFactory,
	                length: length,
	                nativeNode: nativeNode,
	                notSupportedErrorFactory: this._notSupportedErrorFactory,
	                numberOfChannels: numberOfChannels,
	                promiseSupportTester: this._promiseSupportTester,
	                sampleRate: sampleRate
	            });
	        }
	    }]);
	
	    return OfflineIIRFilterNodeFakerFactory;
	}();
	OfflineIIRFilterNodeFakerFactory = __decorate([_angular_core.Injectable(), __param(0, _angular_core.Inject(unpatchedOfflineAudioContextConstructor)), __param(1, _angular_core.Inject(InvalidStateErrorFactory)), __param(2, _angular_core.Inject(NotSupportedErrorFactory)), __param(3, _angular_core.Inject(PromiseSupportTester))], OfflineIIRFilterNodeFakerFactory);
	
	var _createClass$13 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$13(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$1(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	function divide$1(a, b) {
	    var denominator = b[0] * b[0] + b[1] * b[1];
	    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
	}
	function multiply$1(a, b) {
	    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
	}
	function evaluatePolynomial$1(coefficient, z) {
	    var result = [0, 0];
	    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
	        result = multiply$1(result, z);
	        result[0] += coefficient[i];
	    }
	    return result;
	}
	var IIRFilterNodeFaker = function () {
	    function IIRFilterNodeFaker(_invalidAccessErrorFactory, _invalidStateErrorFactory, _notSupportedErrorFactory) {
	        _classCallCheck$13(this, IIRFilterNodeFaker);
	
	        this._invalidAccessErrorFactory = _invalidAccessErrorFactory;
	        this._invalidStateErrorFactory = _invalidStateErrorFactory;
	        this._notSupportedErrorFactory = _notSupportedErrorFactory;
	    }
	
	    _createClass$13(IIRFilterNodeFaker, [{
	        key: "fake",
	        value: function fake(feedforward, feedback, audioContext, unpatchedAudioContext) {
	            var _this = this;
	
	            var bufferIndex = 0;
	            var bufferLength = 32;
	            var feedbackLength = feedback.length;
	            var feedforwardLength = feedforward.length;
	            if (feedforward.length === 0 || feedforward.length > 20 || feedback.length === 0 || feedback.length > 20) {
	                throw this._notSupportedErrorFactory.create();
	            }
	            if (feedforward[0] === 0 || feedback[0] === 0) {
	                throw this._invalidStateErrorFactory.create();
	            }
	            if (feedback[0] !== 1) {
	                for (var i = 0; i < feedforwardLength; i += 1) {
	                    feedforward[i] /= feedback[0];
	                }
	                for (var _i = 1; _i < feedbackLength; _i += 1) {
	                    feedback[_i] /= feedback[0];
	                }
	            }
	            var gainNode = audioContext.createGain();
	            var nyquist = audioContext.sampleRate / 2;
	            // @todo Remove this once the audioContext supports the createScriptProcessor() method, too.
	            var scriptProcessorNode = unpatchedAudioContext.createScriptProcessor(256, gainNode.channelCount, gainNode.channelCount);
	            var bufferSize = scriptProcessorNode.bufferSize;
	            var xBuffer = new Float32Array(bufferLength);
	            var yBuffer = new Float32Array(bufferLength);
	            var minLength = Math.min(feedbackLength, feedforwardLength);
	            // @todo Use TypedArray.prototype.fill() once it lands in Safari.
	            for (var _i2 = 0; _i2 < bufferLength; _i2 += 1) {
	                xBuffer[_i2] = 0;
	                yBuffer[_i2] = 0;
	            }
	            // This implementation as shamelessly inspired by source code of
	            // tslint:disable-next-line:max-line-length
	            // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
	            scriptProcessorNode.onaudioprocess = function (event) {
	                var inputBuffer = event.inputBuffer;
	                var outputBuffer = event.outputBuffer;
	                var numberOfChannels = inputBuffer.numberOfChannels;
	                for (var _i3 = 0; _i3 < numberOfChannels; _i3 += 1) {
	                    var input = inputBuffer.getChannelData(_i3);
	                    var output = outputBuffer.getChannelData(_i3);
	                    for (var j = 0; j < bufferSize; j += 1) {
	                        var y = feedforward[0] * input[j];
	                        for (var k = 1; k < minLength; k += 1) {
	                            var x = bufferIndex - k & bufferLength - 1; // tslint:disable-line:no-bitwise
	                            y += feedforward[k] * xBuffer[x];
	                            y -= feedback[k] * yBuffer[x];
	                        }
	                        for (var _k = minLength; _k < feedforwardLength; _k += 1) {
	                            y += feedforward[_k] * xBuffer[bufferIndex - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise
	                        }
	                        for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {
	                            y -= feedback[_k2] * yBuffer[bufferIndex - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise
	                        }
	                        xBuffer[bufferIndex] = input[j];
	                        yBuffer[bufferIndex] = y;
	                        bufferIndex = bufferIndex + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise
	                        output[j] = y;
	                    }
	                }
	            };
	            gainNode.getFrequencyResponse = function (frequencyHz, magResponse, phaseResponse) {
	                if (magResponse.length === 0 || phaseResponse.length === 0) {
	                    throw _this._notSupportedErrorFactory.create();
	                }
	                var length = frequencyHz.length;
	                for (var _i4 = 0; _i4 < length; _i4 += 1) {
	                    var omega = -Math.PI * (frequencyHz[_i4] / nyquist);
	                    var z = [Math.cos(omega), Math.sin(omega)];
	                    var numerator = evaluatePolynomial$1(feedforward, z);
	                    var denominator = evaluatePolynomial$1(feedback, z);
	                    var response = divide$1(numerator, denominator);
	                    magResponse[_i4] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
	                    phaseResponse[_i4] = Math.atan2(response[1], response[0]);
	                }
	            };
	            gainNode.connect(scriptProcessorNode);
	            gainNode.connect = function (destination) {
	                var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                console.log('HEY');
	                try {
	                    scriptProcessorNode.connect.call(scriptProcessorNode, destination, output, input);
	                } catch (err) {
	                    console.log(err, err.code);
	                    if (err.code === 12) {
	                        throw _this._invalidAccessErrorFactory.create();
	                    }
	                    throw err;
	                }
	                return destination;
	            };
	            return gainNode;
	        }
	    }]);
	
	    return IIRFilterNodeFaker;
	}();
	IIRFilterNodeFaker = __decorate$1([_angular_core.Injectable(), __param$1(0, _angular_core.Inject(InvalidAccessErrorFactory)), __param$1(1, _angular_core.Inject(InvalidStateErrorFactory)), __param$1(2, _angular_core.Inject(NotSupportedErrorFactory))], IIRFilterNodeFaker);
	
	var _createClass$15 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$15(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AnalyserNodeGetFloatTimeDomainDataSupportTester = function () {
	    function AnalyserNodeGetFloatTimeDomainDataSupportTester() {
	        _classCallCheck$15(this, AnalyserNodeGetFloatTimeDomainDataSupportTester);
	    }
	
	    _createClass$15(AnalyserNodeGetFloatTimeDomainDataSupportTester, [{
	        key: 'test',
	        value: function test(audioContext) {
	            var analyserNode = audioContext.createAnalyser();
	            return typeof analyserNode.getFloatTimeDomainData === 'function';
	        }
	    }]);
	
	    return AnalyserNodeGetFloatTimeDomainDataSupportTester;
	}();
	
	var _createClass$16 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$16(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AudioBufferCopyChannelMethodsSupportTester = function () {
	    function AudioBufferCopyChannelMethodsSupportTester() {
	        _classCallCheck$16(this, AudioBufferCopyChannelMethodsSupportTester);
	    }
	
	    _createClass$16(AudioBufferCopyChannelMethodsSupportTester, [{
	        key: "test",
	        value: function test(audioContext) {
	            var audioBuffer = audioContext.createBuffer(1, 1, audioContext.sampleRate);
	            var source = new Float32Array(2);
	            try {
	                /*
	                 * Only Firefox does not fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those
	                 * methods is enough to know if the other one it supported as well.
	                 */
	                audioBuffer.copyToChannel(source, 0);
	            } catch (err) {
	                return false;
	            }
	            return true;
	        }
	    }]);
	
	    return AudioBufferCopyChannelMethodsSupportTester;
	}();
	
	var _createClass$17 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$17(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ChainingSupportTester = function () {
	    function ChainingSupportTester() {
	        _classCallCheck$17(this, ChainingSupportTester);
	    }
	
	    _createClass$17(ChainingSupportTester, [{
	        key: "test",
	        value: function test(audioContext) {
	            var destination = audioContext.createGain();
	            var target = audioContext.createGain();
	            var isSupportingChaining = target.connect(destination) === destination;
	            target.disconnect(destination);
	            return isSupportingChaining;
	        }
	    }]);
	
	    return ChainingSupportTester;
	}();
	
	var unpatchedAudioContextConstructor = new _angular_core.OpaqueToken('UNPATCHED_AUDIO_CONTEXT_CONSTRUCTOR');
	var UNPATCHED_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
	    deps: [Window],
	    provide: unpatchedAudioContextConstructor,
	    useFactory: function useFactory(window) {
	        return window.hasOwnProperty('AudioContext') ? window.AudioContext : window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;
	    }
	};
	
	var _createClass$18 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$18(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$2(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var ConnectingSupportTester = function () {
	    function ConnectingSupportTester(_UnpatchedAudioContext) {
	        _classCallCheck$18(this, ConnectingSupportTester);
	
	        this._UnpatchedAudioContext = _UnpatchedAudioContext;
	    }
	
	    _createClass$18(ConnectingSupportTester, [{
	        key: "test",
	        value: function test(audioContext) {
	            if (this._UnpatchedAudioContext === null) {
	                return false;
	            }
	            var analyserNode = audioContext.createAnalyser();
	            var anotherAudioContext = new this._UnpatchedAudioContext();
	            try {
	                analyserNode.connect(anotherAudioContext.destination);
	            } catch (err) {
	                return err.code === 15;
	            } finally {
	                anotherAudioContext.close();
	            }
	        }
	    }]);
	
	    return ConnectingSupportTester;
	}();
	ConnectingSupportTester = __decorate$2([_angular_core.Injectable(), __param$2(0, _angular_core.Inject(unpatchedAudioContextConstructor))], ConnectingSupportTester);
	
	var _createClass$19 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$19(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DisconnectingSupportTester = function () {
	    function DisconnectingSupportTester() {
	        _classCallCheck$19(this, DisconnectingSupportTester);
	    }
	
	    _createClass$19(DisconnectingSupportTester, [{
	        key: "test",
	        value: function test(audioContext) {
	            return new Promise(function (resolve, reject) {
	                var analyzer = audioContext.createScriptProcessor(256, 1, 1);
	                var dummy = audioContext.createGain();
	                // Safari does not play buffers which contain just one frame.
	                var ones = audioContext.createBuffer(1, 2, 44100);
	                var channelData = ones.getChannelData(0);
	                channelData[0] = 1;
	                channelData[1] = 1;
	                var source = audioContext.createBufferSource();
	                source.buffer = ones;
	                source.loop = true;
	                source.connect(analyzer);
	                analyzer.connect(audioContext.destination);
	                source.connect(dummy);
	                source.disconnect(dummy);
	                analyzer.onaudioprocess = function (event) {
	                    var chnnlDt = event.inputBuffer.getChannelData(0);
	                    if (Array.prototype.some.call(chnnlDt, function (sample) {
	                        return sample === 1;
	                    })) {
	                        resolve(true);
	                    } else {
	                        resolve(false);
	                    }
	                    source.stop();
	                    analyzer.onaudioprocess = null;
	                    source.disconnect(analyzer);
	                    analyzer.disconnect(audioContext.destination);
	                };
	                source.start();
	            });
	        }
	    }]);
	
	    return DisconnectingSupportTester;
	}();
	
	var _createClass$20 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$20(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var StopStoppedSupportTester = function () {
	    function StopStoppedSupportTester() {
	        _classCallCheck$20(this, StopStoppedSupportTester);
	    }
	
	    _createClass$20(StopStoppedSupportTester, [{
	        key: "test",
	        value: function test(audioContext) {
	            var audioBuffer = audioContext.createBuffer(1, 1, 44100);
	            var audioBufferSourceNode = audioContext.createBufferSource();
	            audioBufferSourceNode.buffer = audioBuffer;
	            audioBufferSourceNode.start();
	            audioBufferSourceNode.stop();
	            try {
	                audioBufferSourceNode.stop();
	                return true;
	            } catch (err) {
	                return false;
	            }
	        }
	    }]);
	
	    return StopStoppedSupportTester;
	}();
	
	var _createClass$21 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$21(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AnalyserNodeGetFloatTimeDomainDataMethodWrapper = function () {
	    function AnalyserNodeGetFloatTimeDomainDataMethodWrapper() {
	        _classCallCheck$21(this, AnalyserNodeGetFloatTimeDomainDataMethodWrapper);
	    }
	
	    _createClass$21(AnalyserNodeGetFloatTimeDomainDataMethodWrapper, [{
	        key: "wrap",
	        value: function wrap(analyserNode) {
	            analyserNode.getFloatTimeDomainData = function (array) {
	                var byteTimeDomainData = new Uint8Array(array.length);
	                analyserNode.getByteTimeDomainData(byteTimeDomainData);
	                var length = Math.max(byteTimeDomainData.length, analyserNode.fftSize);
	                for (var i = 0; i < length; i += 1) {
	                    array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;
	                }
	                return array;
	            };
	        }
	    }]);
	
	    return AnalyserNodeGetFloatTimeDomainDataMethodWrapper;
	}();
	
	var _createClass$22 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$22(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$3(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var AudioBufferWrapper = function () {
	    function AudioBufferWrapper(_indexSizeErrorFactory) {
	        _classCallCheck$22(this, AudioBufferWrapper);
	
	        this._indexSizeErrorFactory = _indexSizeErrorFactory;
	    }
	
	    _createClass$22(AudioBufferWrapper, [{
	        key: "wrap",
	        value: function wrap(audioBuffer) {
	            var _this = this;
	
	            audioBuffer.copyFromChannel = function (destination, channelNumber) {
	                var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                if (channelNumber >= audioBuffer.numberOfChannels || startInChannel >= audioBuffer.length) {
	                    throw _this._indexSizeErrorFactory.create();
	                }
	                var channelData = audioBuffer.getChannelData(channelNumber);
	                var channelLength = channelData.length;
	                var destinationLength = destination.length;
	                for (var i = 0; i + startInChannel < channelLength && i < destinationLength; i += 1) {
	                    destination[i] = channelData[i + startInChannel];
	                }
	            };
	            audioBuffer.copyToChannel = function (source, channelNumber) {
	                var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                if (channelNumber >= audioBuffer.numberOfChannels || startInChannel >= audioBuffer.length) {
	                    throw _this._indexSizeErrorFactory.create();
	                }
	                var channelData = audioBuffer.getChannelData(channelNumber);
	                var channelLength = channelData.length;
	                var sourceLength = source.length;
	                for (var i = 0; i + startInChannel < channelLength && i < sourceLength; i += 1) {
	                    channelData[i + startInChannel] = source[i];
	                }
	            };
	        }
	    }]);
	
	    return AudioBufferWrapper;
	}();
	AudioBufferWrapper = __decorate$3([_angular_core.Injectable(), __param$3(0, _angular_core.Inject(IndexSizeErrorFactory))], AudioBufferWrapper);
	
	var _createClass$23 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$23(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AudioBufferCopyChannelMethodsWrapper = function () {
	    function AudioBufferCopyChannelMethodsWrapper() {
	        _classCallCheck$23(this, AudioBufferCopyChannelMethodsWrapper);
	    }
	
	    _createClass$23(AudioBufferCopyChannelMethodsWrapper, [{
	        key: "wrap",
	        value: function wrap(audioBuffer) {
	            audioBuffer.copyFromChannel = function (copyFromChannel) {
	                return function (destination, channelNumber) {
	                    var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                    if (startInChannel < audioBuffer.length && audioBuffer.length - startInChannel < destination.length) {
	                        return copyFromChannel.call(audioBuffer, destination.subarray(0, audioBuffer.length - startInChannel), channelNumber, startInChannel);
	                    }
	                    return copyFromChannel.call(audioBuffer, destination, channelNumber, startInChannel);
	                };
	            }(audioBuffer.copyFromChannel);
	            audioBuffer.copyToChannel = function (copyToChannel) {
	                return function (source, channelNumber) {
	                    var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                    if (startInChannel < audioBuffer.length && audioBuffer.length - startInChannel < source.length) {
	                        return copyToChannel.call(audioBuffer, source.subarray(0, audioBuffer.length - startInChannel), channelNumber, startInChannel);
	                    }
	                    return copyToChannel.call(audioBuffer, source, channelNumber, startInChannel);
	                };
	            }(audioBuffer.copyToChannel);
	        }
	    }]);
	
	    return AudioBufferCopyChannelMethodsWrapper;
	}();
	
	var _createClass$24 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$24(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AudioBufferSourceNodeStopMethodWrapper = function () {
	    function AudioBufferSourceNodeStopMethodWrapper() {
	        _classCallCheck$24(this, AudioBufferSourceNodeStopMethodWrapper);
	    }
	
	    _createClass$24(AudioBufferSourceNodeStopMethodWrapper, [{
	        key: 'wrap',
	        value: function wrap(audioBufferSourceNode, audioContext) {
	            var gainNode = audioContext.createGain();
	            audioBufferSourceNode.connect(gainNode);
	            audioBufferSourceNode.addEventListener('ended', function () {
	                return audioBufferSourceNode.disconnect(gainNode);
	            });
	            audioBufferSourceNode.connect = function (destination) {
	                var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                gainNode.connect.call(gainNode, destination, output, input);
	                return destination;
	            };
	            audioBufferSourceNode.disconnect = function () {
	                gainNode.disconnect.apply(gainNode, arguments);
	            };
	            audioBufferSourceNode.stop = function (stop) {
	                var isStopped = false;
	                return function () {
	                    var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	
	                    if (isStopped) {
	                        try {
	                            stop.call(audioBufferSourceNode, when);
	                        } catch (err) {
	                            gainNode.gain.setValueAtTime(0, when);
	                        }
	                    } else {
	                        stop.call(audioBufferSourceNode, when);
	                        isStopped = true;
	                    }
	                };
	            }(audioBufferSourceNode.stop);
	        }
	    }]);
	
	    return AudioBufferSourceNodeStopMethodWrapper;
	}();
	
	var _createClass$25 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$4 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$25(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$4(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var AudioNodeConnectMethodWrapper = function () {
	    function AudioNodeConnectMethodWrapper(_invalidAccessErrorFactory) {
	        _classCallCheck$25(this, AudioNodeConnectMethodWrapper);
	
	        this._invalidAccessErrorFactory = _invalidAccessErrorFactory;
	    }
	
	    _createClass$25(AudioNodeConnectMethodWrapper, [{
	        key: "wrap",
	        value: function wrap(audioNode) {
	            var _this = this;
	
	            audioNode.connect = function (connect, isSupportingChaining, isSupportingConnecting) {
	                if (isSupportingChaining) {
	                    return function (destination) {
	                        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                        try {
	                            return connect.call(audioNode, destination, output, input);
	                        } catch (err) {
	                            if (err.code === 12) {
	                                throw _this._invalidAccessErrorFactory.create();
	                            }
	                            throw err;
	                        }
	                    };
	                } else {
	                    return function (destination) {
	                        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                        try {
	                            connect.call(audioNode, destination, output, input);
	                        } catch (err) {
	                            if (err.code === 12) {
	                                throw _this._invalidAccessErrorFactory.create();
	                            }
	                            throw err;
	                        }
	                        return destination;
	                    };
	                }
	            }(audioNode.connect);
	        }
	    }]);
	
	    return AudioNodeConnectMethodWrapper;
	}();
	AudioNodeConnectMethodWrapper = __decorate$4([_angular_core.Injectable(), __param$4(0, _angular_core.Inject(InvalidAccessErrorFactory))], AudioNodeConnectMethodWrapper);
	
	var _createClass$26 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$26(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var AudioNodeDisconnectMethodWrapper = function () {
	    function AudioNodeDisconnectMethodWrapper() {
	        _classCallCheck$26(this, AudioNodeDisconnectMethodWrapper);
	    }
	
	    _createClass$26(AudioNodeDisconnectMethodWrapper, [{
	        key: "wrap",
	        value: function wrap(audioNode) {
	            var destinations = new Map();
	            audioNode.connect = function (connect) {
	                return function (destination) {
	                    var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	                    var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	                    destinations.set(destination, { input: input, output: output });
	                    return connect.call(audioNode, destination, output, input);
	                };
	            }(audioNode.connect);
	            audioNode.disconnect = function (disconnect) {
	                return function () {
	                    var destination = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	                    disconnect.apply(audioNode);
	                    if (destination !== null && destinations.has(destination)) {
	                        destinations.delete(destination);
	                        destinations.forEach(function (_ref, dstntn) {
	                            var input = _ref.input,
	                                output = _ref.output;
	
	                            audioNode.connect(dstntn, input, output);
	                        });
	                    }
	                };
	            }(audioNode.disconnect);
	        }
	    }]);
	
	    return AudioNodeDisconnectMethodWrapper;
	}();
	
	var _createClass$27 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$5 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$27(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$5(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var ChannelMergerNodeWrapper = function () {
	    function ChannelMergerNodeWrapper(_invalidStateErrorFactory) {
	        _classCallCheck$27(this, ChannelMergerNodeWrapper);
	
	        this._invalidStateErrorFactory = _invalidStateErrorFactory;
	    }
	
	    _createClass$27(ChannelMergerNodeWrapper, [{
	        key: "wrap",
	        value: function wrap(audioContext, channelMergerNode) {
	            var _this = this;
	
	            var audioBufferSourceNode = audioContext.createBufferSource();
	            channelMergerNode.channelCount = 1;
	            channelMergerNode.channelCountMode = 'explicit';
	            // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.
	            var length = channelMergerNode.numberOfInputs;
	            for (var i = 0; i < length; i += 1) {
	                audioBufferSourceNode.connect(channelMergerNode, 0, i);
	            }
	            Object.defineProperty(channelMergerNode, 'channelCount', {
	                get: function get() {
	                    return 1;
	                },
	                set: function set() {
	                    throw _this._invalidStateErrorFactory.create();
	                }
	            });
	            Object.defineProperty(channelMergerNode, 'channelCountMode', {
	                get: function get() {
	                    return 'explicit';
	                },
	                set: function set() {
	                    throw _this._invalidStateErrorFactory.create();
	                }
	            });
	        }
	    }]);
	
	    return ChannelMergerNodeWrapper;
	}();
	ChannelMergerNodeWrapper = __decorate$5([_angular_core.Injectable(), __param$5(0, _angular_core.Inject(InvalidStateErrorFactory))], ChannelMergerNodeWrapper);
	
	var _createClass$28 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$6 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$28(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$6(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var ChannelSplitterNodeWrapper = function () {
	    function ChannelSplitterNodeWrapper(_invalidStateErrorFactory) {
	        _classCallCheck$28(this, ChannelSplitterNodeWrapper);
	
	        this._invalidStateErrorFactory = _invalidStateErrorFactory;
	    }
	
	    _createClass$28(ChannelSplitterNodeWrapper, [{
	        key: "wrap",
	        value: function wrap(channelSplitterNode) {
	            var _this = this;
	
	            channelSplitterNode.channelCountMode = 'explicit';
	            channelSplitterNode.channelInterpretation = 'discrete';
	            Object.defineProperty(channelSplitterNode, 'channelCountMode', {
	                get: function get() {
	                    return 'explicit';
	                },
	                set: function set() {
	                    throw _this._invalidStateErrorFactory.create();
	                }
	            });
	            Object.defineProperty(channelSplitterNode, 'channelInterpretation', {
	                get: function get() {
	                    return 'discrete';
	                },
	                set: function set() {
	                    throw _this._invalidStateErrorFactory.create();
	                }
	            });
	        }
	    }]);
	
	    return ChannelSplitterNodeWrapper;
	}();
	ChannelSplitterNodeWrapper = __decorate$6([_angular_core.Injectable(), __param$6(0, _angular_core.Inject(InvalidStateErrorFactory))], ChannelSplitterNodeWrapper);
	
	var _createClass$29 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$7 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$29(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$7(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var IIRFilterNodeGetFrequencyResponseMethodWrapper = function () {
	    function IIRFilterNodeGetFrequencyResponseMethodWrapper(_notSupportedErrorFactory) {
	        _classCallCheck$29(this, IIRFilterNodeGetFrequencyResponseMethodWrapper);
	
	        this._notSupportedErrorFactory = _notSupportedErrorFactory;
	    }
	
	    _createClass$29(IIRFilterNodeGetFrequencyResponseMethodWrapper, [{
	        key: "wrap",
	        value: function wrap(iIRFilterNode) {
	            var _this = this;
	
	            iIRFilterNode.getFrequencyResponse = function (getFrequencyResponse) {
	                return function (frequencyHz, magResponse, phaseResponse) {
	                    if (magResponse.length === 0 || phaseResponse.length === 0) {
	                        throw _this._notSupportedErrorFactory.create();
	                    }
	                    return getFrequencyResponse.call(iIRFilterNode, frequencyHz, magResponse, phaseResponse);
	                };
	            }(iIRFilterNode.getFrequencyResponse);
	        }
	    }]);
	
	    return IIRFilterNodeGetFrequencyResponseMethodWrapper;
	}();
	IIRFilterNodeGetFrequencyResponseMethodWrapper = __decorate$7([_angular_core.Injectable(), __param$7(0, _angular_core.Inject(NotSupportedErrorFactory))], IIRFilterNodeGetFrequencyResponseMethodWrapper);
	
	var DetachedAudioBuffers = new _angular_core.OpaqueToken('DETACHED_AUDIO_BUFFERS'); // tslint:disable-line:variable-name
	// tslint:disable-line:variable-name
	var DETACHED_AUDIO_BUFFERS_PROVIDER = { provide: DetachedAudioBuffers, useValue: new WeakSet() };
	
	var _createClass$14 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$14(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var audioContextConstructor = new _angular_core.OpaqueToken('AUDIO_CONTEXT_CONSTRUCTOR');
	var AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
	    deps: [AnalyserNodeGetFloatTimeDomainDataMethodWrapper, AnalyserNodeGetFloatTimeDomainDataSupportTester, AudioBufferCopyChannelMethodsSupportTester, AudioBufferCopyChannelMethodsWrapper, AudioBufferSourceNodeStopMethodWrapper, AudioBufferWrapper, AudioNodeConnectMethodWrapper, AudioNodeDisconnectMethodWrapper, ChainingSupportTester, ChannelMergerNodeWrapper, ChannelSplitterNodeWrapper, ConnectingSupportTester, DataCloneErrorFactory, DetachedAudioBuffers, DisconnectingSupportTester, EncodingErrorFactory, InvalidAccessErrorFactory, InvalidStateErrorFactory, IIRFilterNodeFaker, IIRFilterNodeGetFrequencyResponseMethodWrapper, PromiseSupportTester, StopStoppedSupportTester, unpatchedAudioContextConstructor],
	    provide: audioContextConstructor,
	    useFactory: function useFactory(analyserNodeGetFloatTimeDomainDataMethodWrapper, analyserNodeGetFloatTimeDomainDataSupportTester, audioBufferCopyChannelMethodsSupportTester, audioBufferCopyChannelMethodsWrapper, audioBufferSourceNodeStopMethodWrapper, audioBufferWrapper, audioNodeConnectMethodWrapper, audioNodeDisconnectMethodWrapper, chainingSupportTester, channelMergerNodeWrapper, channelSplitterNodeWrapper, connectingSupportTester, dataCloneErrorFactory, detachedAudioBuffers, disconnectingSupportTester, encodingErrorFactory, invalidAccessErrorFactory, invalidStateErrorFactory, iIRFilterNodeFaker, iIRFilterNodeGetFrequencyResponseMethodWrapper, promiseSupportTester, stopStoppedSupportTester, UnpatchedAudioContext // tslint:disable-line:variable-name
	    ) {
	        var AudioContext = function () {
	            function AudioContext() {
	                var _this = this;
	
	                _classCallCheck$14(this, AudioContext);
	
	                var unpatchedAudioContext = new UnpatchedAudioContext();
	                this._isSupportingAnalyserNodeGetFloatTimeDomainData = analyserNodeGetFloatTimeDomainDataSupportTester.test(unpatchedAudioContext);
	                this._isSupportingChaining = chainingSupportTester.test(unpatchedAudioContext);
	                this._isSupportingCopyChannelMethods = audioBufferCopyChannelMethodsSupportTester.test(unpatchedAudioContext);
	                this._isSupportingConnecting = connectingSupportTester.test(unpatchedAudioContext);
	                this._isSupportingDisconnecting = false;
	                // @todo Actually check for getFrequencyResponse() errors support.
	                this._isSupportingGetFrequencyResponseErrors = false;
	                this._isSupportingPromises = promiseSupportTester.test(unpatchedAudioContext);
	                this._isSupportingStoppingOfStoppedNodes = stopStoppedSupportTester.test(unpatchedAudioContext);
	                this._onStateChangeListener = null;
	                this._unpatchedAudioContext = unpatchedAudioContext;
	                this._state = null;
	                disconnectingSupportTester.test(unpatchedAudioContext).then(function (isSupportingDisconnecting) {
	                    _this._isSupportingDisconnecting = isSupportingDisconnecting;
	                });
	                /*
	                 * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually
	                 * changes to 'running'.
	                 */
	                if (unpatchedAudioContext.state === 'running') {
	                    this._state = 'suspended';
	                    var revokeState = function revokeState() {
	                        if (_this._state === 'suspended') {
	                            _this._state = null;
	                        }
	                        if (unpatchedAudioContext.removeEventListener) {
	                            unpatchedAudioContext.removeEventListener('statechange', revokeState);
	                        }
	                    };
	                    unpatchedAudioContext.addEventListener('statechange', revokeState);
	                }
	            }
	
	            _createClass$14(AudioContext, [{
	                key: 'close',
	                value: function close() {
	                    // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
	                    if (this.state === 'closed') {
	                        return this._unpatchedAudioContext.close().then(function () {
	                            throw invalidStateErrorFactory.create();
	                        });
	                    }
	                    // Bug #34: If the state was set to suspended before it should be revoked now.
	                    if (this._state === 'suspended') {
	                        this._state = null;
	                    }
	                    return this._unpatchedAudioContext.close();
	                }
	            }, {
	                key: 'createAnalyser',
	                value: function createAnalyser() {
	                    if (this._unpatchedAudioContext === null) {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    var analyserNode = this._unpatchedAudioContext.createAnalyser();
	                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
	                    // tslint:disable-next-line:comment-format
	                    // the behaviour of throwing an error.
	                    if (this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #37: Only Chrome Canary and Firefox create an AnalyserNode with default properties.
	                    if (analyserNode.channelCount === 2) {
	                        analyserNode.channelCount = 1;
	                    }
	                    // Bug #36: Safari does not support getFloatTimeDomainData() yet.
	                    if (!this._isSupportingAnalyserNodeGetFloatTimeDomainData) {
	                        analyserNodeGetFloatTimeDomainDataMethodWrapper.wrap(analyserNode);
	                    }
	                    // Bug #11: Safari does not support chaining yet.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(analyserNode, this._isSupportingChaining, this._isSupportingConnecting);
	                    }
	                    // Only Chrome and Opera support disconnecting of a specific destination.
	                    if (!this._isSupportingDisconnecting) {
	                        audioNodeDisconnectMethodWrapper.wrap(analyserNode);
	                    }
	                    return analyserNode;
	                }
	            }, {
	                key: 'createBiquadFilter',
	                value: function createBiquadFilter() {
	                    if (this._unpatchedAudioContext === null) {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    var biquadFilterNode = this._unpatchedAudioContext.createBiquadFilter();
	                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
	                    // tslint:disable-next-line:comment-format
	                    // the behaviour of throwing an error.
	                    if (this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #11: Safari does not support chaining yet.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(biquadFilterNode, this._isSupportingChaining, this._isSupportingConnecting);
	                    }
	                    return biquadFilterNode;
	                }
	            }, {
	                key: 'createBuffer',
	                value: function createBuffer(numberOfChannels, length, sampleRate) {
	                    var audioBuffer = this._unpatchedAudioContext.createBuffer(numberOfChannels, length, sampleRate);
	                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
	                    if (typeof audioBuffer.copyFromChannel !== 'function') {
	                        audioBufferWrapper.wrap(audioBuffer);
	                        // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
	                    } else if (!this._isSupportingCopyChannelMethods) {
	                        audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
	                    }
	                    return audioBuffer;
	                }
	            }, {
	                key: 'createBufferSource',
	                value: function createBufferSource() {
	                    var audioBufferSourceNode = this._unpatchedAudioContext.createBufferSource();
	                    // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.
	                    if (!this._isSupportingStoppingOfStoppedNodes) {
	                        audioBufferSourceNodeStopMethodWrapper.wrap(audioBufferSourceNode, this);
	                        return audioBufferSourceNode;
	                    }
	                    // Bug #11: Safari does not support chaining yet but is already patched above.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(audioBufferSourceNode, true, this._isSupportingConnecting);
	                    }
	                    return audioBufferSourceNode;
	                }
	            }, {
	                key: 'createChannelMerger',
	                value: function createChannelMerger() {
	                    if (this._unpatchedAudioContext === null) {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    var channelMergerNode = this._unpatchedAudioContext.createChannelMerger.apply(this._unpatchedAudioContext, arguments);
	                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
	                    // tslint:disable-next-line:comment-format
	                    // the behaviour of throwing an error.
	                    if (this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #11: Safari does not support chaining yet.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(channelMergerNode, this._isSupportingChaining, this._isSupportingConnecting);
	                    }
	                    // Bug #15: Safari does not return the default properties.
	                    if (channelMergerNode.channelCount !== 1 && channelMergerNode.channelCountMode !== 'explicit') {
	                        channelMergerNodeWrapper.wrap(this._unpatchedAudioContext, channelMergerNode);
	                    }
	                    // Bug #16: Firefox does not throw an error when setting a different channelCount or channelCountMode.
	                    try {
	                        channelMergerNode.channelCount = 2;
	                        channelMergerNodeWrapper.wrap(this._unpatchedAudioContext, channelMergerNode);
	                    } catch (err) {} // tslint:disable-line:no-empty
	                    return channelMergerNode;
	                }
	            }, {
	                key: 'createChannelSplitter',
	                value: function createChannelSplitter() {
	                    if (this._unpatchedAudioContext === null) {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    var channelSplitterNode = this._unpatchedAudioContext.createChannelSplitter.apply(this._unpatchedAudioContext, arguments);
	                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
	                    // tslint:disable-next-line:comment-format
	                    // the behaviour of throwing an error.
	                    if (this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #11: Safari does not support chaining yet.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(channelSplitterNode, this._isSupportingChaining, this._isSupportingConnecting);
	                    }
	                    // Bug #29 - #32: Only Chrome partially supports the spec yet.
	                    channelSplitterNodeWrapper.wrap(channelSplitterNode);
	                    return channelSplitterNode;
	                }
	            }, {
	                key: 'createGain',
	                value: function createGain() {
	                    if (this._unpatchedAudioContext === null) {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    var gainNode = this._unpatchedAudioContext.createGain();
	                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
	                    // tslint:disable-next-line:comment-format
	                    // the behaviour of throwing an error.
	                    if (this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #11: Safari does not support chaining yet.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(gainNode, this._isSupportingChaining, this._isSupportingConnecting);
	                    }
	                    // Bug #12: Firefox and Safari do not support to disconnect a specific destination.
	                    if (!this._isSupportingDisconnecting) {
	                        audioNodeDisconnectMethodWrapper.wrap(gainNode);
	                    }
	                    return gainNode;
	                }
	            }, {
	                key: 'createIIRFilter',
	                value: function createIIRFilter(feedforward, feedback) {
	                    // Bug #10: Edge does not throw an error when the context is closed.
	                    if (this._unpatchedAudioContext === null && this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #9: Safari does not support IIRFilterNodes.
	                    if (this._unpatchedAudioContext.createIIRFilter === undefined) {
	                        return iIRFilterNodeFaker.fake(feedforward, feedback, this, this._unpatchedAudioContext);
	                    }
	                    var iIRFilterNode = this._unpatchedAudioContext.createIIRFilter(feedforward, feedback);
	                    // Bug 23 & 24: FirefoxDeveloper does not throw NotSupportedErrors anymore.
	                    if (!this._isSupportingGetFrequencyResponseErrors) {
	                        iIRFilterNodeGetFrequencyResponseMethodWrapper.wrap(iIRFilterNode);
	                    }
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(iIRFilterNode, true, this._isSupportingConnecting);
	                    }
	                    return iIRFilterNode;
	                }
	            }, {
	                key: 'createOscillator',
	                value: function createOscillator() {
	                    if (this._unpatchedAudioContext === null) {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    var oscillatorNode = this._unpatchedAudioContext.createOscillator();
	                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
	                    // tslint:disable-next-line:comment-format
	                    // the behaviour of throwing an error.
	                    if (this.state === 'closed') {
	                        throw invalidStateErrorFactory.create();
	                    }
	                    // Bug #11: Safari does not support chaining yet.
	                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
	                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
	                        audioNodeConnectMethodWrapper.wrap(oscillatorNode, this._isSupportingChaining, this._isSupportingConnecting);
	                    }
	                    return oscillatorNode;
	                }
	            }, {
	                key: 'decodeAudioData',
	                value: function decodeAudioData(audioData, successCallback, errorCallback) {
	                    var _this2 = this;
	
	                    // Bug #43: Only Chrome Canary does yet throw a DataCloneError.
	                    if (detachedAudioBuffers.has(audioData)) {
	                        var err = dataCloneErrorFactory.create();
	                        if (typeof errorCallback === 'function') {
	                            errorCallback(err);
	                        }
	                        return Promise.reject(err);
	                    }
	                    // The audioData parameter maybe of a type which can't be added to a WeakSet.
	                    try {
	                        detachedAudioBuffers.add(audioData);
	                    } catch (err) {}
	                    // Ignore errors.
	
	                    // Bug #21: Safari does not support promises yet.
	                    if (this._isSupportingPromises) {
	                        // Bug #1: Chrome requires a successCallback.
	                        if (successCallback === undefined) {
	                            successCallback = function successCallback() {}; // tslint:disable-line:no-empty
	                        }
	                        return this._unpatchedAudioContext.decodeAudioData(audioData, successCallback, function (err) {
	                            if (typeof errorCallback === 'function') {
	                                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
	                                if (err instanceof DOMException && err.name === 'NotSupportedError') {
	                                    errorCallback(new TypeError());
	                                } else {
	                                    errorCallback(err);
	                                }
	                            }
	                        }).catch(function (err) {
	                            // Bug #6: Chrome, Firefox and Opera do not call the errorCallback in case of an invalid buffer.
	                            if (typeof errorCallback === 'function' && err instanceof TypeError) {
	                                errorCallback(err);
	                            }
	                            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
	                            if (err instanceof DOMException && err.name === 'NotSupportedError') {
	                                throw new TypeError();
	                            }
	                            throw err;
	                        });
	                    }
	                    // Bug #21: Safari does not return a Promise yet.
	                    return new Promise(function (resolve, reject) {
	                        var fail = function fail(err) {
	                            if (typeof errorCallback === 'function') {
	                                errorCallback(err);
	                            }
	                            reject(err);
	                        };
	                        var succeed = function succeed(dBffrWrppr) {
	                            resolve(dBffrWrppr);
	                            if (typeof successCallback === 'function') {
	                                successCallback(dBffrWrppr);
	                            }
	                        };
	                        // Bug #26: Safari throws a synchronous error.
	                        try {
	                            // Bug #1: Safari requires a successCallback.
	                            _this2._unpatchedAudioContext.decodeAudioData(audioData, function (audioBuffer) {
	                                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
	                                if (typeof audioBuffer.copyFromChannel !== 'function') {
	                                    audioBufferWrapper.wrap(audioBuffer);
	                                    // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
	                                } else if (!_this2._isSupportingCopyChannelMethods) {
	                                    audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
	                                }
	                                succeed(audioBuffer);
	                            }, function (err) {
	                                // Bug #4: Safari returns null instead of an error.
	                                if (err === null) {
	                                    fail(encodingErrorFactory.create());
	                                } else {
	                                    fail(err);
	                                }
	                            });
	                        } catch (err) {
	                            fail(err);
	                        }
	                    });
	                }
	            }, {
	                key: 'currentTime',
	                get: function get() {
	                    return this._unpatchedAudioContext.currentTime;
	                },
	                set: function set(value) {
	                    this._unpatchedAudioContext.currentTime = value;
	                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
	                    throw new TypeError();
	                }
	            }, {
	                key: 'destination',
	                get: function get() {
	                    return this._unpatchedAudioContext.destination;
	                },
	                set: function set(value) {
	                    this._unpatchedAudioContext.destination = value;
	                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
	                    throw new TypeError();
	                }
	            }, {
	                key: 'onstatechange',
	                get: function get() {
	                    if ('onstatechange' in this._unpatchedAudioContext) {
	                        return this._unpatchedAudioContext.onstatechange;
	                    }
	                    return this._onStateChangeListener;
	                },
	                set: function set(value) {
	                    if ('onstatechange' in this._unpatchedAudioContext) {
	                        this._unpatchedAudioContext.onstatechange = value;
	                    } else {
	                        this._onStateChangeListener = typeof value === 'function' ? value : null;
	                    }
	                }
	            }, {
	                key: 'sampleRate',
	                get: function get() {
	                    return this._unpatchedAudioContext.sampleRate;
	                },
	                set: function set(value) {
	                    this._unpatchedAudioContext.sampleRate = value;
	                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
	                    throw new TypeError();
	                }
	            }, {
	                key: 'state',
	                get: function get() {
	                    return this._state !== null ? this._state : this._unpatchedAudioContext.state;
	                },
	                set: function set(value) {
	                    if (this._unpatchedAudioContext.state !== undefined) {
	                        this._unpatchedAudioContext.state = value;
	                    }
	                    // If the unpatched AudioContext does not have a property called state or does not throw an error by itself, it has to be
	                    // tslint:disable-next-line:comment-format
	                    // faked.
	                    throw new TypeError();
	                }
	            }]);
	
	            return AudioContext;
	        }();
	
	        return AudioContext;
	    }
	};
	
	var _createClass$30 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$8 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$30(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$8(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	var CloseSupportTester = function () {
	    function CloseSupportTester(_UnpatchedAudioContext) {
	        _classCallCheck$30(this, CloseSupportTester);
	
	        this._UnpatchedAudioContext = _UnpatchedAudioContext;
	    }
	
	    _createClass$30(CloseSupportTester, [{
	        key: "test",
	        value: function test() {
	            if (this._UnpatchedAudioContext === null) {
	                return false;
	            }
	            var audioContext = new this._UnpatchedAudioContext();
	            var isAudioContextClosable = audioContext.close !== undefined;
	            try {
	                audioContext.close();
	            } catch (err) {
	                // Ignore errors.
	            }
	            return isAudioContextClosable;
	        }
	    }]);
	
	    return CloseSupportTester;
	}();
	CloseSupportTester = __decorate$8([_angular_core.Injectable(), __param$8(0, _angular_core.Inject(unpatchedAudioContextConstructor))], CloseSupportTester);
	
	var _createClass$31 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$9 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$31(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$9(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	/**
	 * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers
	 * did not refuse to decode invalid parameters with a TypeError.
	 */
	var DecodeAudioDataTypeErrorSupportTester = function () {
	    function DecodeAudioDataTypeErrorSupportTester(_UnpatchedAudioContext) {
	        _classCallCheck$31(this, DecodeAudioDataTypeErrorSupportTester);
	
	        this._UnpatchedAudioContext = _UnpatchedAudioContext;
	    }
	
	    _createClass$31(DecodeAudioDataTypeErrorSupportTester, [{
	        key: "test",
	        value: function test() {
	            if (this._UnpatchedAudioContext === null) {
	                return Promise.resolve(false);
	            }
	            var audioContext = new this._UnpatchedAudioContext();
	            // Bug #21: Safari does not support promises yet.
	            // Bug #1: Chrome Canary & Safari requires a successCallback.
	            return new Promise(function (resolve) {
	                audioContext.decodeAudioData(null, function () {
	                    // Ignore the success callback.
	                }, function (err) {
	                    audioContext.close().catch(function () {
	                        // Ignore errors.
	                    });
	                    resolve(err instanceof TypeError);
	                }).catch(function () {
	                    // Ignore errors.
	                });
	            });
	        }
	    }]);
	
	    return DecodeAudioDataTypeErrorSupportTester;
	}();
	DecodeAudioDataTypeErrorSupportTester = __decorate$9([_angular_core.Injectable(), __param$9(0, _angular_core.Inject(unpatchedAudioContextConstructor))], DecodeAudioDataTypeErrorSupportTester);
	
	var _createClass$32 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _typeof$10 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function _classCallCheck$32(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$10(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __param$10 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	        decorator(target, key, paramIndex);
	    };
	};
	/**
	 * Firefox up to version 44 had a bug which resulted in a misbehaving ChannelMergerNode. If one of
	 * its channels would be unconnected the remaining channels were somehow upmixed to spread the
	 * signal across all available channels.
	 */
	var MergingSupportTester = function () {
	    function MergingSupportTester(_UnpatchedAudioContext) {
	        _classCallCheck$32(this, MergingSupportTester);
	
	        this._UnpatchedAudioContext = _UnpatchedAudioContext;
	    }
	
	    _createClass$32(MergingSupportTester, [{
	        key: "test",
	        value: function test() {
	            if (this._UnpatchedAudioContext === null) {
	                return Promise.resolve(false);
	            }
	            var audioContext = new this._UnpatchedAudioContext();
	            var audioBufferSourceNode = audioContext.createBufferSource();
	            var audioBuffer = audioContext.createBuffer(2, 2, audioContext.sampleRate);
	            var channelMergerNode = audioContext.createChannelMerger(2);
	            var scriptProcessorNode = audioContext.createScriptProcessor(256);
	            return new Promise(function (resolve) {
	                var startTime = void 0;
	                // @todo Safari does not play/loop 1 sample buffers. This should be patched.
	                audioBuffer.getChannelData(0)[0] = 1;
	                audioBuffer.getChannelData(0)[1] = 1;
	                audioBuffer.getChannelData(1)[0] = 1;
	                audioBuffer.getChannelData(1)[1] = 1;
	                audioBufferSourceNode.buffer = audioBuffer;
	                audioBufferSourceNode.loop = true;
	                scriptProcessorNode.onaudioprocess = function (event) {
	                    var channelData = event.inputBuffer.getChannelData(1);
	                    var length = channelData.length;
	                    for (var i = 0; i < length; i += 1) {
	                        if (channelData[i] !== 0) {
	                            resolve(false);
	                            return;
	                        }
	                    }
	                    if (startTime + 1 / audioContext.sampleRate < event.playbackTime) {
	                        resolve(true);
	                    }
	                };
	                audioBufferSourceNode.connect(channelMergerNode, 0, 0);
	                channelMergerNode.connect(scriptProcessorNode);
	                scriptProcessorNode.connect(audioContext.destination);
	                startTime = audioContext.currentTime;
	                audioBufferSourceNode.start(startTime);
	            }).then(function (result) {
	                audioBufferSourceNode.stop();
	                audioBufferSourceNode.disconnect();
	                channelMergerNode.disconnect();
	                scriptProcessorNode.disconnect();
	                audioContext.close();
	                return result;
	            });
	        }
	    }]);
	
	    return MergingSupportTester;
	}();
	MergingSupportTester = __decorate$10([_angular_core.Injectable(), __param$10(0, _angular_core.Inject(unpatchedAudioContextConstructor))], MergingSupportTester);
	
	var _typeof$11 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/*!
	 * modernizr v3.5.0
	 * Build https://modernizr.com/download?-promises-typedarrays-webaudio-dontmin
	 *
	 * Copyright (c)
	 *  Faruk Ates
	 *  Paul Irish
	 *  Alex Sexton
	 *  Ryan Seddon
	 *  Patrick Kettner
	 *  Stu Cox
	 *  Richard Herrera
	
	 * MIT License
	 */
	var modernizr = ((function (window, document, undefined) {
	    var tests = [];
	    /**
	     *
	     * ModernizrProto is the constructor for Modernizr
	     *
	     * @class
	     * @access public
	     */
	    var ModernizrProto = {
	        // The current version, dummy
	        _version: '3.5.0',
	        // Any settings that don't work as separate modules
	        // can go in here as configuration.
	        _config: {
	            'classPrefix': '',
	            'enableClasses': true,
	            'enableJSClass': true,
	            'usePrefixes': true
	        },
	        // Queue of tests
	        _q: [],
	        // Stub these for people who are listening
	        on: function on(test, cb) {
	            // I don't really think people should do this, but we can
	            // safe guard it a bit.
	            // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
	            // This is in case people listen to synchronous tests. I would leave it out,
	            // but the code to *disallow* sync tests in the real version of this
	            // function is actually larger than this.
	            var self = this;
	            setTimeout(function () {
	                cb(self[test]);
	            }, 0);
	        },
	        addTest: function addTest(name, fn, options) {
	            tests.push({ name: name, fn: fn, options: options });
	        },
	        addAsyncTest: function addAsyncTest(fn) {
	            tests.push({ name: null, fn: fn });
	        }
	    };
	    // Fake some of Object.create so we can force non test results to be non "own" properties.
	    var Modernizr = function Modernizr() {};
	    Modernizr.prototype = ModernizrProto;
	    // Leak modernizr globally when you `require` it rather than force it here.
	    // Overwrite name so constructor name is nicer :D
	    Modernizr = new Modernizr();
	    var classes = [];
	    /**
	     * is returns a boolean if the typeof an obj is exactly type.
	     *
	     * @access private
	     * @function is
	     * @param {*} obj - A thing we want to check the type of
	     * @param {string} type - A string to compare the typeof against
	     * @returns {boolean}
	     */
	    function is(obj, type) {
	        return (typeof obj === 'undefined' ? 'undefined' : _typeof$11(obj)) === type;
	    }
	    
	    /**
	     * Run through all tests and detect their support in the current UA.
	     *
	     * @access private
	     */
	    function testRunner() {
	        var featureNames;
	        var feature;
	        var aliasIdx;
	        var result;
	        var nameIdx;
	        var featureName;
	        var featureNameSplit;
	        for (var featureIdx in tests) {
	            if (tests.hasOwnProperty(featureIdx)) {
	                featureNames = [];
	                feature = tests[featureIdx];
	                // run the test, throw the return value into the Modernizr,
	                // then based on that boolean, define an appropriate className
	                // and push it into an array of classes we'll join later.
	                //
	                // If there is no name, it's an 'async' test that is run,
	                // but not directly added to the object. That should
	                // be done with a post-run addTest call.
	                if (feature.name) {
	                    featureNames.push(feature.name.toLowerCase());
	                    if (feature.options && feature.options.aliases && feature.options.aliases.length) {
	                        // Add all the aliases into the names list
	                        for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
	                            featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
	                        }
	                    }
	                }
	                // Run the test, or use the raw value if it's not a function
	                result = is(feature.fn, 'function') ? feature.fn() : feature.fn;
	                // Set each of the names on the Modernizr object
	                for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
	                    featureName = featureNames[nameIdx];
	                    // Support dot properties as sub tests. We don't do checking to make sure
	                    // that the implied parent tests have been added. You must call them in
	                    // order (either in the test, or make the parent test a dependency).
	                    //
	                    // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
	                    // hashtag famous last words
	                    featureNameSplit = featureName.split('.');
	                    if (featureNameSplit.length === 1) {
	                        Modernizr[featureNameSplit[0]] = result;
	                    } else {
	                        // cast to a Boolean, if not one already
	                        if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
	                            Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
	                        }
	                        Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
	                    }
	                    classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
	                }
	            }
	        }
	    }
	    
	    /*!
	    {
	      "name": "ES6 Promises",
	      "property": "promises",
	      "caniuse": "promises",
	      "polyfills": ["es6promises"],
	      "authors": ["Krister Kari", "Jake Archibald"],
	      "tags": ["es6"],
	      "notes": [{
	        "name": "The ES6 promises spec",
	        "href": "https://github.com/domenic/promises-unwrapping"
	      },{
	        "name": "Chromium dashboard - ES6 Promises",
	        "href": "https://www.chromestatus.com/features/5681726336532480"
	      },{
	        "name": "JavaScript Promises: There and back again - HTML5 Rocks",
	        "href": "http://www.html5rocks.com/en/tutorials/es6/promises/"
	      }]
	    }
	    !*/
	    /* DOC
	    Check if browser implements ECMAScript 6 Promises per specification.
	    */
	    Modernizr.addTest('promises', function () {
	        return 'Promise' in window &&
	        // Some of these methods are missing from
	        // Firefox/Chrome experimental implementations
	        'resolve' in window.Promise && 'reject' in window.Promise && 'all' in window.Promise && 'race' in window.Promise &&
	        // Older version of the spec had a resolver object
	        // as the arg rather than a function
	        function () {
	            var resolve;
	            new window.Promise(function (r) {
	                resolve = r;
	            });
	            return typeof resolve === 'function';
	        }();
	    });
	    /*!
	    {
	      "name": "Typed arrays",
	      "property": "typedarrays",
	      "caniuse": "typedarrays",
	      "tags": ["js"],
	      "authors": ["Stanley Stuart (@fivetanley)"],
	      "notes": [{
	        "name": "MDN documentation",
	        "href": "https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays"
	      },{
	        "name": "Kronos spec",
	        "href": "https://www.khronos.org/registry/typedarray/specs/latest/"
	      }],
	      "polyfills": ["joshuabell-polyfill"]
	    }
	    !*/
	    /* DOC
	    Detects support for native binary data manipulation via Typed Arrays in JavaScript.
	    
	    Does not check for DataView support; use `Modernizr.dataview` for that.
	    */
	    // Should fail in:
	    // Internet Explorer <= 9
	    // Firefox <= 3.6
	    // Chrome <= 6.0
	    // iOS Safari < 4.2
	    // Safari < 5.1
	    // Opera < 11.6
	    // Opera Mini, <= 7.0
	    // Android Browser < 4.0
	    // Blackberry Browser < 10.0
	    Modernizr.addTest('typedarrays', 'ArrayBuffer' in window);
	    /*!
	    {
	      "name": "Web Audio API",
	      "property": "webaudio",
	      "caniuse": "audio-api",
	      "polyfills": ["xaudiojs", "dynamicaudiojs", "audiolibjs"],
	      "tags": ["audio", "media"],
	      "builderAliases": ["audio_webaudio_api"],
	      "authors": ["Addy Osmani"],
	      "notes": [{
	        "name": "W3 Specification",
	        "href": "https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html"
	      }]
	    }
	    !*/
	    /* DOC
	    Detects the older non standard webaudio API, (as opposed to the standards based AudioContext API)
	    */
	    Modernizr.addTest('webaudio', function () {
	        var prefixed = 'webkitAudioContext' in window;
	        var unprefixed = 'AudioContext' in window;
	        if (Modernizr._config.usePrefixes) {
	            return prefixed || unprefixed;
	        }
	        return unprefixed;
	    });
	    // Run each test
	    testRunner();
	    delete ModernizrProto.addTest;
	    delete ModernizrProto.addAsyncTest;
	    // Run the things that are supposed to run after the tests
	    for (var i = 0; i < Modernizr._q.length; i++) {
	        Modernizr._q[i]();
	    }
	    // Leak Modernizr namespace
	    return Modernizr;
	    
	}))(window, document);
	
	var Modernizr = new _angular_core.OpaqueToken('MODERNIZR'); // tslint:disable-line:variable-name
	// tslint:disable-line:variable-name
	var MODERNIZR_PROVIDER = { provide: Modernizr, useValue: modernizr };
	
	var _slicedToArray$5 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var IsSupportedPromise = new _angular_core.OpaqueToken('IS_SUPPORTED_PROMISE'); // tslint:disable-line:variable-name
	// tslint:disable-line:variable-name
	var IS_SUPPORTED_PROMISE_PROVIDER = {
	    deps: [CloseSupportTester, DecodeAudioDataTypeErrorSupportTester, MergingSupportTester, Modernizr],
	    provide: IsSupportedPromise,
	    useFactory: function useFactory(closeSupportTester, decodeAudioDataTypeErrorSupportTester, mergingSupportTester, modernizr) {
	        if (modernizr.promises && modernizr.typedarrays && modernizr.webaudio && closeSupportTester.test()) {
	            return Promise.all([decodeAudioDataTypeErrorSupportTester.test(), mergingSupportTester.test()]).then(function (_ref) {
	                var _ref2 = _slicedToArray$5(_ref, 2),
	                    decodeAudioDataTypeErrorSupport = _ref2[0],
	                    mergingSupport = _ref2[1];
	
	                return decodeAudioDataTypeErrorSupport && mergingSupport;
	            });
	        }
	        return Promise.resolve(false);
	    }
	};
	
	var _createClass$33 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck$33(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var offlineAudioContextConstructor = new _angular_core.OpaqueToken('OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR');
	var OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
	    deps: [AudioBufferCopyChannelMethodsSupportTester, AudioBufferCopyChannelMethodsWrapper, AudioBufferWrapper, DataCloneErrorFactory, DetachedAudioBuffers, EncodingErrorFactory, IIRFilterNodeGetFrequencyResponseMethodWrapper, OfflineAudioBufferSourceNodeFakerFactory, OfflineAudioDestinationNodeFakerFactory, OfflineBiquadFilterNodeFakerFactory, OfflineGainNodeFakerFactory, OfflineIIRFilterNodeFakerFactory, PromiseSupportTester, unpatchedOfflineAudioContextConstructor],
	    provide: offlineAudioContextConstructor,
	    useFactory: function useFactory(audioBufferCopyChannelMethodsSupportTester, audioBufferCopyChannelMethodsWrapper, audioBufferWrapper, dataCloneErrorFactory, detachedAudioBuffers, encodingErrorFactory, iIRFilterNodeGetFrequencyResponseMethodWrapper, offlineAudioBufferSourceNodeFakerFactory, offlineAudioDestinationNodeFakerFactory, offlineBiquadFilterNodeFakerFactory, offlineGainNodeFakerFactory, offlineIIRFilterNodeFakerFactory, promiseSupportTester, UnpatchedOfflineAudioContext // tslint:disable-line:variable-name
	    ) {
	        var OfflineAudioContext = function () {
	            function OfflineAudioContext(numberOfChannels, length, sampleRate) {
	                _classCallCheck$33(this, OfflineAudioContext);
	
	                var fakeNodeStore = new WeakMap();
	                var unpatchedOfflineAudioContext = new UnpatchedOfflineAudioContext(numberOfChannels, length, sampleRate);
	                this._destination = offlineAudioDestinationNodeFakerFactory.create({ fakeNodeStore: fakeNodeStore });
	                this._fakeNodeStore = fakeNodeStore;
	                this._isSupportingCopyChannelMethods = audioBufferCopyChannelMethodsSupportTester.test(unpatchedOfflineAudioContext);
	                this._isSupportingGetFrequencyResponseErrors = false;
	                this._isSupportingPromises = promiseSupportTester.test(unpatchedOfflineAudioContext);
	                this._length = length;
	                this._numberOfChannels = numberOfChannels;
	                this._unpatchedOfflineAudioContext = unpatchedOfflineAudioContext;
	            }
	
	            _createClass$33(OfflineAudioContext, [{
	                key: 'createBiquadFilter',
	                value: function createBiquadFilter() {
	                    return offlineBiquadFilterNodeFakerFactory.create({
	                        fakeNodeStore: this._fakeNodeStore,
	                        nativeNode: this._unpatchedOfflineAudioContext.createBiquadFilter()
	                    }).proxy;
	                }
	            }, {
	                key: 'createBuffer',
	                value: function createBuffer(numberOfChannels, length, sampleRate) {
	                    // @todo Consider browsers which do not fully support this method yet.
	                    return this._unpatchedOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
	                }
	            }, {
	                key: 'createBufferSource',
	                value: function createBufferSource() {
	                    return offlineAudioBufferSourceNodeFakerFactory.create({
	                        fakeNodeStore: this._fakeNodeStore
	                    }).proxy;
	                }
	            }, {
	                key: 'createGain',
	                value: function createGain() {
	                    return offlineGainNodeFakerFactory.create({
	                        fakeNodeStore: this._fakeNodeStore
	                    }).proxy;
	                }
	            }, {
	                key: 'createIIRFilter',
	                value: function createIIRFilter(feedforward, feedback) {
	                    var nativeNode = null;
	                    // Bug #9: Safari does not support IIRFilterNodes.
	                    if (this._unpatchedOfflineAudioContext.createIIRFilter !== undefined) {
	                        nativeNode = this._unpatchedOfflineAudioContext.createIIRFilter(feedforward, feedback);
	                        // Bug 23 & 24: FirefoxDeveloper does not throw NotSupportedErrors anymore.
	                        if (!this._isSupportingGetFrequencyResponseErrors) {
	                            iIRFilterNodeGetFrequencyResponseMethodWrapper.wrap(nativeNode);
	                        }
	                    }
	                    return offlineIIRFilterNodeFakerFactory.create({
	                        fakeNodeStore: this._fakeNodeStore,
	                        feedback: feedback,
	                        feedforward: feedforward,
	                        length: this.length,
	                        nativeNode: nativeNode,
	                        numberOfChannels: this._numberOfChannels,
	                        sampleRate: this._unpatchedOfflineAudioContext.sampleRate
	                    }).proxy;
	                }
	            }, {
	                key: 'decodeAudioData',
	                value: function decodeAudioData(audioData, successCallback, errorCallback) {
	                    var _this = this;
	
	                    // Bug #43: Only Chrome Canary does yet throw a DataCloneError.
	                    if (detachedAudioBuffers.has(audioData)) {
	                        var err = dataCloneErrorFactory.create();
	                        if (typeof errorCallback === 'function') {
	                            errorCallback(err);
	                        }
	                        return Promise.reject(err);
	                    }
	                    // The audioData parameter maybe of a type which can't be added to a WeakSet.
	                    try {
	                        detachedAudioBuffers.add(audioData);
	                    } catch (err) {}
	                    // Ignore errors.
	
	                    // Bug #21: Safari does not support promises yet.
	                    if (this._isSupportingPromises) {
	                        // Bug #1: Chrome requires a successCallback.
	                        if (successCallback === undefined) {
	                            successCallback = function successCallback() {}; // tslint:disable-line:no-empty
	                        }
	                        return this._unpatchedOfflineAudioContext.decodeAudioData(audioData, successCallback, function (err) {
	                            if (typeof errorCallback === 'function') {
	                                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
	                                if (err instanceof DOMException && err.name === 'NotSupportedError') {
	                                    errorCallback(new TypeError());
	                                } else {
	                                    errorCallback(err);
	                                }
	                            }
	                        }).catch(function (err) {
	                            // Bug #6: Chrome, Firefox and Opera do not call the errorCallback in case of an invalid buffer.
	                            if (typeof errorCallback === 'function' && err instanceof TypeError) {
	                                errorCallback(err);
	                            }
	                            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
	                            if (err instanceof DOMException && err.name === 'NotSupportedError') {
	                                throw new TypeError();
	                            }
	                            throw err;
	                        });
	                    }
	                    // Bug #21: Safari does not return a Promise yet.
	                    return new Promise(function (resolve, reject) {
	                        var fail = function fail(err) {
	                            if (typeof errorCallback === 'function') {
	                                errorCallback(err);
	                            }
	                            reject(err);
	                        };
	                        var succeed = function succeed(dBffrWrppr) {
	                            resolve(dBffrWrppr);
	                            if (typeof successCallback === 'function') {
	                                successCallback(dBffrWrppr);
	                            }
	                        };
	                        // Bug #26: Safari throws a synchronous error.
	                        try {
	                            // Bug #1: Safari requires a successCallback.
	                            _this._unpatchedOfflineAudioContext.decodeAudioData(audioData, function (audioBuffer) {
	                                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
	                                if (typeof audioBuffer.copyFromChannel !== 'function') {
	                                    audioBufferWrapper.wrap(audioBuffer);
	                                    // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
	                                } else if (!_this._isSupportingCopyChannelMethods) {
	                                    audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
	                                }
	                                succeed(audioBuffer);
	                            }, function (err) {
	                                // Bug #4: Safari returns null instead of an error.
	                                if (err === null) {
	                                    fail(encodingErrorFactory.create());
	                                } else {
	                                    fail(err);
	                                }
	                            });
	                        } catch (err) {
	                            fail(err);
	                        }
	                    });
	                }
	                // @todo public resume () {
	                // @todo     return this._unpatchedOfflineAudioContext.resume();
	                // @todo }
	
	            }, {
	                key: 'startRendering',
	                value: function startRendering() {
	                    var _this2 = this;
	
	                    return this._destination.render(this._unpatchedOfflineAudioContext).then(function () {
	                        // Bug #21: Safari does not support promises yet.
	                        if (_this2._isSupportingPromises) {
	                            return _this2._unpatchedOfflineAudioContext.startRendering();
	                        }
	                        return new Promise(function (resolve) {
	                            _this2._unpatchedOfflineAudioContext.oncomplete = function (event) {
	                                return resolve(event.renderedBuffer);
	                            };
	                            _this2._unpatchedOfflineAudioContext.startRendering();
	                        });
	                    });
	                }
	            }, {
	                key: 'currentTime',
	                get: function get() {
	                    return this._unpatchedOfflineAudioContext.currentTime;
	                }
	            }, {
	                key: 'destination',
	                get: function get() {
	                    return this._destination.proxy;
	                }
	            }, {
	                key: 'length',
	                get: function get() {
	                    // Bug #17: Safari does not yet expose the length.
	                    if (this._unpatchedOfflineAudioContext.length === undefined) {
	                        return this._length;
	                    }
	                    return this._unpatchedOfflineAudioContext.length;
	                }
	            }, {
	                key: 'sampleRate',
	                get: function get() {
	                    return this._unpatchedOfflineAudioContext.sampleRate;
	                }
	            }]);
	
	            return OfflineAudioContext;
	        }();
	
	        return OfflineAudioContext;
	    }
	};
	
	(function (AudioContextState) {
	    AudioContextState[AudioContextState["closed"] = 0] = "closed";
	    AudioContextState[AudioContextState["running"] = 1] = "running";
	    AudioContextState[AudioContextState["suspended"] = 2] = "suspended";
	})(exports.AudioContextState || (exports.AudioContextState = {}));
	
	var injector = _angular_core.ReflectiveInjector.resolveAndCreate([AnalyserNodeGetFloatTimeDomainDataMethodWrapper, AnalyserNodeGetFloatTimeDomainDataSupportTester, AudioBufferCopyChannelMethodsSupportTester, AudioBufferCopyChannelMethodsWrapper, AudioBufferSourceNodeStopMethodWrapper, AudioBufferWrapper, AudioNodeConnectMethodWrapper, AudioNodeDisconnectMethodWrapper, AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, ChainingSupportTester, ChannelMergerNodeWrapper, ChannelSplitterNodeWrapper, CloseSupportTester, ConnectingSupportTester, DETACHED_AUDIO_BUFFERS_PROVIDER, DataCloneErrorFactory, DecodeAudioDataTypeErrorSupportTester, DisconnectingSupportTester, EncodingErrorFactory, IIRFilterNodeFaker, IIRFilterNodeGetFrequencyResponseMethodWrapper, IndexSizeErrorFactory, InvalidAccessErrorFactory, InvalidStateErrorFactory, IS_SUPPORTED_PROMISE_PROVIDER, MergingSupportTester, MODERNIZR_PROVIDER, NotSupportedErrorFactory, OfflineAudioBufferSourceNodeFakerFactory, OfflineAudioDestinationNodeFakerFactory, OfflineBiquadFilterNodeFakerFactory, OfflineGainNodeFakerFactory, OfflineIIRFilterNodeFakerFactory, OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, PromiseSupportTester, StopStoppedSupportTester, UNPATCHED_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, UNPATCHED_OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, WINDOW_PROVIDER]);
	// tslint:disable-next-line:variable-name
	var AudioContext = injector.get(audioContextConstructor);
	var isSupported = injector.get(IsSupportedPromise);
	// tslint:disable-next-line:variable-name
	var OfflineAudioContext = injector.get(offlineAudioContextConstructor);
	
	exports.AudioContext = AudioContext;
	exports.isSupported = isSupported;
	exports.OfflineAudioContext = OfflineAudioContext;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(64);
	__webpack_require__(134);
	__webpack_require__(135);
	__webpack_require__(136);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	module.exports = __webpack_require__(99).Reflect;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(65)
	  , anObject                  = __webpack_require__(69)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(66)
	  , $export = __webpack_require__(112)
	  , shared  = __webpack_require__(91)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(126)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(67);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(120)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(68).f
	  , create      = __webpack_require__(77)
	  , redefineAll = __webpack_require__(95)
	  , ctx         = __webpack_require__(100)
	  , anInstance  = __webpack_require__(102)
	  , defined     = __webpack_require__(85)
	  , forOf       = __webpack_require__(103)
	  , $iterDefine = __webpack_require__(110)
	  , step        = __webpack_require__(117)
	  , setSpecies  = __webpack_require__(118)
	  , DESCRIPTORS = __webpack_require__(72)
	  , fastKey     = __webpack_require__(119).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(69)
	  , IE8_DOM_DEFINE = __webpack_require__(71)
	  , toPrimitive    = __webpack_require__(76)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(72) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(70);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(72) && !__webpack_require__(73)(function(){
	  return Object.defineProperty(__webpack_require__(74)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(73)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(70)
	  , document = __webpack_require__(75).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 75 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(70);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(69)
	  , dPs         = __webpack_require__(78)
	  , enumBugKeys = __webpack_require__(93)
	  , IE_PROTO    = __webpack_require__(90)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(74)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(94).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(68)
	  , anObject = __webpack_require__(69)
	  , getKeys  = __webpack_require__(79);
	
	module.exports = __webpack_require__(72) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(80)
	  , enumBugKeys = __webpack_require__(93);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(81)
	  , toIObject    = __webpack_require__(82)
	  , arrayIndexOf = __webpack_require__(86)(false)
	  , IE_PROTO     = __webpack_require__(90)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 81 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(83)
	  , defined = __webpack_require__(85);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(84);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 84 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 85 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(82)
	  , toLength  = __webpack_require__(87)
	  , toIndex   = __webpack_require__(89);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(88)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 88 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(88)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(91)('keys')
	  , uid    = __webpack_require__(92);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(75)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 92 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 93 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(75).document && document.documentElement;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(96);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(75)
	  , hide      = __webpack_require__(97)
	  , has       = __webpack_require__(81)
	  , SRC       = __webpack_require__(92)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(99).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(68)
	  , createDesc = __webpack_require__(98);
	module.exports = __webpack_require__(72) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 99 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(101);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(100)
	  , call        = __webpack_require__(104)
	  , isArrayIter = __webpack_require__(105)
	  , anObject    = __webpack_require__(69)
	  , toLength    = __webpack_require__(87)
	  , getIterFn   = __webpack_require__(108)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(69);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(106)
	  , ITERATOR   = __webpack_require__(107)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(91)('wks')
	  , uid        = __webpack_require__(92)
	  , Symbol     = __webpack_require__(75).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(109)
	  , ITERATOR  = __webpack_require__(107)('iterator')
	  , Iterators = __webpack_require__(106);
	module.exports = __webpack_require__(99).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(84)
	  , TAG = __webpack_require__(107)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(111)
	  , $export        = __webpack_require__(112)
	  , redefine       = __webpack_require__(96)
	  , hide           = __webpack_require__(97)
	  , has            = __webpack_require__(81)
	  , Iterators      = __webpack_require__(106)
	  , $iterCreate    = __webpack_require__(113)
	  , setToStringTag = __webpack_require__(114)
	  , getPrototypeOf = __webpack_require__(115)
	  , ITERATOR       = __webpack_require__(107)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(75)
	  , core      = __webpack_require__(99)
	  , hide      = __webpack_require__(97)
	  , redefine  = __webpack_require__(96)
	  , ctx       = __webpack_require__(100)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(77)
	  , descriptor     = __webpack_require__(98)
	  , setToStringTag = __webpack_require__(114)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(97)(IteratorPrototype, __webpack_require__(107)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(68).f
	  , has = __webpack_require__(81)
	  , TAG = __webpack_require__(107)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(81)
	  , toObject    = __webpack_require__(116)
	  , IE_PROTO    = __webpack_require__(90)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(85);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 117 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(75)
	  , dP          = __webpack_require__(68)
	  , DESCRIPTORS = __webpack_require__(72)
	  , SPECIES     = __webpack_require__(107)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(92)('meta')
	  , isObject = __webpack_require__(70)
	  , has      = __webpack_require__(81)
	  , setDesc  = __webpack_require__(68).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(73)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(75)
	  , $export           = __webpack_require__(112)
	  , redefine          = __webpack_require__(96)
	  , redefineAll       = __webpack_require__(95)
	  , meta              = __webpack_require__(119)
	  , forOf             = __webpack_require__(103)
	  , anInstance        = __webpack_require__(102)
	  , isObject          = __webpack_require__(70)
	  , fails             = __webpack_require__(73)
	  , $iterDetect       = __webpack_require__(121)
	  , setToStringTag    = __webpack_require__(114)
	  , inheritIfRequired = __webpack_require__(122);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(107)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(70)
	  , setPrototypeOf = __webpack_require__(123).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(70)
	  , anObject = __webpack_require__(69);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(100)(Function.call, __webpack_require__(124).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(125)
	  , createDesc     = __webpack_require__(98)
	  , toIObject      = __webpack_require__(82)
	  , toPrimitive    = __webpack_require__(76)
	  , has            = __webpack_require__(81)
	  , IE8_DOM_DEFINE = __webpack_require__(71)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(72) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 125 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(127)(0)
	  , redefine     = __webpack_require__(96)
	  , meta         = __webpack_require__(119)
	  , assign       = __webpack_require__(131)
	  , weak         = __webpack_require__(133)
	  , isObject     = __webpack_require__(70)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(120)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(100)
	  , IObject  = __webpack_require__(83)
	  , toObject = __webpack_require__(116)
	  , toLength = __webpack_require__(87)
	  , asc      = __webpack_require__(128);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(129);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(70)
	  , isArray  = __webpack_require__(130)
	  , SPECIES  = __webpack_require__(107)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(84);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(79)
	  , gOPS     = __webpack_require__(132)
	  , pIE      = __webpack_require__(125)
	  , toObject = __webpack_require__(116)
	  , IObject  = __webpack_require__(83)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(73)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 132 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(95)
	  , getWeak           = __webpack_require__(119).getWeak
	  , anObject          = __webpack_require__(69)
	  , isObject          = __webpack_require__(70)
	  , anInstance        = __webpack_require__(102)
	  , forOf             = __webpack_require__(103)
	  , createArrayMethod = __webpack_require__(127)
	  , $has              = __webpack_require__(81)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(65)
	  , anObject               = __webpack_require__(69)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(65)
	  , anObject               = __webpack_require__(69)
	  , getPrototypeOf         = __webpack_require__(115)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(137)
	  , from                    = __webpack_require__(138)
	  , metadata                = __webpack_require__(65)
	  , anObject                = __webpack_require__(69)
	  , getPrototypeOf          = __webpack_require__(115)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(67);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(120)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(103);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(65)
	  , anObject               = __webpack_require__(69)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(65)
	  , anObject                = __webpack_require__(69)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(65)
	  , anObject               = __webpack_require__(69)
	  , getPrototypeOf         = __webpack_require__(115)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(65)
	  , anObject               = __webpack_require__(69)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(65)
	  , anObject                  = __webpack_require__(69)
	  , aFunction                 = __webpack_require__(101)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v4.1.0
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(145), __webpack_require__(159), __webpack_require__(172), __webpack_require__(175)) :
		typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Observable', 'rxjs/observable/merge', 'rxjs/operator/share', 'rxjs/Subject'], factory) :
		(factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx));
	}(this, (function (exports,rxjs_Observable,rxjs_observable_merge,rxjs_operator_share,rxjs_Subject) { 'use strict';
	
	var __extends = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @license Angular v4.1.0
	 * (c) 2010-2017 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	/**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
	 *
	 * ```typescript
	 * var t = new OpaqueToken("value");
	 *
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: t, useValue: "bindingValue"}
	 * ]);
	 *
	 * expect(injector.get(t)).toEqual("bindingValue");
	 * ```
	 *
	 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
	 * caused by multiple providers using the same string as two different tokens.
	 *
	 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
	 * error messages.
	 * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`
	 * instead.
	 */
	var OpaqueToken = (function () {
	    /**
	     * @param {?} _desc
	     */
	    function OpaqueToken(_desc) {
	        this._desc = _desc;
	    }
	    /**
	     * @return {?}
	     */
	    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	    return OpaqueToken;
	}());
	/**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
	 * runtime representation) such as when injecting an interface, callable type, array or
	 * parametrized type.
	 *
	 * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
	 * the `Injector`. This provides additional level of type safety.
	 *
	 * ```
	 * interface MyInterface {...}
	 * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
	 * // myInterface is inferred to be MyInterface.
	 * ```
	 *
	 * ### Example
	 *
	 * {\@example core/di/ts/injector_spec.ts region='InjectionToken'}
	 *
	 * \@stable
	 */
	var InjectionToken = (function (_super) {
	    __extends(InjectionToken, _super);
	    /**
	     * @param {?} desc
	     */
	    function InjectionToken(desc) {
	        return _super.call(this, desc) || this;
	    }
	    /**
	     * @return {?}
	     */
	    InjectionToken.prototype.toString = function () { return "InjectionToken " + this._desc; };
	    return InjectionToken;
	}(OpaqueToken));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof global !== 'undefined' && global;
	var _global = __window || __global || __self;
	var _symbolIterator = null;
	/**
	 * @return {?}
	 */
	function getSymbolIterator() {
	    if (!_symbolIterator) {
	        var /** @type {?} */ Symbol = _global['Symbol'];
	        if (Symbol && Symbol.iterator) {
	            _symbolIterator = Symbol.iterator;
	        }
	        else {
	            // es6-shim specific logic
	            var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	                var /** @type {?} */ key = keys[i];
	                if (key !== 'entries' && key !== 'size' &&
	                    ((Map)).prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator;
	}
	/**
	 * @param {?} fn
	 * @return {?}
	 */
	function scheduleMicroTask(fn) {
	    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	}
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function looseIdentical(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	/**
	 * @param {?} token
	 * @return {?}
	 */
	function stringify(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token == null) {
	        return '' + token;
	    }
	    if (token.overriddenName) {
	        return "" + token.overriddenName;
	    }
	    if (token.name) {
	        return "" + token.name;
	    }
	    var /** @type {?} */ res = token.toString();
	    if (res == null) {
	        return '' + res;
	    }
	    var /** @type {?} */ newLineIndex = res.indexOf('\n');
	    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _nextClassId = 0;
	var Reflect = _global['Reflect'];
	/**
	 * @param {?} annotation
	 * @return {?}
	 */
	function extractAnnotation(annotation) {
	    if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
	        // it is a decorator, extract annotation
	        annotation = annotation.annotation;
	    }
	    return annotation;
	}
	/**
	 * @param {?} fnOrArray
	 * @param {?} key
	 * @return {?}
	 */
	function applyParams(fnOrArray, key) {
	    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	        fnOrArray === Number || fnOrArray === Array) {
	        throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
	    }
	    if (typeof fnOrArray === 'function') {
	        return fnOrArray;
	    }
	    if (Array.isArray(fnOrArray)) {
	        var /** @type {?} */ annotations = (fnOrArray);
	        var /** @type {?} */ annoLength = annotations.length - 1;
	        var /** @type {?} */ fn = fnOrArray[annoLength];
	        if (typeof fn !== 'function') {
	            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
	        }
	        if (annoLength != fn.length) {
	            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
	        }
	        var /** @type {?} */ paramsAnnotations = [];
	        for (var /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {
	            var /** @type {?} */ paramAnnotations = [];
	            paramsAnnotations.push(paramAnnotations);
	            var /** @type {?} */ annotation = annotations[i];
	            if (Array.isArray(annotation)) {
	                for (var /** @type {?} */ j = 0; j < annotation.length; j++) {
	                    paramAnnotations.push(extractAnnotation(annotation[j]));
	                }
	            }
	            else if (typeof annotation === 'function') {
	                paramAnnotations.push(extractAnnotation(annotation));
	            }
	            else {
	                paramAnnotations.push(annotation);
	            }
	        }
	        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	        return fn;
	    }
	    throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
	}
	/**
	 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	 *
	 * ## Basic Example
	 *
	 * ```
	 * var Greeter = ng.Class({
	 *   constructor: function(name) {
	 *     this.name = name;
	 *   },
	 *
	 *   greet: function() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class Greeter {
	 *   constructor(name) {
	 *     this.name = name;
	 *   }
	 *
	 *   greet() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * }
	 * ```
	 *
	 * or equivalent to ES5:
	 *
	 * ```
	 * var Greeter = function (name) {
	 *   this.name = name;
	 * }
	 *
	 * Greeter.prototype.greet = function () {
	 *   alert('Hello ' + this.name + '!');
	 * }
	 * ```
	 *
	 * ### Example with parameter annotations
	 *
	 * ```
	 * var MyService = ng.Class({
	 *   constructor: [String, [new Optional(), Service], function(name, myService) {
	 *     ...
	 *   }]
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class MyService {
	 *   constructor(name: string, \@Optional() myService: Service) {
	 *     ...
	 *   }
	 * }
	 * ```
	 *
	 * ### Example with inheritance
	 *
	 * ```
	 * var Shape = ng.Class({
	 *   constructor: (color) {
	 *     this.color = color;
	 *   }
	 * });
	 *
	 * var Square = ng.Class({
	 *   extends: Shape,
	 *   constructor: function(color, size) {
	 *     Shape.call(this, color);
	 *     this.size = size;
	 *   }
	 * });
	 * ```
	 * @suppress {globalThis}
	 * \@stable
	 * @param {?} clsDef
	 * @return {?}
	 */
	function Class(clsDef) {
	    var /** @type {?} */ constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	    var /** @type {?} */ proto = constructor.prototype;
	    if (clsDef.hasOwnProperty('extends')) {
	        if (typeof clsDef.extends === 'function') {
	            ((constructor)).prototype = proto =
	                Object.create(((clsDef.extends)).prototype);
	        }
	        else {
	            throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
	        }
	    }
	    for (var /** @type {?} */ key in clsDef) {
	        if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
	            proto[key] = applyParams(clsDef[key], key);
	        }
	    }
	    if (this && this.annotations instanceof Array) {
	        Reflect.defineMetadata('annotations', this.annotations, constructor);
	    }
	    var /** @type {?} */ constructorName = constructor['name'];
	    if (!constructorName || constructorName === 'constructor') {
	        ((constructor))['overriddenName'] = "class" + _nextClassId++;
	    }
	    return (constructor);
	}
	/**
	 * @suppress {globalThis}
	 * @param {?} name
	 * @param {?} props
	 * @param {?=} parentClass
	 * @param {?=} chainFn
	 * @return {?}
	 */
	function makeDecorator(name, props, parentClass, chainFn) {
	    var /** @type {?} */ metaCtor = makeMetadataCtor([props]);
	    /**
	     * @param {?} objOrType
	     * @return {?}
	     */
	    function DecoratorFactory(objOrType) {
	        if (!(Reflect && Reflect.getOwnMetadata)) {
	            throw 'reflect-metadata shim is required when using class decorators';
	        }
	        if (this instanceof DecoratorFactory) {
	            metaCtor.call(this, objOrType);
	            return this;
	        }
	        var /** @type {?} */ annotationInstance = new ((DecoratorFactory))(objOrType);
	        var /** @type {?} */ chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
	        chainAnnotation.push(annotationInstance);
	        var /** @type {?} */ TypeDecorator = (function TypeDecorator(cls) {
	            var /** @type {?} */ annotations = Reflect.getOwnMetadata('annotations', cls) || [];
	            annotations.push(annotationInstance);
	            Reflect.defineMetadata('annotations', annotations, cls);
	            return cls;
	        });
	        TypeDecorator.annotations = chainAnnotation;
	        TypeDecorator.Class = Class;
	        if (chainFn)
	            chainFn(TypeDecorator);
	        return TypeDecorator;
	    }
	    if (parentClass) {
	        DecoratorFactory.prototype = Object.create(parentClass.prototype);
	    }
	    DecoratorFactory.prototype.toString = function () { return "@" + name; };
	    ((DecoratorFactory)).annotationCls = DecoratorFactory;
	    return DecoratorFactory;
	}
	/**
	 * @param {?} props
	 * @return {?}
	 */
	function makeMetadataCtor(props) {
	    return function ctor() {
	        var _this = this;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        props.forEach(function (prop, i) {
	            var /** @type {?} */ argVal = args[i];
	            if (Array.isArray(prop)) {
	                // plain parameter
	                _this[prop[0]] = argVal === undefined ? prop[1] : argVal;
	            }
	            else {
	                for (var /** @type {?} */ propName in prop) {
	                    _this[propName] =
	                        argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];
	                }
	            }
	        });
	    };
	}
	/**
	 * @param {?} name
	 * @param {?} props
	 * @param {?=} parentClass
	 * @return {?}
	 */
	function makeParamDecorator(name, props, parentClass) {
	    var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	    /**
	     * @param {...?} args
	     * @return {?}
	     */
	    function ParamDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (this instanceof ParamDecoratorFactory) {
	            metaCtor.apply(this, args);
	            return this;
	        }
	        var /** @type {?} */ annotationInstance = new (((ParamDecoratorFactory)).bind.apply(((ParamDecoratorFactory)), [void 0].concat(args)))();
	        ((ParamDecorator)).annotation = annotationInstance;
	        return ParamDecorator;
	        /**
	         * @param {?} cls
	         * @param {?} unusedKey
	         * @param {?} index
	         * @return {?}
	         */
	        function ParamDecorator(cls, unusedKey, index) {
	            var /** @type {?} */ parameters = Reflect.getOwnMetadata('parameters', cls) || [];
	            // there might be gaps if some in between parameters do not have annotations.
	            // we pad with nulls.
	            while (parameters.length <= index) {
	                parameters.push(null);
	            }
	            parameters[index] = parameters[index] || []; /** @type {?} */
	            ((parameters[index])).push(annotationInstance);
	            Reflect.defineMetadata('parameters', parameters, cls);
	            return cls;
	        }
	    }
	    if (parentClass) {
	        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
	    }
	    ParamDecoratorFactory.prototype.toString = function () { return "@" + name; };
	    ((ParamDecoratorFactory)).annotationCls = ParamDecoratorFactory;
	    return ParamDecoratorFactory;
	}
	/**
	 * @param {?} name
	 * @param {?} props
	 * @param {?=} parentClass
	 * @return {?}
	 */
	function makePropDecorator(name, props, parentClass) {
	    var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	    /**
	     * @param {...?} args
	     * @return {?}
	     */
	    function PropDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (this instanceof PropDecoratorFactory) {
	            metaCtor.apply(this, args);
	            return this;
	        }
	        var /** @type {?} */ decoratorInstance = new (((PropDecoratorFactory)).bind.apply(((PropDecoratorFactory)), [void 0].concat(args)))();
	        return function PropDecorator(target, name) {
	            var /** @type {?} */ meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
	            meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
	            meta[name].unshift(decoratorInstance);
	            Reflect.defineMetadata('propMetadata', meta, target.constructor);
	        };
	    }
	    if (parentClass) {
	        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
	    }
	    PropDecoratorFactory.prototype.toString = function () { return "@" + name; };
	    ((PropDecoratorFactory)).annotationCls = PropDecoratorFactory;
	    return PropDecoratorFactory;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * This token can be used to create a virtual provider that will populate the
	 * `entryComponents` fields of components and ng modules based on its `useValue`.
	 * All components that are referenced in the `useValue` value (either directly
	 * or in a nested array or map) will be added to the `entryComponents` property.
	 *
	 * ### Example
	 * The following example shows how the router can populate the `entryComponents`
	 * field of an NgModule based on the router configuration which refers
	 * to components.
	 *
	 * ```typescript
	 * // helper function inside the router
	 * function provideRoutes(routes) {
	 *   return [
	 *     {provide: ROUTES, useValue: routes},
	 *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	 *   ];
	 * }
	 *
	 * // user code
	 * let routes = [
	 *   {path: '/root', component: RootComp},
	 *   {path: '/teams', component: TeamsComp}
	 * ];
	 *
	 * \@NgModule({
	 *   providers: [provideRoutes(routes)]
	 * })
	 * class ModuleWithRoutes {}
	 * ```
	 *
	 * \@experimental
	 */
	var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
	/**
	 * Attribute decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
	/**
	 * Base class for query metadata.
	 *
	 * See {\@link ContentChildren}, {\@link ContentChild}, {\@link ViewChildren}, {\@link ViewChild} for
	 * more information.
	 *
	 * \@stable
	 * @abstract
	 */
	var Query = (function () {
	    function Query() {
	    }
	    return Query;
	}());
	/**
	 * ContentChildren decorator and metadata.
	 *
	 *  \@stable
	 *  \@Annotation
	 */
	var ContentChildren = makePropDecorator('ContentChildren', [
	    ['selector', undefined], {
	        first: false,
	        isViewQuery: false,
	        descendants: false,
	        read: undefined,
	    }
	], Query);
	/**
	 * ContentChild decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var ContentChild = makePropDecorator('ContentChild', [
	    ['selector', undefined], {
	        first: true,
	        isViewQuery: false,
	        descendants: true,
	        read: undefined,
	    }
	], Query);
	/**
	 * ViewChildren decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var ViewChildren = makePropDecorator('ViewChildren', [
	    ['selector', undefined], {
	        first: false,
	        isViewQuery: true,
	        descendants: true,
	        read: undefined,
	    }
	], Query);
	/**
	 * ViewChild decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var ViewChild = makePropDecorator('ViewChild', [
	    ['selector', undefined], {
	        first: true,
	        isViewQuery: true,
	        descendants: true,
	        read: undefined,
	    }
	], Query);
	var ChangeDetectionStrategy = {};
	ChangeDetectionStrategy.OnPush = 0;
	ChangeDetectionStrategy.Default = 1;
	ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush";
	ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default";
	var ChangeDetectorStatus = {};
	ChangeDetectorStatus.CheckOnce = 0;
	ChangeDetectorStatus.Checked = 1;
	ChangeDetectorStatus.CheckAlways = 2;
	ChangeDetectorStatus.Detached = 3;
	ChangeDetectorStatus.Errored = 4;
	ChangeDetectorStatus.Destroyed = 5;
	ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = "CheckOnce";
	ChangeDetectorStatus[ChangeDetectorStatus.Checked] = "Checked";
	ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = "CheckAlways";
	ChangeDetectorStatus[ChangeDetectorStatus.Detached] = "Detached";
	ChangeDetectorStatus[ChangeDetectorStatus.Errored] = "Errored";
	ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = "Destroyed";
	/**
	 * @param {?} changeDetectionStrategy
	 * @return {?}
	 */
	function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	    return changeDetectionStrategy == null ||
	        changeDetectionStrategy === ChangeDetectionStrategy.Default;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Directive decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Directive = makeDecorator('Directive', {
	    selector: undefined,
	    inputs: undefined,
	    outputs: undefined,
	    host: undefined,
	    providers: undefined,
	    exportAs: undefined,
	    queries: undefined
	});
	/**
	 * Component decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Component = makeDecorator('Component', {
	    selector: undefined,
	    inputs: undefined,
	    outputs: undefined,
	    host: undefined,
	    exportAs: undefined,
	    moduleId: undefined,
	    providers: undefined,
	    viewProviders: undefined,
	    changeDetection: ChangeDetectionStrategy.Default,
	    queries: undefined,
	    templateUrl: undefined,
	    template: undefined,
	    styleUrls: undefined,
	    styles: undefined,
	    animations: undefined,
	    encapsulation: undefined,
	    interpolation: undefined,
	    entryComponents: undefined
	}, Directive);
	/**
	 * Pipe decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Pipe = makeDecorator('Pipe', {
	    name: undefined,
	    pure: true,
	});
	/**
	 * Input decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
	/**
	 * Output decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
	/**
	 * HostBinding decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
	/**
	 * HostListener decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Defines a schema that will allow:
	 * - any non-Angular elements with a `-` in their name,
	 * - any properties on elements with a `-` in their name which is the common rule for custom
	 * elements.
	 *
	 * \@stable
	 */
	var CUSTOM_ELEMENTS_SCHEMA = {
	    name: 'custom-elements'
	};
	/**
	 * Defines a schema that will allow any property on any element.
	 *
	 * \@experimental
	 */
	var NO_ERRORS_SCHEMA = {
	    name: 'no-errors-schema'
	};
	/**
	 * NgModule decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var NgModule = makeDecorator('NgModule', {
	    providers: undefined,
	    declarations: undefined,
	    imports: undefined,
	    exports: undefined,
	    entryComponents: undefined,
	    bootstrap: undefined,
	    schemas: undefined,
	    id: undefined,
	});
	var ViewEncapsulation = {};
	ViewEncapsulation.Emulated = 0;
	ViewEncapsulation.Native = 1;
	ViewEncapsulation.None = 2;
	ViewEncapsulation[ViewEncapsulation.Emulated] = "Emulated";
	ViewEncapsulation[ViewEncapsulation.Native] = "Native";
	ViewEncapsulation[ViewEncapsulation.None] = "None";
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * For details on the `\@Component` annotation, see {\@link Component}.
	 *
	 * ### Example
	 *
	 * ```
	 * \@Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 *
	 * @deprecated Use Component instead.
	 *
	 * {\@link Component}
	 */
	var ViewMetadata = (function () {
	    /**
	     * @param {?=} __0
	     */
	    function ViewMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
	        this.templateUrl = templateUrl;
	        this.template = template;
	        this.styleUrls = styleUrls;
	        this.styles = styles;
	        this.encapsulation = encapsulation;
	        this.animations = animations;
	        this.interpolation = interpolation;
	    }
	    return ViewMetadata;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Represents the version of Angular
	 *
	 * \@stable
	 */
	var Version = (function () {
	    /**
	     * @param {?} full
	     */
	    function Version(full) {
	        this.full = full;
	    }
	    Object.defineProperty(Version.prototype, "major", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.full.split('.')[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Version.prototype, "minor", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.full.split('.')[1]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Version.prototype, "patch", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.full.split('.').slice(2).join('.'); },
	        enumerable: true,
	        configurable: true
	    });
	    return Version;
	}());
	/**
	 * \@stable
	 */
	var VERSION = new Version('4.1.0');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Inject decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Inject = makeParamDecorator('Inject', [['token', undefined]]);
	/**
	 * Optional decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Optional = makeParamDecorator('Optional', []);
	/**
	 * Injectable decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Injectable = makeDecorator('Injectable', []);
	/**
	 * Self decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Self = makeParamDecorator('Self', []);
	/**
	 * SkipSelf decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var SkipSelf = makeParamDecorator('SkipSelf', []);
	/**
	 * Host decorator and metadata.
	 *
	 * \@stable
	 * \@Annotation
	 */
	var Host = makeParamDecorator('Host', []);
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	 * DI is declared,
	 * but not yet defined. It is also used when the `token` which we use when creating a query is not
	 * yet defined.
	 *
	 * ### Example
	 * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
	 * \@experimental
	 * @param {?} forwardRefFn
	 * @return {?}
	 */
	function forwardRef(forwardRefFn) {
	    ((forwardRefFn)).__forward_ref__ = forwardRef;
	    ((forwardRefFn)).toString = function () { return stringify(this()); };
	    return (((forwardRefFn)));
	}
	/**
	 * Lazily retrieves the reference value from a forwardRef.
	 *
	 * Acts as the identity function when given a non-forward-ref value.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	 *
	 * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
	 *
	 * See: {\@link forwardRef}
	 * \@experimental
	 * @param {?} type
	 * @return {?}
	 */
	function resolveForwardRef(type) {
	    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
	        type.__forward_ref__ === forwardRef) {
	        return ((type))();
	    }
	    else {
	        return type;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _THROW_IF_NOT_FOUND = new Object();
	var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	var _NullInjector = (function () {
	    function _NullInjector() {
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    _NullInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
	        if (notFoundValue === _THROW_IF_NOT_FOUND) {
	            throw new Error("No provider for " + stringify(token) + "!");
	        }
	        return notFoundValue;
	    };
	    return _NullInjector;
	}());
	/**
	 * \@whatItDoes Injector interface
	 * \@howToUse
	 * ```
	 * const injector: Injector = ...;
	 * injector.get(...);
	 * ```
	 *
	 * \@description
	 * For more details, see the {\@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
	 *
	 * ### Example
	 *
	 * {\@example core/di/ts/injector_spec.ts region='Injector'}
	 *
	 * `Injector` returns itself when given `Injector` as a token:
	 * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
	 *
	 * \@stable
	 * @abstract
	 */
	var Injector = (function () {
	    function Injector() {
	    }
	    /**
	     * Retrieves an instance from the injector based on the provided token.
	     * If not found:
	     * - Throws {\@link NoProviderError} if no `notFoundValue` that is not equal to
	     * Injector.THROW_IF_NOT_FOUND is given
	     * - Returns the `notFoundValue` otherwise
	     * @abstract
	     * @template T
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    Injector.prototype.get = function (token, notFoundValue) { };
	    /**
	     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
	     * @suppress {duplicate}
	     * @abstract
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    Injector.prototype.get = function (token, notFoundValue) { };
	    return Injector;
	}());
	Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	Injector.NULL = new _NullInjector();
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ERROR_COMPONENT_TYPE = 'ngComponentType';
	var ERROR_DEBUG_CONTEXT = 'ngDebugContext';
	var ERROR_ORIGINAL_ERROR = 'ngOriginalError';
	var ERROR_LOGGER = 'ngErrorLogger';
	/**
	 * @param {?} error
	 * @return {?}
	 */
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function getDebugContext(error) {
	    return ((error))[ERROR_DEBUG_CONTEXT];
	}
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function getOriginalError(error) {
	    return ((error))[ERROR_ORIGINAL_ERROR];
	}
	/**
	 * @param {?} error
	 * @return {?}
	 */
	function getErrorLogger(error) {
	    return ((error))[ERROR_LOGGER] || defaultErrorLogger;
	}
	/**
	 * @param {?} console
	 * @param {...?} values
	 * @return {?}
	 */
	function defaultErrorLogger(console) {
	    var values = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        values[_i - 1] = arguments[_i];
	    }
	    console.error.apply(console, values);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@whatItDoes Provides a hook for centralized exception handling.
	 *
	 * \@description
	 *
	 * The default implementation of `ErrorHandler` prints error messages to the `console`. To
	 * intercept error handling, write a custom exception handler that replaces this default as
	 * appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```
	 * class MyErrorHandler implements ErrorHandler {
	 *   handleError(error) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * \@NgModule({
	 *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
	 * })
	 * class MyModule {}
	 * ```
	 *
	 * \@stable
	 */
	var ErrorHandler = (function () {
	    /**
	     * @param {?=} deprecatedParameter
	     */
	    function ErrorHandler(
	        /**
	         * @deprecated since v4.0 parameter no longer has an effect, as ErrorHandler will never
	         * rethrow.
	         */
	        deprecatedParameter) {
	        /**
	         * \@internal
	         */
	        this._console = console;
	    }
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    ErrorHandler.prototype.handleError = function (error) {
	        var /** @type {?} */ originalError = this._findOriginalError(error);
	        var /** @type {?} */ context = this._findContext(error);
	        // Note: Browser consoles show the place from where console.error was called.
	        // We can use this to give users additional information about the error.
	        var /** @type {?} */ errorLogger = getErrorLogger(error);
	        errorLogger(this._console, "ERROR", error);
	        if (originalError) {
	            errorLogger(this._console, "ORIGINAL ERROR", originalError);
	        }
	        if (context) {
	            errorLogger(this._console, 'ERROR CONTEXT', context);
	        }
	    };
	    /**
	     * \@internal
	     * @param {?} error
	     * @return {?}
	     */
	    ErrorHandler.prototype._findContext = function (error) {
	        if (error) {
	            return getDebugContext(error) ? getDebugContext(error) :
	                this._findContext(getOriginalError(error));
	        }
	        return null;
	    };
	    /**
	     * \@internal
	     * @param {?} error
	     * @return {?}
	     */
	    ErrorHandler.prototype._findOriginalError = function (error) {
	        var /** @type {?} */ e = getOriginalError(error);
	        while (e && getOriginalError(e)) {
	            e = getOriginalError(e);
	        }
	        return e;
	    };
	    return ErrorHandler;
	}());
	/**
	 * @param {?} message
	 * @param {?} originalError
	 * @return {?}
	 */
	function wrappedError(message, originalError) {
	    var /** @type {?} */ msg = message + " caused by: " + (originalError instanceof Error ? originalError.message : originalError);
	    var /** @type {?} */ error = Error(msg);
	    ((error))[ERROR_ORIGINAL_ERROR] = originalError;
	    return error;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} keys
	 * @return {?}
	 */
	function findFirstClosedCycle(keys) {
	    var /** @type {?} */ res = [];
	    for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	        if (res.indexOf(keys[i]) > -1) {
	            res.push(keys[i]);
	            return res;
	        }
	        res.push(keys[i]);
	    }
	    return res;
	}
	/**
	 * @param {?} keys
	 * @return {?}
	 */
	function constructResolvingPath(keys) {
	    if (keys.length > 1) {
	        var /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());
	        var /** @type {?} */ tokenStrs = reversed.map(function (k) { return stringify(k.token); });
	        return ' (' + tokenStrs.join(' -> ') + ')';
	    }
	    return '';
	}
	/**
	 * @param {?} injector
	 * @param {?} key
	 * @param {?} constructResolvingMessage
	 * @param {?=} originalError
	 * @return {?}
	 */
	function injectionError(injector, key, constructResolvingMessage, originalError) {
	    var /** @type {?} */ error = ((originalError ? wrappedError('', originalError) : Error()));
	    error.addKey = addKey;
	    error.keys = [key];
	    error.injectors = [injector];
	    error.constructResolvingMessage = constructResolvingMessage;
	    error.message = error.constructResolvingMessage();
	    ((error))[ERROR_ORIGINAL_ERROR] = originalError;
	    return error;
	}
	/**
	 * @this {?}
	 * @param {?} injector
	 * @param {?} key
	 * @return {?}
	 */
	function addKey(injector, key) {
	    this.injectors.push(injector);
	    this.keys.push(key);
	    this.message = this.constructResolvingMessage();
	}
	/**
	 * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
	 * {\@link Injector} does not have a {\@link Provider} for the given key.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 * @param {?} injector
	 * @param {?} key
	 * @return {?}
	 */
	function noProviderError(injector, key) {
	    return injectionError(injector, key, function () {
	        var /** @type {?} */ first = stringify(this.keys[0].token);
	        return "No provider for " + first + "!" + constructResolvingPath(this.keys);
	    });
	}
	/**
	 * Thrown when dependencies form a cycle.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	 *
	 * ```typescript
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	 *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	 * ]);
	 *
	 * expect(() => injector.get("one")).toThrowError();
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 * @param {?} injector
	 * @param {?} key
	 * @return {?}
	 */
	function cyclicDependencyError(injector, key) {
	    return injectionError(injector, key, function () {
	        return "Cannot instantiate cyclic dependency!" + constructResolvingPath(this.keys);
	    });
	}
	/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor() {
	 *     throw new Error('message');
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 * try {
	 *   injector.get(A);
	 * } catch (e) {
	 *   expect(e instanceof InstantiationError).toBe(true);
	 *   expect(e.originalException.message).toEqual("message");
	 *   expect(e.originalStack).toBeDefined();
	 * }
	 * ```
	 * @param {?} injector
	 * @param {?} originalException
	 * @param {?} originalStack
	 * @param {?} key
	 * @return {?}
	 */
	function instantiationError(injector, originalException, originalStack, key) {
	    return injectionError(injector, key, function () {
	        var /** @type {?} */ first = stringify(this.keys[0].token);
	        return getOriginalError(this).message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	    }, originalException);
	}
	/**
	 * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
	 * creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	 * ```
	 * @param {?} provider
	 * @return {?}
	 */
	function invalidProviderError(provider) {
	    return Error("Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	}
	/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 *
	 * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
	 *
	 * ```typescript
	 * class B {}
	 *
	 * class A {
	 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	 * ```
	 * \@stable
	 * @param {?} typeOrFunc
	 * @param {?} params
	 * @return {?}
	 */
	function noAnnotationError(typeOrFunc, params) {
	    var /** @type {?} */ signature = [];
	    for (var /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {
	        var /** @type {?} */ parameter = params[i];
	        if (!parameter || parameter.length == 0) {
	            signature.push('?');
	        }
	        else {
	            signature.push(parameter.map(stringify).join(' '));
	        }
	    }
	    return Error('Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
	        signature.join(', ') + '). ' +
	        'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	        stringify(typeOrFunc) + '\' is decorated with Injectable.');
	}
	/**
	 * Thrown when getting an object by index.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	 *
	 * ```typescript
	 * class A {}
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 *
	 * expect(() => injector.getAt(100)).toThrowError();
	 * ```
	 * \@stable
	 * @param {?} index
	 * @return {?}
	 */
	function outOfBoundsError(index) {
	    return Error("Index " + index + " is out-of-bounds.");
	}
	/**
	 * Thrown when a multi provider and a regular provider are bound to the same token.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate([
	 *   { provide: "Strings", useValue: "string1", multi: true},
	 *   { provide: "Strings", useValue: "string2", multi: false}
	 * ])).toThrowError();
	 * ```
	 * @param {?} provider1
	 * @param {?} provider2
	 * @return {?}
	 */
	function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	    return Error("Cannot mix multi providers and regular providers, got: " + provider1 + " " + provider2);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`.
	 *
	 * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
	 * the
	 * injector to store created objects in a more efficient way.
	 *
	 * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
	 * resolving
	 * providers.
	 * \@experimental
	 */
	var ReflectiveKey = (function () {
	    /**
	     * Private
	     * @param {?} token
	     * @param {?} id
	     */
	    function ReflectiveKey(token, id) {
	        this.token = token;
	        this.id = id;
	        if (!token) {
	            throw new Error('Token must be defined!');
	        }
	    }
	    Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	        /**
	         * Returns a stringified token.
	         * @return {?}
	         */
	        get: function () { return stringify(this.token); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Retrieves a `Key` for a token.
	     * @param {?} token
	     * @return {?}
	     */
	    ReflectiveKey.get = function (token) {
	        return _globalKeyRegistry.get(resolveForwardRef(token));
	    };
	    Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	        /**
	         * @return {?} the number of keys registered in the system.
	         */
	        get: function () { return _globalKeyRegistry.numberOfKeys; },
	        enumerable: true,
	        configurable: true
	    });
	    return ReflectiveKey;
	}());
	/**
	 * \@internal
	 */
	var KeyRegistry = (function () {
	    function KeyRegistry() {
	        this._allKeys = new Map();
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    KeyRegistry.prototype.get = function (token) {
	        if (token instanceof ReflectiveKey)
	            return token;
	        if (this._allKeys.has(token)) {
	            return ((this._allKeys.get(token)));
	        }
	        var /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	        this._allKeys.set(token, newKey);
	        return newKey;
	    };
	    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._allKeys.size; },
	        enumerable: true,
	        configurable: true
	    });
	    return KeyRegistry;
	}());
	var _globalKeyRegistry = new KeyRegistry();
	/**
	 * \@whatItDoes Represents a type that a Component or other object is instances of.
	 *
	 * \@description
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * \@stable
	 */
	var Type = Function;
	/**
	 * @param {?} v
	 * @return {?}
	 */
	function isType(v) {
	    return typeof v === 'function';
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Attention: This regex has to hold even if the code is minified!
	 */
	var DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*arguments\)/;
	var ReflectionCapabilities = (function () {
	    /**
	     * @param {?=} reflect
	     */
	    function ReflectionCapabilities(reflect) {
	        this._reflect = reflect || _global['Reflect'];
	    }
	    /**
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	    /**
	     * @template T
	     * @param {?} t
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.factory = function (t) { return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return new (t.bind.apply(t, [void 0].concat(args)))();
	    }; };
	    /**
	     * \@internal
	     * @param {?} paramTypes
	     * @param {?} paramAnnotations
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
	        var /** @type {?} */ result;
	        if (typeof paramTypes === 'undefined') {
	            result = new Array(paramAnnotations.length);
	        }
	        else {
	            result = new Array(paramTypes.length);
	        }
	        for (var /** @type {?} */ i = 0; i < result.length; i++) {
	            // TS outputs Object for parameters without types, while Traceur omits
	            // the annotations. For now we preserve the Traceur behavior to aid
	            // migration, but this can be revisited.
	            if (typeof paramTypes === 'undefined') {
	                result[i] = [];
	            }
	            else if (paramTypes[i] != Object) {
	                result[i] = [paramTypes[i]];
	            }
	            else {
	                result[i] = [];
	            }
	            if (paramAnnotations && paramAnnotations[i] != null) {
	                result[i] = result[i].concat(paramAnnotations[i]);
	            }
	        }
	        return result;
	    };
	    /**
	     * @param {?} type
	     * @param {?} parentCtor
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {
	        // If we have no decorators, we only have function.length as metadata.
	        // In that case, to detect whether a child class declared an own constructor or not,
	        // we need to look inside of that constructor to check whether it is
	        // just calling the parent.
	        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
	        // that sets 'design:paramtypes' to []
	        // if a class inherits from another class but has no ctor declared itself.
	        if (DELEGATE_CTOR.exec(type.toString())) {
	            return null;
	        }
	        // Prefer the direct API.
	        if (((type)).parameters && ((type)).parameters !== parentCtor.parameters) {
	            return ((type)).parameters;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        var /** @type {?} */ tsickleCtorParams = ((type)).ctorParameters;
	        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
	            // Newer tsickle uses a function closure
	            // Retain the non-function case for compatibility with older tsickle
	            var /** @type {?} */ ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
	            var /** @type {?} */ paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
	            var /** @type {?} */ paramAnnotations = ctorParameters.map(function (ctorParam) { return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators); });
	            return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	        }
	        // API for metadata created by invoking the decorators.
	        if (this._reflect != null && this._reflect.getOwnMetadata != null) {
	            var /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);
	            var /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);
	            if (paramTypes || paramAnnotations) {
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	        }
	        // If a class has no decorators, at least create metadata
	        // based on function.length.
	        // Note: We know that this is a real constructor as we checked
	        // the content of the constructor above.
	        return new Array(((type.length))).fill(undefined);
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.parameters = function (type) {
	        // Note: only report metadata if we have at least one class decorator
	        // to stay in sync with the static reflector.
	        if (!isType(type)) {
	            return [];
	        }
	        var /** @type {?} */ parentCtor = getParentCtor(type);
	        var /** @type {?} */ parameters = this._ownParameters(type, parentCtor);
	        if (!parameters && parentCtor !== Object) {
	            parameters = this.parameters(parentCtor);
	        }
	        return parameters || [];
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} parentCtor
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {
	        // Prefer the direct API.
	        if (((typeOrFunc)).annotations && ((typeOrFunc)).annotations !== parentCtor.annotations) {
	            var /** @type {?} */ annotations = ((typeOrFunc)).annotations;
	            if (typeof annotations === 'function' && annotations.annotations) {
	                annotations = annotations.annotations;
	            }
	            return annotations;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (((typeOrFunc)).decorators && ((typeOrFunc)).decorators !== parentCtor.decorators) {
	            return convertTsickleDecoratorIntoMetadata(((typeOrFunc)).decorators);
	        }
	        // API for metadata created by invoking the decorators.
	        if (this._reflect && this._reflect.getOwnMetadata) {
	            return this._reflect.getOwnMetadata('annotations', typeOrFunc);
	        }
	        return null;
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	        if (!isType(typeOrFunc)) {
	            return [];
	        }
	        var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	        var /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
	        var /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
	        return parentAnnotations.concat(ownAnnotations);
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} parentCtor
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {
	        // Prefer the direct API.
	        if (((typeOrFunc)).propMetadata &&
	            ((typeOrFunc)).propMetadata !== parentCtor.propMetadata) {
	            var /** @type {?} */ propMetadata = ((typeOrFunc)).propMetadata;
	            if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
	                propMetadata = propMetadata.propMetadata;
	            }
	            return propMetadata;
	        }
	        // API of tsickle for lowering decorators to properties on the class.
	        if (((typeOrFunc)).propDecorators &&
	            ((typeOrFunc)).propDecorators !== parentCtor.propDecorators) {
	            var /** @type {?} */ propDecorators_1 = ((typeOrFunc)).propDecorators;
	            var /** @type {?} */ propMetadata_1 = ({});
	            Object.keys(propDecorators_1).forEach(function (prop) {
	                propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	            });
	            return propMetadata_1;
	        }
	        // API for metadata created by invoking the decorators.
	        if (this._reflect && this._reflect.getOwnMetadata) {
	            return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);
	        }
	        return null;
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	        if (!isType(typeOrFunc)) {
	            return {};
	        }
	        var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	        var /** @type {?} */ propMetadata = {};
	        if (parentCtor !== Object) {
	            var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentCtor);
	            Object.keys(parentPropMetadata_1).forEach(function (propName) {
	                propMetadata[propName] = parentPropMetadata_1[propName];
	            });
	        }
	        var /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
	        if (ownPropMetadata) {
	            Object.keys(ownPropMetadata).forEach(function (propName) {
	                var /** @type {?} */ decorators = [];
	                if (propMetadata.hasOwnProperty(propName)) {
	                    decorators.push.apply(decorators, propMetadata[propName]);
	                }
	                decorators.push.apply(decorators, ownPropMetadata[propName]);
	                propMetadata[propName] = decorators;
	            });
	        }
	        return propMetadata;
	    };
	    /**
	     * @param {?} type
	     * @param {?} lcProperty
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
	        return type instanceof Type && lcProperty in type.prototype;
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.getter = function (name) { return (new Function('o', 'return o.' + name + ';')); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.setter = function (name) {
	        return (new Function('o', 'v', 'return o.' + name + ' = v;'));
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.method = function (name) {
	        var /** @type {?} */ functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	        return (new Function('o', 'args', functionBody));
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.importUri = function (type) {
	        // StaticSymbol
	        if (typeof type === 'object' && type['filePath']) {
	            return type['filePath'];
	        }
	        // Runtime type
	        return "./" + stringify(type);
	    };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.resourceUri = function (type) { return "./" + stringify(type); };
	    /**
	     * @param {?} name
	     * @param {?} moduleUrl
	     * @param {?} members
	     * @param {?} runtime
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {
	        return runtime;
	    };
	    /**
	     * @param {?} enumIdentifier
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
	    return ReflectionCapabilities;
	}());
	/**
	 * @param {?} decoratorInvocations
	 * @return {?}
	 */
	function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	    if (!decoratorInvocations) {
	        return [];
	    }
	    return decoratorInvocations.map(function (decoratorInvocation) {
	        var /** @type {?} */ decoratorType = decoratorInvocation.type;
	        var /** @type {?} */ annotationCls = decoratorType.annotationCls;
	        var /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	        return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
	    });
	}
	/**
	 * @param {?} ctor
	 * @return {?}
	 */
	function getParentCtor(ctor) {
	    var /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);
	    var /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;
	    // Note: We always use `Object` as the null value
	    // to simplify checking later on.
	    return parentCtor || Object;
	}
	/**
	 * Provides read-only access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 * @abstract
	 */
	var ReflectorReader = (function () {
	    function ReflectorReader() {
	    }
	    /**
	     * @abstract
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectorReader.prototype.parameters = function (typeOrFunc) { };
	    /**
	     * @abstract
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectorReader.prototype.annotations = function (typeOrFunc) { };
	    /**
	     * @abstract
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectorReader.prototype.propMetadata = function (typeOrFunc) { };
	    /**
	     * @abstract
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectorReader.prototype.importUri = function (typeOrFunc) { };
	    /**
	     * @abstract
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    ReflectorReader.prototype.resourceUri = function (typeOrFunc) { };
	    /**
	     * @abstract
	     * @param {?} name
	     * @param {?} moduleUrl
	     * @param {?} members
	     * @param {?} runtime
	     * @return {?}
	     */
	    ReflectorReader.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) { };
	    /**
	     * @abstract
	     * @param {?} identifier
	     * @param {?} name
	     * @return {?}
	     */
	    ReflectorReader.prototype.resolveEnum = function (identifier, name) { };
	    return ReflectorReader;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Provides access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var Reflector = (function (_super) {
	    __extends(Reflector, _super);
	    /**
	     * @param {?} reflectionCapabilities
	     */
	    function Reflector(reflectionCapabilities) {
	        var _this = _super.call(this) || this;
	        _this.reflectionCapabilities = reflectionCapabilities;
	        return _this;
	    }
	    /**
	     * @param {?} caps
	     * @return {?}
	     */
	    Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    Reflector.prototype.parameters = function (typeOrFunc) {
	        return this.reflectionCapabilities.parameters(typeOrFunc);
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    Reflector.prototype.annotations = function (typeOrFunc) {
	        return this.reflectionCapabilities.annotations(typeOrFunc);
	    };
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    Reflector.prototype.propMetadata = function (typeOrFunc) {
	        return this.reflectionCapabilities.propMetadata(typeOrFunc);
	    };
	    /**
	     * @param {?} type
	     * @param {?} lcProperty
	     * @return {?}
	     */
	    Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
	        return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
	    };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    Reflector.prototype.resourceUri = function (type) { return this.reflectionCapabilities.resourceUri(type); };
	    /**
	     * @param {?} name
	     * @param {?} moduleUrl
	     * @param {?} members
	     * @param {?} runtime
	     * @return {?}
	     */
	    Reflector.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {
	        return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
	    };
	    /**
	     * @param {?} identifier
	     * @param {?} name
	     * @return {?}
	     */
	    Reflector.prototype.resolveEnum = function (identifier, name) {
	        return this.reflectionCapabilities.resolveEnum(identifier, name);
	    };
	    return Reflector;
	}(ReflectorReader));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * The {@link Reflector} used internally in Angular to access metadata
	 * about symbols.
	 */
	var reflector = new Reflector(new ReflectionCapabilities());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * `Dependency` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 */
	var ReflectiveDependency = (function () {
	    /**
	     * @param {?} key
	     * @param {?} optional
	     * @param {?} visibility
	     */
	    function ReflectiveDependency(key, optional, visibility) {
	        this.key = key;
	        this.optional = optional;
	        this.visibility = visibility;
	    }
	    /**
	     * @param {?} key
	     * @return {?}
	     */
	    ReflectiveDependency.fromKey = function (key) {
	        return new ReflectiveDependency(key, false, null);
	    };
	    return ReflectiveDependency;
	}());
	var _EMPTY_LIST = [];
	var ResolvedReflectiveProvider_ = (function () {
	    /**
	     * @param {?} key
	     * @param {?} resolvedFactories
	     * @param {?} multiProvider
	     */
	    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	        this.key = key;
	        this.resolvedFactories = resolvedFactories;
	        this.multiProvider = multiProvider;
	    }
	    Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.resolvedFactories[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    return ResolvedReflectiveProvider_;
	}());
	/**
	 * An internal resolved representation of a factory function created by resolving {\@link
	 * Provider}.
	 * \@experimental
	 */
	var ResolvedReflectiveFactory = (function () {
	    /**
	     * @param {?} factory
	     * @param {?} dependencies
	     */
	    function ResolvedReflectiveFactory(factory, dependencies) {
	        this.factory = factory;
	        this.dependencies = dependencies;
	    }
	    return ResolvedReflectiveFactory;
	}());
	/**
	 * Resolve a single provider.
	 * @param {?} provider
	 * @return {?}
	 */
	function resolveReflectiveFactory(provider) {
	    var /** @type {?} */ factoryFn;
	    var /** @type {?} */ resolvedDeps;
	    if (provider.useClass) {
	        var /** @type {?} */ useClass = resolveForwardRef(provider.useClass);
	        factoryFn = reflector.factory(useClass);
	        resolvedDeps = _dependenciesFor(useClass);
	    }
	    else if (provider.useExisting) {
	        factoryFn = function (aliasInstance) { return aliasInstance; };
	        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
	    }
	    else if (provider.useFactory) {
	        factoryFn = provider.useFactory;
	        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
	    }
	    else {
	        factoryFn = function () { return provider.useValue; };
	        resolvedDeps = _EMPTY_LIST;
	    }
	    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	}
	/**
	 * Converts the {\@link Provider} into {\@link ResolvedProvider}.
	 *
	 * {\@link Injector} internally only uses {\@link ResolvedProvider}, {\@link Provider} contains
	 * convenience provider syntax.
	 * @param {?} provider
	 * @return {?}
	 */
	function resolveReflectiveProvider(provider) {
	    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
	}
	/**
	 * Resolve a list of Providers.
	 * @param {?} providers
	 * @return {?}
	 */
	function resolveReflectiveProviders(providers) {
	    var /** @type {?} */ normalized = _normalizeProviders(providers, []);
	    var /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);
	    var /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
	    return Array.from(resolvedProviderMap.values());
	}
	/**
	 * Merges a list of ResolvedProviders into a list where
	 * each key is contained exactly once and multi providers
	 * have been merged.
	 * @param {?} providers
	 * @param {?} normalizedProvidersMap
	 * @return {?}
	 */
	function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	    for (var /** @type {?} */ i = 0; i < providers.length; i++) {
	        var /** @type {?} */ provider = providers[i];
	        var /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);
	        if (existing) {
	            if (provider.multiProvider !== existing.multiProvider) {
	                throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
	            }
	            if (provider.multiProvider) {
	                for (var /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {
	                    existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                }
	            }
	            else {
	                normalizedProvidersMap.set(provider.key.id, provider);
	            }
	        }
	        else {
	            var /** @type {?} */ resolvedProvider = void 0;
	            if (provider.multiProvider) {
	                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
	            }
	            else {
	                resolvedProvider = provider;
	            }
	            normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	        }
	    }
	    return normalizedProvidersMap;
	}
	/**
	 * @param {?} providers
	 * @param {?} res
	 * @return {?}
	 */
	function _normalizeProviders(providers, res) {
	    providers.forEach(function (b) {
	        if (b instanceof Type) {
	            res.push({ provide: b, useClass: b });
	        }
	        else if (b && typeof b == 'object' && ((b)).provide !== undefined) {
	            res.push(/** @type {?} */ (b));
	        }
	        else if (b instanceof Array) {
	            _normalizeProviders(b, res);
	        }
	        else {
	            throw invalidProviderError(b);
	        }
	    });
	    return res;
	}
	/**
	 * @param {?} typeOrFunc
	 * @param {?=} dependencies
	 * @return {?}
	 */
	function constructDependencies(typeOrFunc, dependencies) {
	    if (!dependencies) {
	        return _dependenciesFor(typeOrFunc);
	    }
	    else {
	        var /** @type {?} */ params_1 = dependencies.map(function (t) { return [t]; });
	        return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });
	    }
	}
	/**
	 * @param {?} typeOrFunc
	 * @return {?}
	 */
	function _dependenciesFor(typeOrFunc) {
	    var /** @type {?} */ params = reflector.parameters(typeOrFunc);
	    if (!params)
	        return [];
	    if (params.some(function (p) { return p == null; })) {
	        throw noAnnotationError(typeOrFunc, params);
	    }
	    return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	}
	/**
	 * @param {?} typeOrFunc
	 * @param {?} metadata
	 * @param {?} params
	 * @return {?}
	 */
	function _extractToken(typeOrFunc, metadata, params) {
	    var /** @type {?} */ token = null;
	    var /** @type {?} */ optional = false;
	    if (!Array.isArray(metadata)) {
	        if (metadata instanceof Inject) {
	            return _createDependency(metadata['token'], optional, null);
	        }
	        else {
	            return _createDependency(metadata, optional, null);
	        }
	    }
	    var /** @type {?} */ visibility = null;
	    for (var /** @type {?} */ i = 0; i < metadata.length; ++i) {
	        var /** @type {?} */ paramMetadata = metadata[i];
	        if (paramMetadata instanceof Type) {
	            token = paramMetadata;
	        }
	        else if (paramMetadata instanceof Inject) {
	            token = paramMetadata['token'];
	        }
	        else if (paramMetadata instanceof Optional) {
	            optional = true;
	        }
	        else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
	            visibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof InjectionToken) {
	            token = paramMetadata;
	        }
	    }
	    token = resolveForwardRef(token);
	    if (token != null) {
	        return _createDependency(token, optional, visibility);
	    }
	    else {
	        throw noAnnotationError(typeOrFunc, params);
	    }
	}
	/**
	 * @param {?} token
	 * @param {?} optional
	 * @param {?} visibility
	 * @return {?}
	 */
	function _createDependency(token, optional, visibility) {
	    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Threshold for the dynamic version
	var UNDEFINED = new Object();
	/**
	 * A ReflectiveDependency injection container used for instantiating objects and resolving
	 * dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 *
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	 *
	 * The following example creates an `Injector` configured to create `Engine` and `Car`.
	 *
	 * ```typescript
	 * \@Injectable()
	 * class Engine {
	 * }
	 *
	 * \@Injectable()
	 * class Car {
	 *   constructor(public engine:Engine) {}
	 * }
	 *
	 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	 * var car = injector.get(Car);
	 * expect(car instanceof Car).toBe(true);
	 * expect(car.engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 *
	 * \@stable
	 * @abstract
	 */
	var ReflectiveInjector = (function () {
	    function ReflectiveInjector() {
	    }
	    /**
	     * Turns an array of provider definitions into an array of resolved providers.
	     *
	     * A resolution is a process of flattening multiple nested arrays and converting individual
	     * providers into an array of {\@link ResolvedReflectiveProvider}s.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	     *
	     * expect(providers.length).toEqual(2);
	     *
	     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	     * expect(providers[0].key.displayName).toBe("Car");
	     * expect(providers[0].dependencies.length).toEqual(1);
	     * expect(providers[0].factory).toBeDefined();
	     *
	     * expect(providers[1].key.displayName).toBe("Engine");
	     * });
	     * ```
	     *
	     * See {\@link ReflectiveInjector#fromResolvedProviders} for more info.
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector.resolve = function (providers) {
	        return resolveReflectiveProviders(providers);
	    };
	    /**
	     * Resolves an array of providers and creates an injector from those providers.
	     *
	     * The passed-in providers can be an array of `Type`, {\@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     *
	     * This function is slower than the corresponding `fromResolvedProviders`
	     * because it needs to resolve the passed-in providers first.
	     * See {\@link Injector#resolve} and {\@link Injector#fromResolvedProviders}.
	     * @param {?} providers
	     * @param {?=} parent
	     * @return {?}
	     */
	    ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	        var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	    };
	    /**
	     * Creates an injector from previously resolved providers.
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var providers = ReflectiveInjector.resolve([Car, Engine]);
	     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	     * expect(injector.get(Car) instanceof Car).toBe(true);
	     * ```
	     * \@experimental
	     * @param {?} providers
	     * @param {?=} parent
	     * @return {?}
	     */
	    ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	        return new ReflectiveInjector_(providers, parent);
	    };
	    /**
	     * Parent of this injector.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	     *
	     * ```typescript
	     * var parent = ReflectiveInjector.resolveAndCreate([]);
	     * var child = parent.resolveAndCreateChild([]);
	     * expect(child.parent).toBe(parent);
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.parent = function () { };
	    /**
	     * Resolves an array of providers and creates a child injector from those providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * The passed-in providers can be an array of `Type`, {\@link Provider},
	     * or a recursive array of more providers.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	     * var child = parent.resolveAndCreateChild([ChildProvider]);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     *
	     * This function is slower than the corresponding `createChildFromResolved`
	     * because it needs to resolve the passed-in providers first.
	     * See {\@link Injector#resolve} and {\@link Injector#createChildFromResolved}.
	     * @abstract
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { };
	    /**
	     * Creates a child injector from previously resolved providers.
	     *
	     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	     * -->
	     *
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	     *
	     * ```typescript
	     * class ParentProvider {}
	     * class ChildProvider {}
	     *
	     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	     *
	     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	     * var child = parent.createChildFromResolved(childProviders);
	     *
	     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	     * ```
	     * @abstract
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.createChildFromResolved = function (providers) { };
	    /**
	     * Resolves a provider and instantiates an object in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     *
	     * var car = injector.resolveAndInstantiate(Car);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	     * ```
	     * @abstract
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { };
	    /**
	     * Instantiates an object using a resolved provider in the context of the injector.
	     *
	     * The created object does not get cached by the injector.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	     * var carProvider = ReflectiveInjector.resolve([Car])[0];
	     * var car = injector.instantiateResolved(carProvider);
	     * expect(car.engine).toBe(injector.get(Engine));
	     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	     * ```
	     * @abstract
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.instantiateResolved = function (provider) { };
	    /**
	     * @abstract
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector.prototype.get = function (token, notFoundValue) { };
	    return ReflectiveInjector;
	}());
	var ReflectiveInjector_ = (function () {
	    /**
	     * Private
	     * @param {?} _providers
	     * @param {?=} _parent
	     */
	    function ReflectiveInjector_(_providers, _parent) {
	        /**
	         * \@internal
	         */
	        this._constructionCounter = 0;
	        this._providers = _providers;
	        this._parent = _parent || null;
	        var len = _providers.length;
	        this.keyIds = new Array(len);
	        this.objs = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.keyIds[i] = _providers[i].key.id;
	            this.objs[i] = UNDEFINED;
	        }
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
	    };
	    Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._parent; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	        var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	        return this.createChildFromResolved(ResolvedReflectiveProviders);
	    };
	    /**
	     * @param {?} providers
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	        var /** @type {?} */ inj = new ReflectiveInjector_(providers);
	        inj._parent = this;
	        return inj;
	    };
	    /**
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	    };
	    /**
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	        return this._instantiateProvider(provider);
	    };
	    /**
	     * @param {?} index
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.getProviderAtIndex = function (index) {
	        if (index < 0 || index >= this._providers.length) {
	            throw outOfBoundsError(index);
	        }
	        return this._providers[index];
	    };
	    /**
	     * \@internal
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._new = function (provider) {
	        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
	            throw cyclicDependencyError(this, provider.key);
	        }
	        return this._instantiateProvider(provider);
	    };
	    /**
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getMaxNumberOfObjects = function () { return this.objs.length; };
	    /**
	     * @param {?} provider
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	        if (provider.multiProvider) {
	            var /** @type {?} */ res = new Array(provider.resolvedFactories.length);
	            for (var /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {
	                res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	            }
	            return res;
	        }
	        else {
	            return this._instantiate(provider, provider.resolvedFactories[0]);
	        }
	    };
	    /**
	     * @param {?} provider
	     * @param {?} ResolvedReflectiveFactory
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory$$1) {
	        var _this = this;
	        var /** @type {?} */ factory = ResolvedReflectiveFactory$$1.factory;
	        var /** @type {?} */ deps;
	        try {
	            deps =
	                ResolvedReflectiveFactory$$1.dependencies.map(function (dep) { return _this._getByReflectiveDependency(dep); });
	        }
	        catch (e) {
	            if (e.addKey) {
	                e.addKey(this, provider.key);
	            }
	            throw e;
	        }
	        var /** @type {?} */ obj;
	        try {
	            obj = factory.apply(void 0, deps);
	        }
	        catch (e) {
	            throw instantiationError(this, e, e.stack, provider.key);
	        }
	        return obj;
	    };
	    /**
	     * @param {?} dep
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByReflectiveDependency = function (dep) {
	        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
	    };
	    /**
	     * @param {?} key
	     * @param {?} visibility
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByKey = function (key, visibility, notFoundValue) {
	        if (key === INJECTOR_KEY) {
	            return this;
	        }
	        if (visibility instanceof Self) {
	            return this._getByKeySelf(key, notFoundValue);
	        }
	        else {
	            return this._getByKeyDefault(key, notFoundValue, visibility);
	        }
	    };
	    /**
	     * @param {?} keyId
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getObjByKeyId = function (keyId) {
	        for (var /** @type {?} */ i = 0; i < this.keyIds.length; i++) {
	            if (this.keyIds[i] === keyId) {
	                if (this.objs[i] === UNDEFINED) {
	                    this.objs[i] = this._new(this._providers[i]);
	                }
	                return this.objs[i];
	            }
	        }
	        return UNDEFINED;
	    };
	    /**
	     * \@internal
	     * @param {?} key
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	        if (notFoundValue !== THROW_IF_NOT_FOUND) {
	            return notFoundValue;
	        }
	        else {
	            throw noProviderError(this, key);
	        }
	    };
	    /**
	     * \@internal
	     * @param {?} key
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	        var /** @type {?} */ obj = this._getObjByKeyId(key.id);
	        return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	    };
	    /**
	     * \@internal
	     * @param {?} key
	     * @param {?} notFoundValue
	     * @param {?} visibility
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, visibility) {
	        var /** @type {?} */ inj;
	        if (visibility instanceof SkipSelf) {
	            inj = this._parent;
	        }
	        else {
	            inj = this;
	        }
	        while (inj instanceof ReflectiveInjector_) {
	            var /** @type {?} */ inj_ = (inj);
	            var /** @type {?} */ obj = inj_._getObjByKeyId(key.id);
	            if (obj !== UNDEFINED)
	                return obj;
	            inj = inj_._parent;
	        }
	        if (inj !== null) {
	            return inj.get(key.token, notFoundValue);
	        }
	        else {
	            return this._throwOrNull(key, notFoundValue);
	        }
	    };
	    Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                .join(', ');
	            return "ReflectiveInjector(providers: [" + providers + "])";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	    return ReflectiveInjector_;
	}());
	var INJECTOR_KEY = ReflectiveKey.get(Injector);
	/**
	 * @param {?} injector
	 * @param {?} fn
	 * @return {?}
	 */
	function _mapProviders(injector, fn) {
	    var /** @type {?} */ res = new Array(injector._providers.length);
	    for (var /** @type {?} */ i = 0; i < injector._providers.length; ++i) {
	        res[i] = fn(injector.getProviderAtIndex(i));
	    }
	    return res;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * The `di` module provides dependency injection container services.
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Determine if the argument is shaped like a Promise
	 * @param {?} obj
	 * @return {?}
	 */
	function isPromise(obj) {
	    // allow any Promise/A+ compliant thenable.
	    // It's up to the caller to ensure that obj.then conforms to the spec
	    return !!obj && typeof obj.then === 'function';
	}
	/**
	 * Determine if the argument is an Observable
	 * @param {?} obj
	 * @return {?}
	 */
	function isObservable(obj) {
	    // TODO use Symbol.observable when https://github.com/ReactiveX/rxjs/issues/2415 will be resolved
	    return !!obj && typeof obj.subscribe === 'function';
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A function that will be executed when an application is initialized.
	 * \@experimental
	 */
	var APP_INITIALIZER = new InjectionToken('Application Initializer');
	/**
	 * A class that reflects the state of running {\@link APP_INITIALIZER}s.
	 *
	 * \@experimental
	 */
	var ApplicationInitStatus = (function () {
	    /**
	     * @param {?} appInits
	     */
	    function ApplicationInitStatus(appInits) {
	        var _this = this;
	        this._done = false;
	        var asyncInitPromises = [];
	        if (appInits) {
	            for (var i = 0; i < appInits.length; i++) {
	                var initResult = appInits[i]();
	                if (isPromise(initResult)) {
	                    asyncInitPromises.push(initResult);
	                }
	            }
	        }
	        this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
	        if (asyncInitPromises.length === 0) {
	            this._done = true;
	        }
	    }
	    Object.defineProperty(ApplicationInitStatus.prototype, "done", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._done; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._donePromise; },
	        enumerable: true,
	        configurable: true
	    });
	    return ApplicationInitStatus;
	}());
	ApplicationInitStatus.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	ApplicationInitStatus.ctorParameters = function () { return [
	    { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A DI Token representing a unique string id assigned to the application by Angular and used
	 * primarily for prefixing application attributes and CSS styles when
	 * {\@link ViewEncapsulation#Emulated} is being used.
	 *
	 * If you need to avoid randomly generated value to be used as an application id, you can provide
	 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {\@link Injector}
	 * using this token.
	 * \@experimental
	 */
	var APP_ID = new InjectionToken('AppId');
	/**
	 * @return {?}
	 */
	function _appIdRandomProviderFactory() {
	    return "" + _randomChar() + _randomChar() + _randomChar();
	}
	/**
	 * Providers that will generate a random APP_ID_TOKEN.
	 * \@experimental
	 */
	var APP_ID_RANDOM_PROVIDER = {
	    provide: APP_ID,
	    useFactory: _appIdRandomProviderFactory,
	    deps: [],
	};
	/**
	 * @return {?}
	 */
	function _randomChar() {
	    return String.fromCharCode(97 + Math.floor(Math.random() * 25));
	}
	/**
	 * A function that will be executed when a platform is initialized.
	 * \@experimental
	 */
	var PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
	/**
	 * A token that indicates an opaque platform id.
	 * \@experimental
	 */
	var PLATFORM_ID = new InjectionToken('Platform ID');
	/**
	 * All callbacks provided via this token will be called for every component that is bootstrapped.
	 * Signature of the callback:
	 *
	 * `(componentRef: ComponentRef) => void`.
	 *
	 * \@experimental
	 */
	var APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
	/**
	 * A token which indicates the root directory of the application
	 * \@experimental
	 */
	var PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var Console = (function () {
	    function Console() {
	    }
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    Console.prototype.log = function (message) {
	        // tslint:disable-next-line:no-console
	        console.log(message);
	    };
	    /**
	     * @param {?} message
	     * @return {?}
	     */
	    Console.prototype.warn = function (message) {
	        // tslint:disable-next-line:no-console
	        console.warn(message);
	    };
	    return Console;
	}());
	Console.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	Console.ctorParameters = function () { return []; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Combination of NgModuleFactory and ComponentFactorys.
	 *
	 * \@experimental
	 */
	var ModuleWithComponentFactories = (function () {
	    /**
	     * @param {?} ngModuleFactory
	     * @param {?} componentFactories
	     */
	    function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
	        this.ngModuleFactory = ngModuleFactory;
	        this.componentFactories = componentFactories;
	    }
	    return ModuleWithComponentFactories;
	}());
	/**
	 * @return {?}
	 */
	function _throwError() {
	    throw new Error("Runtime compiler is not loaded");
	}
	/**
	 * Low-level service for running the angular compiler during runtime
	 * to create {\@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 *
	 * Each `\@NgModule` provides an own `Compiler` to its injector,
	 * that will use the directives/pipes of the ng module for compilation
	 * of components.
	 * \@stable
	 */
	var Compiler = (function () {
	    function Compiler() {
	    }
	    /**
	     * Compiles the given NgModule and all of its components. All templates of the components listed
	     * in `entryComponents` have to be inlined.
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
	    /**
	     * Compiles the given NgModule and all of its components
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
	    /**
	     * Same as {\@link compileModuleSync} but also creates ComponentFactories for all components.
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Same as {\@link compileModuleAsync} but also creates ComponentFactories for all components.
	     * @template T
	     * @param {?} moduleType
	     * @return {?}
	     */
	    Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	        throw _throwError();
	    };
	    /**
	     * Exposes the CSS-style selectors that have been used in `ngContent` directives within
	     * the template of the given component.
	     * This is used by the `upgrade` library to compile the appropriate transclude content
	     * in the AngularJS wrapper component.
	     *
	     * @deprecated since v4. Use ComponentFactory.ngContentSelectors instead.
	     * @param {?} component
	     * @return {?}
	     */
	    Compiler.prototype.getNgContentSelectors = function (component) { throw _throwError(); };
	    /**
	     * Clears all caches.
	     * @return {?}
	     */
	    Compiler.prototype.clearCache = function () { };
	    /**
	     * Clears the cache for the given component/ngModule.
	     * @param {?} type
	     * @return {?}
	     */
	    Compiler.prototype.clearCacheFor = function (type) { };
	    return Compiler;
	}());
	Compiler.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	Compiler.ctorParameters = function () { return []; };
	/**
	 * Token to provide CompilerOptions in the platform injector.
	 *
	 * \@experimental
	 */
	var COMPILER_OPTIONS = new InjectionToken('compilerOptions');
	/**
	 * A factory for creating a Compiler
	 *
	 * \@experimental
	 * @abstract
	 */
	var CompilerFactory = (function () {
	    function CompilerFactory() {
	    }
	    /**
	     * @abstract
	     * @param {?=} options
	     * @return {?}
	     */
	    CompilerFactory.prototype.createCompiler = function (options) { };
	    return CompilerFactory;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents an instance of a Component created via a {\@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
	 * method.
	 * \@stable
	 * @abstract
	 */
	var ComponentRef = (function () {
	    function ComponentRef() {
	    }
	    /**
	     * Location of the Host Element of this Component Instance.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.location = function () { };
	    /**
	     * The injector on which the component instance exists.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.injector = function () { };
	    /**
	     * The instance of the Component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.instance = function () { };
	    /**
	     * The {\@link ViewRef} of the Host View of this Component instance.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.hostView = function () { };
	    /**
	     * The {\@link ChangeDetectorRef} of the Component instance.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.changeDetectorRef = function () { };
	    /**
	     * The component type.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.componentType = function () { };
	    /**
	     * Destroys the component instance and all of the data structures associated with it.
	     * @abstract
	     * @return {?}
	     */
	    ComponentRef.prototype.destroy = function () { };
	    /**
	     * Allows to register a callback that will be called when the component is destroyed.
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    ComponentRef.prototype.onDestroy = function (callback) { };
	    return ComponentRef;
	}());
	/**
	 * \@stable
	 * @abstract
	 */
	var ComponentFactory = (function () {
	    function ComponentFactory() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.selector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.componentType = function () { };
	    /**
	     * selector for all <ng-content> elements in the component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.ngContentSelectors = function () { };
	    /**
	     * the inputs of the component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.inputs = function () { };
	    /**
	     * the outputs of the component.
	     * @abstract
	     * @return {?}
	     */
	    ComponentFactory.prototype.outputs = function () { };
	    /**
	     * Creates a new component.
	     * @abstract
	     * @param {?} injector
	     * @param {?=} projectableNodes
	     * @param {?=} rootSelectorOrNode
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) { };
	    return ComponentFactory;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} component
	 * @return {?}
	 */
	function noComponentFactoryError(component) {
	    var /** @type {?} */ error = Error("No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
	    ((error))[ERROR_COMPONENT] = component;
	    return error;
	}
	var ERROR_COMPONENT = 'ngComponent';
	/**
	 * @param {?} error
	 * @return {?}
	 */
	var _NullComponentFactoryResolver = (function () {
	    function _NullComponentFactoryResolver() {
	    }
	    /**
	     * @template T
	     * @param {?} component
	     * @return {?}
	     */
	    _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        throw noComponentFactoryError(component);
	    };
	    return _NullComponentFactoryResolver;
	}());
	/**
	 * \@stable
	 * @abstract
	 */
	var ComponentFactoryResolver = (function () {
	    function ComponentFactoryResolver() {
	    }
	    /**
	     * @abstract
	     * @template T
	     * @param {?} component
	     * @return {?}
	     */
	    ComponentFactoryResolver.prototype.resolveComponentFactory = function (component) { };
	    return ComponentFactoryResolver;
	}());
	ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	var CodegenComponentFactoryResolver = (function () {
	    /**
	     * @param {?} factories
	     * @param {?} _parent
	     * @param {?} _ngModule
	     */
	    function CodegenComponentFactoryResolver(factories, _parent, _ngModule) {
	        this._parent = _parent;
	        this._ngModule = _ngModule;
	        this._factories = new Map();
	        for (var i = 0; i < factories.length; i++) {
	            var factory = factories[i];
	            this._factories.set(factory.componentType, factory);
	        }
	    }
	    /**
	     * @template T
	     * @param {?} component
	     * @return {?}
	     */
	    CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	        var /** @type {?} */ factory = this._factories.get(component) || this._parent.resolveComponentFactory(component);
	        return new ComponentFactoryBoundToModule(factory, this._ngModule);
	    };
	    return CodegenComponentFactoryResolver;
	}());
	var ComponentFactoryBoundToModule = (function (_super) {
	    __extends(ComponentFactoryBoundToModule, _super);
	    /**
	     * @param {?} factory
	     * @param {?} ngModule
	     */
	    function ComponentFactoryBoundToModule(factory, ngModule) {
	        var _this = _super.call(this) || this;
	        _this.factory = factory;
	        _this.ngModule = ngModule;
	        return _this;
	    }
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "selector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.selector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "componentType", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.componentType; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "ngContentSelectors", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.ngContentSelectors; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "inputs", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.inputs; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactoryBoundToModule.prototype, "outputs", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.factory.outputs; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} injector
	     * @param {?=} projectableNodes
	     * @param {?=} rootSelectorOrNode
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ComponentFactoryBoundToModule.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {
	        return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
	    };
	    return ComponentFactoryBoundToModule;
	}(ComponentFactory));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
	 *
	 * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	 * NgModule Instance.
	 *
	 * \@stable
	 * @abstract
	 */
	var NgModuleRef = (function () {
	    function NgModuleRef() {
	    }
	    /**
	     * The injector that contains all of the providers of the NgModule.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.injector = function () { };
	    /**
	     * The ComponentFactoryResolver to get hold of the ComponentFactories
	     * declared in the `entryComponents` property of the module.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.componentFactoryResolver = function () { };
	    /**
	     * The NgModule instance.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.instance = function () { };
	    /**
	     * Destroys the module instance and all of the data structures associated with it.
	     * @abstract
	     * @return {?}
	     */
	    NgModuleRef.prototype.destroy = function () { };
	    /**
	     * Allows to register a callback that will be called when the module is destroyed.
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    NgModuleRef.prototype.onDestroy = function (callback) { };
	    return NgModuleRef;
	}());
	/**
	 * \@experimental
	 */
	var NgModuleFactory = (function () {
	    /**
	     * @param {?} _injectorClass
	     * @param {?} _moduleType
	     */
	    function NgModuleFactory(_injectorClass, _moduleType) {
	        this._injectorClass = _injectorClass;
	        this._moduleType = _moduleType;
	    }
	    Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._moduleType; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} parentInjector
	     * @return {?}
	     */
	    NgModuleFactory.prototype.create = function (parentInjector) {
	        var /** @type {?} */ instance = new this._injectorClass(parentInjector || Injector.NULL);
	        instance.create();
	        return instance;
	    };
	    return NgModuleFactory;
	}());
	var _UNDEFINED = new Object();
	/**
	 * @abstract
	 */
	var NgModuleInjector = (function () {
	    /**
	     * @param {?} parent
	     * @param {?} factories
	     * @param {?} bootstrapFactories
	     */
	    function NgModuleInjector(parent, factories, bootstrapFactories) {
	        var _this = this;
	        this.parent = parent;
	        this._destroyListeners = [];
	        this._destroyed = false;
	        this.bootstrapFactories =
	            bootstrapFactories.map(function (f) { return new ComponentFactoryBoundToModule(f, _this); });
	        this._cmpFactoryResolver = new CodegenComponentFactoryResolver(factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL), this);
	    }
	    /**
	     * @return {?}
	     */
	    NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    NgModuleInjector.prototype.createInternal = function () { };
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    NgModuleInjector.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	        if (token === Injector || token === NgModuleRef) {
	            return this;
	        }
	        if (token === ComponentFactoryResolver) {
	            return this._cmpFactoryResolver;
	        }
	        var /** @type {?} */ result = this.getInternal(token, _UNDEFINED);
	        return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
	    };
	    /**
	     * @abstract
	     * @param {?} token
	     * @param {?} notFoundValue
	     * @return {?}
	     */
	    NgModuleInjector.prototype.getInternal = function (token, notFoundValue) { };
	    Object.defineProperty(NgModuleInjector.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._cmpFactoryResolver; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    NgModuleInjector.prototype.destroy = function () {
	        if (this._destroyed) {
	            throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
	        }
	        this._destroyed = true;
	        this.destroyInternal();
	        this._destroyListeners.forEach(function (listener) { return listener(); });
	    };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    NgModuleInjector.prototype.destroyInternal = function () { };
	    return NgModuleInjector;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var trace;
	var events;
	/**
	 * @return {?}
	 */
	function detectWTF() {
	    var /** @type {?} */ wtf = ((_global) /** TODO #9100 */)['wtf'];
	    if (wtf) {
	        trace = wtf['trace'];
	        if (trace) {
	            events = trace['events'];
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * @param {?} signature
	 * @param {?=} flags
	 * @return {?}
	 */
	function createScope$1(signature, flags) {
	    if (flags === void 0) { flags = null; }
	    return events.createScope(signature, flags);
	}
	/**
	 * @template T
	 * @param {?} scope
	 * @param {?=} returnValue
	 * @return {?}
	 */
	function leave(scope, returnValue) {
	    trace.leaveScope(scope, returnValue);
	    return returnValue;
	}
	/**
	 * @param {?} rangeType
	 * @param {?} action
	 * @return {?}
	 */
	function startTimeRange(rangeType, action) {
	    return trace.beginTimeRange(rangeType, action);
	}
	/**
	 * @param {?} range
	 * @return {?}
	 */
	function endTimeRange(range) {
	    trace.endTimeRange(range);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * True if WTF is enabled.
	 */
	var wtfEnabled = detectWTF();
	/**
	 * @param {?=} arg0
	 * @param {?=} arg1
	 * @return {?}
	 */
	function noopScope(arg0, arg1) {
	    return null;
	}
	/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 * \@experimental
	 */
	var wtfCreateScope = wtfEnabled ? createScope$1 : function (signature, flags) { return noopScope; };
	/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 * \@experimental
	 */
	var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
	/**
	 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	 * enabled.
	 *
	 *     someMethod() {
	 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	 *        var future = new Future.delay(5).then((_) {
	 *          wtfEndTimeRange(s);
	 *        });
	 *     }
	 * \@experimental
	 */
	var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
	/**
	 * Ends a async time range operation.
	 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	 * enabled.
	 * \@experimental
	 */
	var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * \@Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   \@Output() open: EventEmitter<any> = new EventEmitter();
	 *   \@Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * \@stable
	 */
	var EventEmitter = (function (_super) {
	    __extends(EventEmitter, _super);
	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     * @param {?=} isAsync
	     */
	    function EventEmitter(isAsync) {
	        if (isAsync === void 0) { isAsync = false; }
	        var _this = _super.call(this) || this;
	        _this.__isAsync = isAsync;
	        return _this;
	    }
	    /**
	     * @param {?=} value
	     * @return {?}
	     */
	    EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	    /**
	     * @param {?=} generatorOrNext
	     * @param {?=} error
	     * @param {?=} complete
	     * @return {?}
	     */
	    EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	        var /** @type {?} */ schedulerFn;
	        var /** @type {?} */ errorFn = function (err) { return null; };
	        var /** @type {?} */ completeFn = function () { return null; };
	        if (generatorOrNext && typeof generatorOrNext === 'object') {
	            schedulerFn = this.__isAsync ? function (value) {
	                setTimeout(function () { return generatorOrNext.next(value); });
	            } : function (value) { generatorOrNext.next(value); };
	            if (generatorOrNext.error) {
	                errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                    function (err) { generatorOrNext.error(err); };
	            }
	            if (generatorOrNext.complete) {
	                completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                    function () { generatorOrNext.complete(); };
	            }
	        }
	        else {
	            schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                function (value) { generatorOrNext(value); };
	            if (error) {
	                errorFn =
	                    this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	            }
	            if (complete) {
	                completeFn =
	                    this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	            }
	        }
	        return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	    };
	    return EventEmitter;
	}(rxjs_Subject.Subject));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {\@link runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {\@link run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * ### Example
	 *
	 * ```
	 * import {Component, NgZone} from '\@angular/core';
	 * import {NgIf} from '\@angular/common';
	 *
	 * \@Component({
	 *   selector: 'ng-zone-demo'.
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *       // reenter the Angular zone and display done
	 *       this._ngZone.run(() => {console.log('Outside Done!') });
	 *     }}));
	 *   }
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * \@experimental
	 */
	var NgZone = (function () {
	    /**
	     * @param {?} __0
	     */
	    function NgZone(_a) {
	        var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	        this._hasPendingMicrotasks = false;
	        this._hasPendingMacrotasks = false;
	        this._isStable = true;
	        this._nesting = 0;
	        this._onUnstable = new EventEmitter(false);
	        this._onMicrotaskEmpty = new EventEmitter(false);
	        this._onStable = new EventEmitter(false);
	        this._onErrorEvents = new EventEmitter(false);
	        if (typeof Zone == 'undefined') {
	            throw new Error('Angular requires Zone.js prolyfill.');
	        }
	        Zone.assertZonePatched();
	        this.outer = this.inner = Zone.current;
	        if (Zone['wtfZoneSpec']) {
	            this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	        }
	        if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
	            this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	        }
	        this.forkInnerZoneWithAngularBehavior();
	    }
	    /**
	     * @return {?}
	     */
	    NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	    /**
	     * @return {?}
	     */
	    NgZone.assertInAngularZone = function () {
	        if (!NgZone.isInAngularZone()) {
	            throw new Error('Expected to be in Angular Zone, but it is not!');
	        }
	    };
	    /**
	     * @return {?}
	     */
	    NgZone.assertNotInAngularZone = function () {
	        if (NgZone.isInAngularZone()) {
	            throw new Error('Expected to not be in Angular Zone, but it is!');
	        }
	    };
	    /**
	     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	     * outside of the Angular zone (typically started via {\@link runOutsideAngular}).
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * within the Angular zone.
	     *
	     * If a synchronous error happens it will be rethrown and not reported via `onError`.
	     * @param {?} fn
	     * @return {?}
	     */
	    NgZone.prototype.run = function (fn) { return this.inner.run(fn); };
	    /**
	     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
	     * rethrown.
	     * @param {?} fn
	     * @return {?}
	     */
	    NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };
	    /**
	     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	     * the function.
	     *
	     * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	     *
	     * Any future tasks or microtasks scheduled from within this function will continue executing from
	     * outside of the Angular zone.
	     *
	     * Use {\@link run} to reenter the Angular zone and do work that updates the application model.
	     * @param {?} fn
	     * @return {?}
	     */
	    NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };
	    Object.defineProperty(NgZone.prototype, "onUnstable", {
	        /**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         * @return {?}
	         */
	        get: function () { return this._onUnstable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
	        /**
	         * Notifies when there is no more microtasks enqueue in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         * @return {?}
	         */
	        get: function () { return this._onMicrotaskEmpty; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onStable", {
	        /**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         * @return {?}
	         */
	        get: function () { return this._onStable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "onError", {
	        /**
	         * Notify that an error has been delivered.
	         * @return {?}
	         */
	        get: function () { return this._onErrorEvents; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "isStable", {
	        /**
	         * Whether there are no outstanding microtasks or macrotasks.
	         * @return {?}
	         */
	        get: function () { return this._isStable; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._hasPendingMicrotasks; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._hasPendingMacrotasks; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    NgZone.prototype.checkStable = function () {
	        var _this = this;
	        if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {
	            try {
	                this._nesting++;
	                this._onMicrotaskEmpty.emit(null);
	            }
	            finally {
	                this._nesting--;
	                if (!this._hasPendingMicrotasks) {
	                    try {
	                        this.runOutsideAngular(function () { return _this._onStable.emit(null); });
	                    }
	                    finally {
	                        this._isStable = true;
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * @return {?}
	     */
	    NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {
	        var _this = this;
	        this.inner = this.inner.fork({
	            name: 'angular',
	            properties: /** @type {?} */ ({ 'isAngularZone': true }),
	            onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	                try {
	                    _this.onEnter();
	                    return delegate.invokeTask(target, task, applyThis, applyArgs);
	                }
	                finally {
	                    _this.onLeave();
	                }
	            },
	            onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	                try {
	                    _this.onEnter();
	                    return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                }
	                finally {
	                    _this.onLeave();
	                }
	            },
	            onHasTask: function (delegate, current, target, hasTaskState) {
	                delegate.hasTask(target, hasTaskState);
	                if (current === target) {
	                    // We are only interested in hasTask events which originate from our zone
	                    // (A child hasTask event is not interesting to us)
	                    if (hasTaskState.change == 'microTask') {
	                        _this.setHasMicrotask(hasTaskState.microTask);
	                    }
	                    else if (hasTaskState.change == 'macroTask') {
	                        _this.setHasMacrotask(hasTaskState.macroTask);
	                    }
	                }
	            },
	            onHandleError: function (delegate, current, target, error) {
	                delegate.handleError(target, error);
	                _this.triggerError(error);
	                return false;
	            }
	        });
	    };
	    /**
	     * @return {?}
	     */
	    NgZone.prototype.onEnter = function () {
	        this._nesting++;
	        if (this._isStable) {
	            this._isStable = false;
	            this._onUnstable.emit(null);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    NgZone.prototype.onLeave = function () {
	        this._nesting--;
	        this.checkStable();
	    };
	    /**
	     * @param {?} hasMicrotasks
	     * @return {?}
	     */
	    NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
	        this._hasPendingMicrotasks = hasMicrotasks;
	        this.checkStable();
	    };
	    /**
	     * @param {?} hasMacrotasks
	     * @return {?}
	     */
	    NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
	    /**
	     * @param {?} error
	     * @return {?}
	     */
	    NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
	    return NgZone;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * The Testability service provides testing hooks that can be accessed from
	 * the browser and by services such as Protractor. Each bootstrapped Angular
	 * application on the page will have an instance of Testability.
	 * \@experimental
	 */
	var Testability = (function () {
	    /**
	     * @param {?} _ngZone
	     */
	    function Testability(_ngZone) {
	        this._ngZone = _ngZone;
	        /**
	         * \@internal
	         */
	        this._pendingCount = 0;
	        /**
	         * \@internal
	         */
	        this._isZoneStable = true;
	        /**
	         * Whether any work was done since the last 'whenStable' callback. This is
	         * useful to detect if this could have potentially destabilized another
	         * component while it is stabilizing.
	         * \@internal
	         */
	        this._didWork = false;
	        /**
	         * \@internal
	         */
	        this._callbacks = [];
	        this._watchAngularEvents();
	    }
	    /**
	     * \@internal
	     * @return {?}
	     */
	    Testability.prototype._watchAngularEvents = function () {
	        var _this = this;
	        this._ngZone.onUnstable.subscribe({
	            next: function () {
	                _this._didWork = true;
	                _this._isZoneStable = false;
	            }
	        });
	        this._ngZone.runOutsideAngular(function () {
	            _this._ngZone.onStable.subscribe({
	                next: function () {
	                    NgZone.assertNotInAngularZone();
	                    scheduleMicroTask(function () {
	                        _this._isZoneStable = true;
	                        _this._runCallbacksIfReady();
	                    });
	                }
	            });
	        });
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.increasePendingRequestCount = function () {
	        this._pendingCount += 1;
	        this._didWork = true;
	        return this._pendingCount;
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.decreasePendingRequestCount = function () {
	        this._pendingCount -= 1;
	        if (this._pendingCount < 0) {
	            throw new Error('pending async requests below zero');
	        }
	        this._runCallbacksIfReady();
	        return this._pendingCount;
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.isStable = function () {
	        return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	    };
	    /**
	     * \@internal
	     * @return {?}
	     */
	    Testability.prototype._runCallbacksIfReady = function () {
	        var _this = this;
	        if (this.isStable()) {
	            // Schedules the call backs in a new frame so that it is always async.
	            scheduleMicroTask(function () {
	                while (_this._callbacks.length !== 0) {
	                    (((_this._callbacks.pop())))(_this._didWork);
	                }
	                _this._didWork = false;
	            });
	        }
	        else {
	            // Not Ready
	            this._didWork = true;
	        }
	    };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    Testability.prototype.whenStable = function (callback) {
	        this._callbacks.push(callback);
	        this._runCallbacksIfReady();
	    };
	    /**
	     * @return {?}
	     */
	    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	    /**
	     * @deprecated use findProviders
	     * @param {?} using
	     * @param {?} provider
	     * @param {?} exactMatch
	     * @return {?}
	     */
	    Testability.prototype.findBindings = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    /**
	     * @param {?} using
	     * @param {?} provider
	     * @param {?} exactMatch
	     * @return {?}
	     */
	    Testability.prototype.findProviders = function (using, provider, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    return Testability;
	}());
	Testability.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	Testability.ctorParameters = function () { return [
	    { type: NgZone, },
	]; };
	/**
	 * A global registry of {\@link Testability} instances for specific elements.
	 * \@experimental
	 */
	var TestabilityRegistry = (function () {
	    function TestabilityRegistry() {
	        /**
	         * \@internal
	         */
	        this._applications = new Map();
	        _testabilityGetter.addToWindow(this);
	    }
	    /**
	     * @param {?} token
	     * @param {?} testability
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	        this._applications.set(token, testability);
	    };
	    /**
	     * @param {?} elem
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem) || null; };
	    /**
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };
	    /**
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };
	    /**
	     * @param {?} elem
	     * @param {?=} findInAncestors
	     * @return {?}
	     */
	    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	        if (findInAncestors === void 0) { findInAncestors = true; }
	        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	    };
	    return TestabilityRegistry;
	}());
	TestabilityRegistry.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	TestabilityRegistry.ctorParameters = function () { return []; };
	var _NoopGetTestability = (function () {
	    function _NoopGetTestability() {
	    }
	    /**
	     * @param {?} registry
	     * @return {?}
	     */
	    _NoopGetTestability.prototype.addToWindow = function (registry) { };
	    /**
	     * @param {?} registry
	     * @param {?} elem
	     * @param {?} findInAncestors
	     * @return {?}
	     */
	    _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	        return null;
	    };
	    return _NoopGetTestability;
	}());
	/**
	 * Set the {\@link GetTestability} implementation used by the Angular testing framework.
	 * \@experimental
	 * @param {?} getter
	 * @return {?}
	 */
	function setTestabilityGetter(getter) {
	    _testabilityGetter = getter;
	}
	var _testabilityGetter = new _NoopGetTestability();
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _devMode = true;
	var _runModeLocked = false;
	var _platform;
	var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
	/**
	 * Disable Angular's development mode, which turns off assertions and other
	 * checks within the framework.
	 *
	 * One important assertion this disables verifies that a change detection pass
	 * does not result in additional changes to any bindings (also known as
	 * unidirectional data flow).
	 *
	 * \@stable
	 * @return {?}
	 */
	function enableProdMode() {
	    if (_runModeLocked) {
	        throw new Error('Cannot enable prod mode after platform setup.');
	    }
	    _devMode = false;
	}
	/**
	 * Returns whether Angular is in development mode. After called once,
	 * the value is locked and won't change any more.
	 *
	 * By default, this is true, unless a user calls `enableProdMode` before calling this.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @return {?}
	 */
	function isDevMode() {
	    _runModeLocked = true;
	    return _devMode;
	}
	/**
	 * A token for third-party components that can register themselves with NgProbe.
	 *
	 * \@experimental
	 */
	var NgProbeToken = (function () {
	    /**
	     * @param {?} name
	     * @param {?} token
	     */
	    function NgProbeToken(name, token) {
	        this.name = name;
	        this.token = token;
	    }
	    return NgProbeToken;
	}());
	/**
	 * Creates a platform.
	 * Platforms have to be eagerly created via this function.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @param {?} injector
	 * @return {?}
	 */
	function createPlatform(injector) {
	    if (_platform && !_platform.destroyed &&
	        !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
	        throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
	    }
	    _platform = injector.get(PlatformRef);
	    var /** @type {?} */ inits = injector.get(PLATFORM_INITIALIZER, null);
	    if (inits)
	        inits.forEach(function (init) { return init(); });
	    return _platform;
	}
	/**
	 * Creates a factory for a platform
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @param {?} parentPlatformFactory
	 * @param {?} name
	 * @param {?=} providers
	 * @return {?}
	 */
	function createPlatformFactory(parentPlatformFactory, name, providers) {
	    if (providers === void 0) { providers = []; }
	    var /** @type {?} */ marker = new InjectionToken("Platform: " + name);
	    return function (extraProviders) {
	        if (extraProviders === void 0) { extraProviders = []; }
	        var /** @type {?} */ platform = getPlatform();
	        if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
	            if (parentPlatformFactory) {
	                parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
	            }
	            else {
	                createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
	            }
	        }
	        return assertPlatform(marker);
	    };
	}
	/**
	 * Checks that there currently is a platform which contains the given token as a provider.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @param {?} requiredToken
	 * @return {?}
	 */
	function assertPlatform(requiredToken) {
	    var /** @type {?} */ platform = getPlatform();
	    if (!platform) {
	        throw new Error('No platform exists!');
	    }
	    if (!platform.injector.get(requiredToken, null)) {
	        throw new Error('A platform with a different configuration has been created. Please destroy it first.');
	    }
	    return platform;
	}
	/**
	 * Destroy the existing platform.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @return {?}
	 */
	function destroyPlatform() {
	    if (_platform && !_platform.destroyed) {
	        _platform.destroy();
	    }
	}
	/**
	 * Returns the current platform.
	 *
	 * \@experimental APIs related to application bootstrap are currently under review.
	 * @return {?}
	 */
	function getPlatform() {
	    return _platform && !_platform.destroyed ? _platform : null;
	}
	/**
	 * The Angular platform is the entry point for Angular on a web page. Each page
	 * has exactly one platform, and services (such as reflection) which are common
	 * to every Angular application running on the page are bound in its scope.
	 *
	 * A page's platform is initialized implicitly when {\@link bootstrap}() is called, or
	 * explicitly by calling {\@link createPlatform}().
	 *
	 * \@stable
	 * @abstract
	 */
	var PlatformRef = (function () {
	    function PlatformRef() {
	    }
	    /**
	     * Creates an instance of an `\@NgModule` for the given platform
	     * for offline compilation.
	     *
	     * ## Simple Example
	     *
	     * ```typescript
	     * my_module.ts:
	     *
	     * \@NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * main.ts:
	     * import {MyModuleNgFactory} from './my_module.ngfactory';
	     * import {platformBrowser} from '\@angular/platform-browser';
	     *
	     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
	     * ```
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @abstract
	     * @template M
	     * @param {?} moduleFactory
	     * @return {?}
	     */
	    PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) { };
	    /**
	     * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
	     *
	     * ## Simple Example
	     *
	     * ```typescript
	     * \@NgModule({
	     *   imports: [BrowserModule]
	     * })
	     * class MyModule {}
	     *
	     * let moduleRef = platformBrowser().bootstrapModule(MyModule);
	     * ```
	     * \@stable
	     * @abstract
	     * @template M
	     * @param {?} moduleType
	     * @param {?=} compilerOptions
	     * @return {?}
	     */
	    PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) { };
	    /**
	     * Register a listener to be called when the platform is disposed.
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    PlatformRef.prototype.onDestroy = function (callback) { };
	    /**
	     * Retrieve the platform {\@link Injector}, which is the parent injector for
	     * every Angular application on the page and provides singleton providers.
	     * @abstract
	     * @return {?}
	     */
	    PlatformRef.prototype.injector = function () { };
	    /**
	     * Destroy the Angular platform and all Angular applications on the page.
	     * @abstract
	     * @return {?}
	     */
	    PlatformRef.prototype.destroy = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    PlatformRef.prototype.destroyed = function () { };
	    return PlatformRef;
	}());
	/**
	 * @param {?} errorHandler
	 * @param {?} callback
	 * @return {?}
	 */
	function _callAndReportToErrorHandler(errorHandler, callback) {
	    try {
	        var /** @type {?} */ result = callback();
	        if (isPromise(result)) {
	            return result.catch(function (e) {
	                errorHandler.handleError(e);
	                // rethrow as the exception handler might not do it
	                throw e;
	            });
	        }
	        return result;
	    }
	    catch (e) {
	        errorHandler.handleError(e);
	        // rethrow as the exception handler might not do it
	        throw e;
	    }
	}
	/**
	 * workaround https://github.com/angular/tsickle/issues/350
	 * @suppress {checkTypes}
	 */
	var PlatformRef_ = (function (_super) {
	    __extends(PlatformRef_, _super);
	    /**
	     * @param {?} _injector
	     */
	    function PlatformRef_(_injector) {
	        var _this = _super.call(this) || this;
	        _this._injector = _injector;
	        _this._modules = [];
	        _this._destroyListeners = [];
	        _this._destroyed = false;
	        return _this;
	    }
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	    Object.defineProperty(PlatformRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PlatformRef_.prototype, "destroyed", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._destroyed; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    PlatformRef_.prototype.destroy = function () {
	        if (this._destroyed) {
	            throw new Error('The platform has already been destroyed!');
	        }
	        this._modules.slice().forEach(function (module) { return module.destroy(); });
	        this._destroyListeners.forEach(function (listener) { return listener(); });
	        this._destroyed = true;
	    };
	    /**
	     * @template M
	     * @param {?} moduleFactory
	     * @return {?}
	     */
	    PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
	        return this._bootstrapModuleFactoryWithZone(moduleFactory);
	    };
	    /**
	     * @template M
	     * @param {?} moduleFactory
	     * @param {?=} ngZone
	     * @return {?}
	     */
	    PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
	        var _this = this;
	        // Note: We need to create the NgZone _before_ we instantiate the module,
	        // as instantiating the module creates some providers eagerly.
	        // So we create a mini parent injector that just contains the new NgZone and
	        // pass that as parent to the NgModuleFactory.
	        if (!ngZone)
	            ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
	        // Attention: Don't use ApplicationRef.run here,
	        // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	        return ngZone.run(function () {
	            var /** @type {?} */ ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
	            var /** @type {?} */ moduleRef = (moduleFactory.create(ngZoneInjector));
	            var /** @type {?} */ exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
	            if (!exceptionHandler) {
	                throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
	            }
	            moduleRef.onDestroy(function () { return remove(_this._modules, moduleRef); }); /** @type {?} */
	            ((ngZone)).onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
	            return _callAndReportToErrorHandler(exceptionHandler, function () {
	                var /** @type {?} */ initStatus = moduleRef.injector.get(ApplicationInitStatus);
	                return initStatus.donePromise.then(function () {
	                    _this._moduleDoBootstrap(moduleRef);
	                    return moduleRef;
	                });
	            });
	        });
	    };
	    /**
	     * @template M
	     * @param {?} moduleType
	     * @param {?=} compilerOptions
	     * @return {?}
	     */
	    PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        return this._bootstrapModuleWithZone(moduleType, compilerOptions);
	    };
	    /**
	     * @template M
	     * @param {?} moduleType
	     * @param {?=} compilerOptions
	     * @param {?=} ngZone
	     * @return {?}
	     */
	    PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone) {
	        var _this = this;
	        if (compilerOptions === void 0) { compilerOptions = []; }
	        var /** @type {?} */ compilerFactory = this.injector.get(CompilerFactory);
	        var /** @type {?} */ compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
	        return compiler.compileModuleAsync(moduleType)
	            .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
	    };
	    /**
	     * @param {?} moduleRef
	     * @return {?}
	     */
	    PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
	        var /** @type {?} */ appRef = moduleRef.injector.get(ApplicationRef);
	        if (moduleRef.bootstrapFactories.length > 0) {
	            moduleRef.bootstrapFactories.forEach(function (f) { return appRef.bootstrap(f); });
	        }
	        else if (moduleRef.instance.ngDoBootstrap) {
	            moduleRef.instance.ngDoBootstrap(appRef);
	        }
	        else {
	            throw new Error("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. " +
	                "Please define one of these.");
	        }
	        this._modules.push(moduleRef);
	    };
	    return PlatformRef_;
	}(PlatformRef));
	PlatformRef_.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	PlatformRef_.ctorParameters = function () { return [
	    { type: Injector, },
	]; };
	/**
	 * A reference to an Angular application running on a page.
	 *
	 * For more about Angular applications, see the documentation for {\@link bootstrap}.
	 *
	 * \@stable
	 * @abstract
	 */
	var ApplicationRef = (function () {
	    function ApplicationRef() {
	    }
	    /**
	     * Bootstrap a new component at the root level of the application.
	     *
	     * ### Bootstrap process
	     *
	     * When bootstrapping a new root component into an application, Angular mounts the
	     * specified application component onto DOM elements identified by the [componentType]'s
	     * selector and kicks off automatic change detection to finish initializing the component.
	     *
	     * ### Example
	     * {\@example core/ts/platform/platform.ts region='longform'}
	     * @abstract
	     * @template C
	     * @param {?} componentFactory
	     * @return {?}
	     */
	    ApplicationRef.prototype.bootstrap = function (componentFactory) { };
	    /**
	     * Invoke this method to explicitly process change detection and its side-effects.
	     *
	     * In development mode, `tick()` also performs a second change detection cycle to ensure that no
	     * further changes are detected. If additional changes are picked up during this second cycle,
	     * bindings in the app have side-effects that cannot be resolved in a single change detection
	     * pass.
	     * In this case, Angular throws an error, since an Angular application can only have one change
	     * detection pass during which all change detection must complete.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.tick = function () { };
	    /**
	     * Get a list of component types registered to this application.
	     * This list is populated even before the component is created.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.componentTypes = function () { };
	    /**
	     * Get a list of components registered to this application.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.components = function () { };
	    /**
	     * Attaches a view so that it will be dirty checked.
	     * The view will be automatically detached when it is destroyed.
	     * This will throw if the view is already attached to a ViewContainer.
	     * @abstract
	     * @param {?} view
	     * @return {?}
	     */
	    ApplicationRef.prototype.attachView = function (view) { };
	    /**
	     * Detaches a view from dirty checking again.
	     * @abstract
	     * @param {?} view
	     * @return {?}
	     */
	    ApplicationRef.prototype.detachView = function (view) { };
	    /**
	     * Returns the number of attached views.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.viewCount = function () { };
	    /**
	     * Returns an Observable that indicates when the application is stable or unstable.
	     * @abstract
	     * @return {?}
	     */
	    ApplicationRef.prototype.isStable = function () { };
	    return ApplicationRef;
	}());
	/**
	 * workaround https://github.com/angular/tsickle/issues/350
	 * @suppress {checkTypes}
	 */
	var ApplicationRef_ = (function (_super) {
	    __extends(ApplicationRef_, _super);
	    /**
	     * @param {?} _zone
	     * @param {?} _console
	     * @param {?} _injector
	     * @param {?} _exceptionHandler
	     * @param {?} _componentFactoryResolver
	     * @param {?} _initStatus
	     */
	    function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
	        var _this = _super.call(this) || this;
	        _this._zone = _zone;
	        _this._console = _console;
	        _this._injector = _injector;
	        _this._exceptionHandler = _exceptionHandler;
	        _this._componentFactoryResolver = _componentFactoryResolver;
	        _this._initStatus = _initStatus;
	        _this._bootstrapListeners = [];
	        _this._rootComponents = [];
	        _this._rootComponentTypes = [];
	        _this._views = [];
	        _this._runningTick = false;
	        _this._enforceNoNewChanges = false;
	        _this._stable = true;
	        _this._enforceNoNewChanges = isDevMode();
	        _this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
	        var isCurrentlyStable = new rxjs_Observable.Observable(function (observer) {
	            _this._stable = _this._zone.isStable && !_this._zone.hasPendingMacrotasks &&
	                !_this._zone.hasPendingMicrotasks;
	            _this._zone.runOutsideAngular(function () {
	                observer.next(_this._stable);
	                observer.complete();
	            });
	        });
	        var isStable = new rxjs_Observable.Observable(function (observer) {
	            var stableSub = _this._zone.onStable.subscribe(function () {
	                NgZone.assertNotInAngularZone();
	                // Check whether there are no pending macro/micro tasks in the next tick
	                // to allow for NgZone to update the state.
	                scheduleMicroTask(function () {
	                    if (!_this._stable && !_this._zone.hasPendingMacrotasks &&
	                        !_this._zone.hasPendingMicrotasks) {
	                        _this._stable = true;
	                        observer.next(true);
	                    }
	                });
	            });
	            var unstableSub = _this._zone.onUnstable.subscribe(function () {
	                NgZone.assertInAngularZone();
	                if (_this._stable) {
	                    _this._stable = false;
	                    _this._zone.runOutsideAngular(function () { observer.next(false); });
	                }
	            });
	            return function () {
	                stableSub.unsubscribe();
	                unstableSub.unsubscribe();
	            };
	        });
	        _this._isStable = rxjs_observable_merge.merge(isCurrentlyStable, rxjs_operator_share.share.call(isStable));
	        return _this;
	    }
	    /**
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype.attachView = function (viewRef) {
	        var /** @type {?} */ view = ((viewRef));
	        this._views.push(view);
	        view.attachToAppRef(this);
	    };
	    /**
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype.detachView = function (viewRef) {
	        var /** @type {?} */ view = ((viewRef));
	        remove(this._views, view);
	        view.detachFromAppRef();
	    };
	    /**
	     * @template C
	     * @param {?} componentOrFactory
	     * @return {?}
	     */
	    ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
	        var _this = this;
	        if (!this._initStatus.done) {
	            throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
	        }
	        var /** @type {?} */ componentFactory;
	        if (componentOrFactory instanceof ComponentFactory) {
	            componentFactory = componentOrFactory;
	        }
	        else {
	            componentFactory = ((this._componentFactoryResolver.resolveComponentFactory(componentOrFactory)));
	        }
	        this._rootComponentTypes.push(componentFactory.componentType);
	        // Create a factory associated with the current module if it's not bound to some other
	        var /** @type {?} */ ngModule = componentFactory instanceof ComponentFactoryBoundToModule ?
	            null :
	            this._injector.get(NgModuleRef);
	        var /** @type {?} */ compRef = componentFactory.create(Injector.NULL, [], componentFactory.selector, ngModule);
	        compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	        var /** @type {?} */ testability = compRef.injector.get(Testability, null);
	        if (testability) {
	            compRef.injector.get(TestabilityRegistry)
	                .registerApplication(compRef.location.nativeElement, testability);
	        }
	        this._loadComponent(compRef);
	        if (isDevMode()) {
	            this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
	        }
	        return compRef;
	    };
	    /**
	     * @param {?} componentRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype._loadComponent = function (componentRef) {
	        this.attachView(componentRef.hostView);
	        this.tick();
	        this._rootComponents.push(componentRef);
	        // Get the listeners lazily to prevent DI cycles.
	        var /** @type {?} */ listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
	        listeners.forEach(function (listener) { return listener(componentRef); });
	    };
	    /**
	     * @param {?} componentRef
	     * @return {?}
	     */
	    ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	        this.detachView(componentRef.hostView);
	        remove(this._rootComponents, componentRef);
	    };
	    /**
	     * @return {?}
	     */
	    ApplicationRef_.prototype.tick = function () {
	        if (this._runningTick) {
	            throw new Error('ApplicationRef.tick is called recursively');
	        }
	        var /** @type {?} */ scope = ApplicationRef_._tickScope();
	        try {
	            this._runningTick = true;
	            this._views.forEach(function (view) { return view.detectChanges(); });
	            if (this._enforceNoNewChanges) {
	                this._views.forEach(function (view) { return view.checkNoChanges(); });
	            }
	        }
	        finally {
	            this._runningTick = false;
	            wtfLeave(scope);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    ApplicationRef_.prototype.ngOnDestroy = function () {
	        // TODO(alxhub): Dispose of the NgZone.
	        this._views.slice().forEach(function (view) { return view.destroy(); });
	    };
	    Object.defineProperty(ApplicationRef_.prototype, "viewCount", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._views.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._rootComponentTypes; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "components", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._rootComponents; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef_.prototype, "isStable", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._isStable; },
	        enumerable: true,
	        configurable: true
	    });
	    return ApplicationRef_;
	}(ApplicationRef));
	/**
	 * \@internal
	 */
	ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
	ApplicationRef_.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	ApplicationRef_.ctorParameters = function () { return [
	    { type: NgZone, },
	    { type: Console, },
	    { type: Injector, },
	    { type: ErrorHandler, },
	    { type: ComponentFactoryResolver, },
	    { type: ApplicationInitStatus, },
	]; };
	/**
	 * @template T
	 * @param {?} list
	 * @param {?} el
	 * @return {?}
	 */
	function remove(list, el) {
	    var /** @type {?} */ index = list.indexOf(el);
	    if (index > -1) {
	        list.splice(index, 1);
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Public API for Zone
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @deprecated Use `RendererType2` (and `Renderer2`) instead.
	 */
	var RenderComponentType = (function () {
	    /**
	     * @param {?} id
	     * @param {?} templateUrl
	     * @param {?} slotCount
	     * @param {?} encapsulation
	     * @param {?} styles
	     * @param {?} animations
	     */
	    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
	        this.id = id;
	        this.templateUrl = templateUrl;
	        this.slotCount = slotCount;
	        this.encapsulation = encapsulation;
	        this.styles = styles;
	        this.animations = animations;
	    }
	    return RenderComponentType;
	}());
	/**
	 * @deprecated Debug info is handeled internally in the view engine now.
	 * @abstract
	 */
	var RenderDebugInfo = (function () {
	    function RenderDebugInfo() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.injector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.component = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.providerTokens = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.references = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.context = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    RenderDebugInfo.prototype.source = function () { };
	    return RenderDebugInfo;
	}());
	/**
	 * @deprecated Use the `Renderer2` instead.
	 * @abstract
	 */
	var Renderer = (function () {
	    function Renderer() {
	    }
	    /**
	     * @abstract
	     * @param {?} selectorOrNode
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?} name
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.createElement = function (parentElement, name, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} hostElement
	     * @return {?}
	     */
	    Renderer.prototype.createViewRoot = function (hostElement) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?} value
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    Renderer.prototype.createText = function (parentElement, value, debugInfo) { };
	    /**
	     * @abstract
	     * @param {?} parentElement
	     * @param {?} nodes
	     * @return {?}
	     */
	    Renderer.prototype.projectNodes = function (parentElement, nodes) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    Renderer.prototype.attachViewAfter = function (node, viewRootNodes) { };
	    /**
	     * @abstract
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    Renderer.prototype.detachView = function (viewRootNodes) { };
	    /**
	     * @abstract
	     * @param {?} hostElement
	     * @param {?} viewAllNodes
	     * @return {?}
	     */
	    Renderer.prototype.destroyView = function (hostElement, viewAllNodes) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    Renderer.prototype.listen = function (renderElement, name, callback) { };
	    /**
	     * @abstract
	     * @param {?} target
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    Renderer.prototype.listenGlobal = function (target, name, callback) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    Renderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} attributeName
	     * @param {?} attributeValue
	     * @return {?}
	     */
	    Renderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) { };
	    /**
	     * Used only in debug mode to serialize property changes to dom nodes as attributes.
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    Renderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} className
	     * @param {?} isAdd
	     * @return {?}
	     */
	    Renderer.prototype.setElementClass = function (renderElement, className, isAdd) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} styleName
	     * @param {?} styleValue
	     * @return {?}
	     */
	    Renderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) { };
	    /**
	     * @abstract
	     * @param {?} renderElement
	     * @param {?} methodName
	     * @param {?=} args
	     * @return {?}
	     */
	    Renderer.prototype.invokeElementMethod = function (renderElement, methodName, args) { };
	    /**
	     * @abstract
	     * @param {?} renderNode
	     * @param {?} text
	     * @return {?}
	     */
	    Renderer.prototype.setText = function (renderNode, text) { };
	    /**
	     * @abstract
	     * @param {?} element
	     * @param {?} startingStyles
	     * @param {?} keyframes
	     * @param {?} duration
	     * @param {?} delay
	     * @param {?} easing
	     * @param {?=} previousPlayers
	     * @return {?}
	     */
	    Renderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
	    return Renderer;
	}());
	var Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
	/**
	 * Injectable service that provides a low-level interface for modifying the UI.
	 *
	 * Use this service to bypass Angular's templating and make custom UI changes that can't be
	 * expressed declaratively. For example if you need to set a property or an attribute whose name is
	 * not statically known, use {\@link #setElementProperty} or {\@link #setElementAttribute}
	 * respectively.
	 *
	 * If you are implementing a custom renderer, you must implement this interface.
	 *
	 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	 *
	 * @deprecated Use `RendererFactory2` instead.
	 * @abstract
	 */
	var RootRenderer = (function () {
	    function RootRenderer() {
	    }
	    /**
	     * @abstract
	     * @param {?} componentType
	     * @return {?}
	     */
	    RootRenderer.prototype.renderComponent = function (componentType) { };
	    return RootRenderer;
	}());
	/**
	 * \@experimental
	 * @abstract
	 */
	var RendererFactory2 = (function () {
	    function RendererFactory2() {
	    }
	    /**
	     * @abstract
	     * @param {?} hostElement
	     * @param {?} type
	     * @return {?}
	     */
	    RendererFactory2.prototype.createRenderer = function (hostElement, type) { };
	    return RendererFactory2;
	}());
	var RendererStyleFlags2 = {};
	RendererStyleFlags2.Important = 1;
	RendererStyleFlags2.DashCase = 2;
	RendererStyleFlags2[RendererStyleFlags2.Important] = "Important";
	RendererStyleFlags2[RendererStyleFlags2.DashCase] = "DashCase";
	/**
	 * \@experimental
	 * @abstract
	 */
	var Renderer2 = (function () {
	    function Renderer2() {
	    }
	    /**
	     * This field can be used to store arbitrary data on this renderer instance.
	     * This is useful for renderers that delegate to other renderers.
	     * @abstract
	     * @return {?}
	     */
	    Renderer2.prototype.data = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    Renderer2.prototype.destroy = function () { };
	    /**
	     * @abstract
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    Renderer2.prototype.createElement = function (name, namespace) { };
	    /**
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.createComment = function (value) { };
	    /**
	     * @abstract
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.createText = function (value) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} newChild
	     * @return {?}
	     */
	    Renderer2.prototype.appendChild = function (parent, newChild) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} newChild
	     * @param {?} refChild
	     * @return {?}
	     */
	    Renderer2.prototype.insertBefore = function (parent, newChild, refChild) { };
	    /**
	     * @abstract
	     * @param {?} parent
	     * @param {?} oldChild
	     * @return {?}
	     */
	    Renderer2.prototype.removeChild = function (parent, oldChild) { };
	    /**
	     * @abstract
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    Renderer2.prototype.selectRootElement = function (selectorOrNode) { };
	    /**
	     * Attention: On WebWorkers, this will always return a value,
	     * as we are asking for a result synchronously. I.e.
	     * the caller can't rely on checking whether this is null or not.
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    Renderer2.prototype.parentNode = function (node) { };
	    /**
	     * Attention: On WebWorkers, this will always return a value,
	     * as we are asking for a result synchronously. I.e.
	     * the caller can't rely on checking whether this is null or not.
	     * @abstract
	     * @param {?} node
	     * @return {?}
	     */
	    Renderer2.prototype.nextSibling = function (node) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @param {?=} namespace
	     * @return {?}
	     */
	    Renderer2.prototype.setAttribute = function (el, name, value, namespace) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    Renderer2.prototype.removeAttribute = function (el, name, namespace) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    Renderer2.prototype.addClass = function (el, name) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    Renderer2.prototype.removeClass = function (el, name) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} style
	     * @param {?} value
	     * @param {?=} flags
	     * @return {?}
	     */
	    Renderer2.prototype.setStyle = function (el, style, value, flags) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} style
	     * @param {?=} flags
	     * @return {?}
	     */
	    Renderer2.prototype.removeStyle = function (el, style, flags) { };
	    /**
	     * @abstract
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.setProperty = function (el, name, value) { };
	    /**
	     * @abstract
	     * @param {?} node
	     * @param {?} value
	     * @return {?}
	     */
	    Renderer2.prototype.setValue = function (node, value) { };
	    /**
	     * @abstract
	     * @param {?} target
	     * @param {?} eventName
	     * @param {?} callback
	     * @return {?}
	     */
	    Renderer2.prototype.listen = function (target, eventName, callback) { };
	    return Renderer2;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Public API for render
	var ElementRef = (function () {
	    /**
	     * @param {?} nativeElement
	     */
	    function ElementRef(nativeElement) {
	        this.nativeElement = nativeElement;
	    }
	    return ElementRef;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Used to load ng module factories.
	 * \@stable
	 * @abstract
	 */
	var NgModuleFactoryLoader = (function () {
	    function NgModuleFactoryLoader() {
	    }
	    /**
	     * @abstract
	     * @param {?} path
	     * @return {?}
	     */
	    NgModuleFactoryLoader.prototype.load = function (path) { };
	    return NgModuleFactoryLoader;
	}());
	var moduleFactories = new Map();
	/**
	 * Registers a loaded module. Should only be called from generated NgModuleFactory code.
	 * \@experimental
	 * @param {?} id
	 * @param {?} factory
	 * @return {?}
	 */
	function registerModuleFactory(id, factory) {
	    var /** @type {?} */ existing = moduleFactories.get(id);
	    if (existing) {
	        throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
	    }
	    moduleFactories.set(id, factory);
	}
	/**
	 * @return {?}
	 */
	/**
	 * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
	 * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
	 * cannot be found.
	 * \@experimental
	 * @param {?} id
	 * @return {?}
	 */
	function getModuleFactory(id) {
	    var /** @type {?} */ factory = moduleFactories.get(id);
	    if (!factory)
	        throw new Error("No module with ID " + id + " loaded");
	    return factory;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * An unmodifiable list of items that Angular keeps up to date when the state
	 * of the application changes.
	 *
	 * The type of object that {\@link Query} and {\@link ViewQueryMetadata} provide.
	 *
	 * Implements an iterable interface, therefore it can be used in both ES6
	 * javascript `for (var i of items)` loops as well as in Angular templates with
	 * `*ngFor="let i of myList"`.
	 *
	 * Changes can be observed by subscribing to the changes `Observable`.
	 *
	 * NOTE: In the future this class will implement an `Observable` interface.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	 * ```typescript
	 * \@Component({...})
	 * class Container {
	 *   \@ViewChildren(Item) items:QueryList<Item>;
	 * }
	 * ```
	 * \@stable
	 */
	var QueryList = (function () {
	    function QueryList() {
	        this._dirty = true;
	        this._results = [];
	        this._emitter = new EventEmitter();
	    }
	    Object.defineProperty(QueryList.prototype, "changes", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._emitter; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "length", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._results.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "first", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._results[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "last", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._results[this.length - 1]; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * See
	     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	     * @template U
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	    /**
	     * See
	     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.filter = function (fn) {
	        return this._results.filter(fn);
	    };
	    /**
	     * See
	     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.find = function (fn) {
	        return this._results.find(fn);
	    };
	    /**
	     * See
	     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	     * @template U
	     * @param {?} fn
	     * @param {?} init
	     * @return {?}
	     */
	    QueryList.prototype.reduce = function (fn, init) {
	        return this._results.reduce(fn, init);
	    };
	    /**
	     * See
	     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	    /**
	     * See
	     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	     * @param {?} fn
	     * @return {?}
	     */
	    QueryList.prototype.some = function (fn) {
	        return this._results.some(fn);
	    };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype.toArray = function () { return this._results.slice(); };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype[getSymbolIterator()] = function () { return ((this._results))[getSymbolIterator()](); };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype.toString = function () { return this._results.toString(); };
	    /**
	     * @param {?} res
	     * @return {?}
	     */
	    QueryList.prototype.reset = function (res) {
	        this._results = flatten(res);
	        this._dirty = false;
	    };
	    /**
	     * @return {?}
	     */
	    QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	    /**
	     * internal
	     * @return {?}
	     */
	    QueryList.prototype.setDirty = function () { this._dirty = true; };
	    Object.defineProperty(QueryList.prototype, "dirty", {
	        /**
	         * internal
	         * @return {?}
	         */
	        get: function () { return this._dirty; },
	        enumerable: true,
	        configurable: true
	    });
	    return QueryList;
	}());
	/**
	 * @template T
	 * @param {?} list
	 * @return {?}
	 */
	function flatten(list) {
	    return list.reduce(function (flat, item) {
	        var /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;
	        return ((flat)).concat(flatItem);
	    }, []);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var _SEPARATOR = '#';
	var FACTORY_CLASS_SUFFIX = 'NgFactory';
	/**
	 * Configuration for SystemJsNgModuleLoader.
	 * token.
	 *
	 * \@experimental
	 * @abstract
	 */
	var SystemJsNgModuleLoaderConfig = (function () {
	    function SystemJsNgModuleLoaderConfig() {
	    }
	    return SystemJsNgModuleLoaderConfig;
	}());
	var DEFAULT_CONFIG = {
	    factoryPathPrefix: '',
	    factoryPathSuffix: '.ngfactory',
	};
	/**
	 * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
	 * \@experimental
	 */
	var SystemJsNgModuleLoader = (function () {
	    /**
	     * @param {?} _compiler
	     * @param {?=} config
	     */
	    function SystemJsNgModuleLoader(_compiler, config) {
	        this._compiler = _compiler;
	        this._config = config || DEFAULT_CONFIG;
	    }
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    SystemJsNgModuleLoader.prototype.load = function (path) {
	        var /** @type {?} */ offlineMode = this._compiler instanceof Compiler;
	        return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
	    };
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
	        var _this = this;
	        var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	        if (exportName === undefined) {
	            exportName = 'default';
	        }
	        return System.import(module)
	            .then(function (module) { return module[exportName]; })
	            .then(function (type) { return checkNotEmpty(type, module, exportName); })
	            .then(function (type) { return _this._compiler.compileModuleAsync(type); });
	    };
	    /**
	     * @param {?} path
	     * @return {?}
	     */
	    SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
	        var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	        var /** @type {?} */ factoryClassSuffix = FACTORY_CLASS_SUFFIX;
	        if (exportName === undefined) {
	            exportName = 'default';
	            factoryClassSuffix = '';
	        }
	        return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
	            .then(function (module) { return module[exportName + factoryClassSuffix]; })
	            .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
	    };
	    return SystemJsNgModuleLoader;
	}());
	SystemJsNgModuleLoader.decorators = [
	    { type: Injectable },
	];
	/**
	 * @nocollapse
	 */
	SystemJsNgModuleLoader.ctorParameters = function () { return [
	    { type: Compiler, },
	    { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
	]; };
	/**
	 * @param {?} value
	 * @param {?} modulePath
	 * @param {?} exportName
	 * @return {?}
	 */
	function checkNotEmpty(value, modulePath, exportName) {
	    if (!value) {
	        throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
	    }
	    return value;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents an Embedded Template that can be used to instantiate Embedded Views.
	 *
	 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<ng-template>` element
	 * (or directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into
	 * the constructor of the directive using the `TemplateRef` Token. Alternatively you can query for
	 * the `TemplateRef` from a Component or a Directive via {\@link Query}.
	 *
	 * To instantiate Embedded Views based on a Template, use
	 * {\@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	 * View Container.
	 * \@stable
	 * @abstract
	 */
	var TemplateRef = (function () {
	    function TemplateRef() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    TemplateRef.prototype.elementRef = function () { };
	    /**
	     * @abstract
	     * @param {?} context
	     * @return {?}
	     */
	    TemplateRef.prototype.createEmbeddedView = function (context) { };
	    return TemplateRef;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Represents a container where one or more Views can be attached.
	 *
	 * The container can contain two kinds of Views. Host Views, created by instantiating a
	 * {\@link Component} via {\@link #createComponent}, and Embedded Views, created by instantiating an
	 * {\@link TemplateRef Embedded Template} via {\@link #createEmbeddedView}.
	 *
	 * The location of the View Container within the containing View is specified by the Anchor
	 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	 * have a single View Container.
	 *
	 * Root elements of Views attached to this container become siblings of the Anchor Element in
	 * the Rendered View.
	 *
	 * To access a `ViewContainerRef` of an Element, you can either place a {\@link Directive} injected
	 * with `ViewContainerRef` on the Element, or you obtain it via a {\@link ViewChild} query.
	 * \@stable
	 * @abstract
	 */
	var ViewContainerRef = (function () {
	    function ViewContainerRef() {
	    }
	    /**
	     * Anchor element that specifies the location of this container in the containing View.
	     * <!-- TODO: rename to anchorElement -->
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.element = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.injector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.parentInjector = function () { };
	    /**
	     * Destroys all Views in this container.
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.clear = function () { };
	    /**
	     * Returns the {\@link ViewRef} for the View located in this container at the specified index.
	     * @abstract
	     * @param {?} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.get = function (index) { };
	    /**
	     * Returns the number of Views currently attached to this container.
	     * @abstract
	     * @return {?}
	     */
	    ViewContainerRef.prototype.length = function () { };
	    /**
	     * Instantiates an Embedded View based on the {\@link TemplateRef `templateRef`} and inserts it
	     * into this container at the specified `index`.
	     *
	     * If `index` is not specified, the new View will be inserted as the last View in the container.
	     *
	     * Returns the {\@link ViewRef} for the newly created View.
	     * @abstract
	     * @template C
	     * @param {?} templateRef
	     * @param {?=} context
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.createEmbeddedView = function (templateRef, context, index) { };
	    /**
	     * Instantiates a single {\@link Component} and inserts its Host View into this container at the
	     * specified `index`.
	     *
	     * The component is instantiated using its {\@link ComponentFactory} which can be
	     * obtained via {\@link ComponentFactoryResolver#resolveComponentFactory}.
	     *
	     * If `index` is not specified, the new View will be inserted as the last View in the container.
	     *
	     * You can optionally specify the {\@link Injector} that will be used as parent for the Component.
	     *
	     * Returns the {\@link ComponentRef} of the Host View created for the newly instantiated Component.
	     * @abstract
	     * @template C
	     * @param {?} componentFactory
	     * @param {?=} index
	     * @param {?=} injector
	     * @param {?=} projectableNodes
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ViewContainerRef.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModule) { };
	    /**
	     * Inserts a View identified by a {\@link ViewRef} into the container at the specified `index`.
	     *
	     * If `index` is not specified, the new View will be inserted as the last View in the container.
	     *
	     * Returns the inserted {\@link ViewRef}.
	     * @abstract
	     * @param {?} viewRef
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.insert = function (viewRef, index) { };
	    /**
	     * Moves a View identified by a {\@link ViewRef} into the container at the specified `index`.
	     *
	     * Returns the inserted {\@link ViewRef}.
	     * @abstract
	     * @param {?} viewRef
	     * @param {?} currentIndex
	     * @return {?}
	     */
	    ViewContainerRef.prototype.move = function (viewRef, currentIndex) { };
	    /**
	     * Returns the index of the View, specified via {\@link ViewRef}, within the current container or
	     * `-1` if this container doesn't contain the View.
	     * @abstract
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ViewContainerRef.prototype.indexOf = function (viewRef) { };
	    /**
	     * Destroys a View attached to this container at the specified `index`.
	     *
	     * If `index` is not specified, the last View in the container will be removed.
	     * @abstract
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.remove = function (index) { };
	    /**
	     * Use along with {\@link #insert} to move a View within the current container.
	     *
	     * If the `index` param is omitted, the last {\@link ViewRef} is detached.
	     * @abstract
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef.prototype.detach = function (index) { };
	    return ViewContainerRef;
	}());
	/**
	 * \@stable
	 * @abstract
	 */
	var ChangeDetectorRef = (function () {
	    function ChangeDetectorRef() {
	    }
	    /**
	     * Marks all {\@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
	     *
	     * <!-- TODO: Add a link to a chapter on OnPush components -->
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
	     *
	     * ```typescript
	     * \@Component({
	     *   selector: 'cmp',
	     *   changeDetection: ChangeDetectionStrategy.OnPush,
	     *   template: `Number of ticks: {{numberOfTicks}}`
	     * })
	     * class Cmp {
	     *   numberOfTicks = 0;
	     *
	     *   constructor(ref: ChangeDetectorRef) {
	     *     setInterval(() => {
	     *       this.numberOfTicks ++
	     *       // the following is required, otherwise the view will not be updated
	     *       this.ref.markForCheck();
	     *     }, 1000);
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'app',
	     *   changeDetection: ChangeDetectionStrategy.OnPush,
	     *   template: `
	     *     <cmp><cmp>
	     *   `,
	     * })
	     * class App {
	     * }
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.markForCheck = function () { };
	    /**
	     * Detaches the change detector from the change detector tree.
	     *
	     * The detached change detector will not be checked until it is reattached.
	     *
	     * This can also be used in combination with {\@link ChangeDetectorRef#detectChanges} to implement
	     * local change
	     * detection checks.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	     *
	     * ### Example
	     *
	     * The following example defines a component with a large list of readonly data.
	     * Imagine the data changes constantly, many times per second. For performance reasons,
	     * we want to check and update the list every five seconds. We can do that by detaching
	     * the component's change detector and doing a local check every five seconds.
	     *
	     * ```typescript
	     * class DataProvider {
	     *   // in a real application the returned data will be different every time
	     *   get data() {
	     *     return [1,2,3,4,5];
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'giant-list',
	     *   template: `
	     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
	     *   `,
	     * })
	     * class GiantList {
	     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
	     *     ref.detach();
	     *     setInterval(() => {
	     *       this.ref.detectChanges();
	     *     }, 5000);
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'app',
	     *   providers: [DataProvider],
	     *   template: `
	     *     <giant-list><giant-list>
	     *   `,
	     * })
	     * class App {
	     * }
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.detach = function () { };
	    /**
	     * Checks the change detector and its children.
	     *
	     * This can also be used in combination with {\@link ChangeDetectorRef#detach} to implement local
	     * change detection
	     * checks.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	     *
	     * ### Example
	     *
	     * The following example defines a component with a large list of readonly data.
	     * Imagine, the data changes constantly, many times per second. For performance reasons,
	     * we want to check and update the list every five seconds.
	     *
	     * We can do that by detaching the component's change detector and doing a local change detection
	     * check
	     * every five seconds.
	     *
	     * See {\@link ChangeDetectorRef#detach} for more information.
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.detectChanges = function () { };
	    /**
	     * Checks the change detector and its children, and throws if any changes are detected.
	     *
	     * This is used in development mode to verify that running change detection doesn't introduce
	     * other changes.
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.checkNoChanges = function () { };
	    /**
	     * Reattach the change detector to the change detector tree.
	     *
	     * This also marks OnPush ancestors as to be checked. This reattached change detector will be
	     * checked during the next change detection run.
	     *
	     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
	     *
	     * The following example creates a component displaying `live` data. The component will detach
	     * its change detector from the main change detector tree when the component's live property
	     * is set to false.
	     *
	     * ```typescript
	     * class DataProvider {
	     *   data = 1;
	     *
	     *   constructor() {
	     *     setInterval(() => {
	     *       this.data = this.data * 2;
	     *     }, 500);
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'live-data',
	     *   inputs: ['live'],
	     *   template: 'Data: {{dataProvider.data}}'
	     * })
	     * class LiveData {
	     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
	     *
	     *   set live(value) {
	     *     if (value)
	     *       this.ref.reattach();
	     *     else
	     *       this.ref.detach();
	     *   }
	     * }
	     *
	     * \@Component({
	     *   selector: 'app',
	     *   providers: [DataProvider],
	     *   template: `
	     *     Live Update: <input type="checkbox" [(ngModel)]="live">
	     *     <live-data [live]="live"><live-data>
	     *   `,
	     * })
	     * class App {
	     *   live = true;
	     * }
	     * ```
	     * @abstract
	     * @return {?}
	     */
	    ChangeDetectorRef.prototype.reattach = function () { };
	    return ChangeDetectorRef;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@stable
	 * @abstract
	 */
	var ViewRef = (function (_super) {
	    __extends(ViewRef, _super);
	    function ViewRef() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Destroys the view and all of the data structures associated with it.
	     * @abstract
	     * @return {?}
	     */
	    ViewRef.prototype.destroy = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    ViewRef.prototype.destroyed = function () { };
	    /**
	     * @abstract
	     * @param {?} callback
	     * @return {?}
	     */
	    ViewRef.prototype.onDestroy = function (callback) { };
	    return ViewRef;
	}(ChangeDetectorRef));
	/**
	 * Represents an Angular View.
	 *
	 * <!-- TODO: move the next two paragraphs to the dev guide -->
	 * A View is a fundamental building block of the application UI. It is the smallest grouping of
	 * Elements which are created and destroyed together.
	 *
	 * Properties of elements in a View can change, but the structure (number and order) of elements in
	 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	 * removing nested Views via a {\@link ViewContainerRef}. Each View can contain many View Containers.
	 * <!-- /TODO -->
	 *
	 * ### Example
	 *
	 * Given this template...
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ngFor="let  item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * We have two {\@link TemplateRef}s:
	 *
	 * Outer {\@link TemplateRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
	 * </ul>
	 * ```
	 *
	 * Inner {\@link TemplateRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {\@link TemplateRef}s.
	 *
	 * The outer/inner {\@link TemplateRef}s are then assembled into views like so:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <ng-template view-container-ref></ng-template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 * \@experimental
	 * @abstract
	 */
	var EmbeddedViewRef = (function (_super) {
	    __extends(EmbeddedViewRef, _super);
	    function EmbeddedViewRef() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    EmbeddedViewRef.prototype.context = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    EmbeddedViewRef.prototype.rootNodes = function () { };
	    return EmbeddedViewRef;
	}(ViewRef));
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// Public API for compiler
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var EventListener = (function () {
	    /**
	     * @param {?} name
	     * @param {?} callback
	     */
	    function EventListener(name, callback) {
	        this.name = name;
	        this.callback = callback;
	    }
	    
	    return EventListener;
	}());
	/**
	 * \@experimental All debugging apis are currently experimental.
	 */
	var DebugNode = (function () {
	    /**
	     * @param {?} nativeNode
	     * @param {?} parent
	     * @param {?} _debugContext
	     */
	    function DebugNode(nativeNode, parent, _debugContext) {
	        this._debugContext = _debugContext;
	        this.nativeNode = nativeNode;
	        if (parent && parent instanceof DebugElement) {
	            parent.addChild(this);
	        }
	        else {
	            this.parent = null;
	        }
	        this.listeners = [];
	    }
	    Object.defineProperty(DebugNode.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.injector; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "componentInstance", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.component; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "context", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "references", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.references; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "providerTokens", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._debugContext.providerTokens; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugNode.prototype, "source", {
	        /**
	         * @deprecated since v4
	         * @return {?}
	         */
	        get: function () { return 'Deprecated since v4'; },
	        enumerable: true,
	        configurable: true
	    });
	    return DebugNode;
	}());
	/**
	 * \@experimental All debugging apis are currently experimental.
	 */
	var DebugElement = (function (_super) {
	    __extends(DebugElement, _super);
	    /**
	     * @param {?} nativeNode
	     * @param {?} parent
	     * @param {?} _debugContext
	     */
	    function DebugElement(nativeNode, parent, _debugContext) {
	        var _this = _super.call(this, nativeNode, parent, _debugContext) || this;
	        _this.properties = {};
	        _this.attributes = {};
	        _this.classes = {};
	        _this.styles = {};
	        _this.childNodes = [];
	        _this.nativeElement = nativeNode;
	        return _this;
	    }
	    /**
	     * @param {?} child
	     * @return {?}
	     */
	    DebugElement.prototype.addChild = function (child) {
	        if (child) {
	            this.childNodes.push(child);
	            child.parent = this;
	        }
	    };
	    /**
	     * @param {?} child
	     * @return {?}
	     */
	    DebugElement.prototype.removeChild = function (child) {
	        var /** @type {?} */ childIndex = this.childNodes.indexOf(child);
	        if (childIndex !== -1) {
	            child.parent = null;
	            this.childNodes.splice(childIndex, 1);
	        }
	    };
	    /**
	     * @param {?} child
	     * @param {?} newChildren
	     * @return {?}
	     */
	    DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	        var _this = this;
	        var /** @type {?} */ siblingIndex = this.childNodes.indexOf(child);
	        if (siblingIndex !== -1) {
	            (_a = this.childNodes).splice.apply(_a, [siblingIndex + 1, 0].concat(newChildren));
	            newChildren.forEach(function (c) {
	                if (c.parent) {
	                    c.parent.removeChild(c);
	                }
	                c.parent = _this;
	            });
	        }
	        var _a;
	    };
	    /**
	     * @param {?} refChild
	     * @param {?} newChild
	     * @return {?}
	     */
	    DebugElement.prototype.insertBefore = function (refChild, newChild) {
	        var /** @type {?} */ refIndex = this.childNodes.indexOf(refChild);
	        if (refIndex === -1) {
	            this.addChild(newChild);
	        }
	        else {
	            if (newChild.parent) {
	                newChild.parent.removeChild(newChild);
	            }
	            newChild.parent = this;
	            this.childNodes.splice(refIndex, 0, newChild);
	        }
	    };
	    /**
	     * @param {?} predicate
	     * @return {?}
	     */
	    DebugElement.prototype.query = function (predicate) {
	        var /** @type {?} */ results = this.queryAll(predicate);
	        return results[0] || null;
	    };
	    /**
	     * @param {?} predicate
	     * @return {?}
	     */
	    DebugElement.prototype.queryAll = function (predicate) {
	        var /** @type {?} */ matches = [];
	        _queryElementChildren(this, predicate, matches);
	        return matches;
	    };
	    /**
	     * @param {?} predicate
	     * @return {?}
	     */
	    DebugElement.prototype.queryAllNodes = function (predicate) {
	        var /** @type {?} */ matches = [];
	        _queryNodeChildren(this, predicate, matches);
	        return matches;
	    };
	    Object.defineProperty(DebugElement.prototype, "children", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return (this.childNodes.filter(function (node) { return node instanceof DebugElement; }));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} eventName
	     * @param {?} eventObj
	     * @return {?}
	     */
	    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	        this.listeners.forEach(function (listener) {
	            if (listener.name == eventName) {
	                listener.callback(eventObj);
	            }
	        });
	    };
	    return DebugElement;
	}(DebugNode));
	/**
	 * \@experimental
	 * @param {?} debugEls
	 * @return {?}
	 */
	function asNativeElements(debugEls) {
	    return debugEls.map(function (el) { return el.nativeElement; });
	}
	/**
	 * @param {?} element
	 * @param {?} predicate
	 * @param {?} matches
	 * @return {?}
	 */
	function _queryElementChildren(element, predicate, matches) {
	    element.childNodes.forEach(function (node) {
	        if (node instanceof DebugElement) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            _queryElementChildren(node, predicate, matches);
	        }
	    });
	}
	/**
	 * @param {?} parentNode
	 * @param {?} predicate
	 * @param {?} matches
	 * @return {?}
	 */
	function _queryNodeChildren(parentNode, predicate, matches) {
	    if (parentNode instanceof DebugElement) {
	        parentNode.childNodes.forEach(function (node) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            if (node instanceof DebugElement) {
	                _queryNodeChildren(node, predicate, matches);
	            }
	        });
	    }
	}
	// Need to keep the nodes in a global Map so that multiple angular apps are supported.
	var _nativeNodeToDebugNode = new Map();
	/**
	 * \@experimental
	 * @param {?} nativeNode
	 * @return {?}
	 */
	function getDebugNode(nativeNode) {
	    return _nativeNodeToDebugNode.get(nativeNode) || null;
	}
	/**
	 * @return {?}
	 */
	/**
	 * @param {?} node
	 * @return {?}
	 */
	function indexDebugNode(node) {
	    _nativeNodeToDebugNode.set(node.nativeNode, node);
	}
	/**
	 * @param {?} node
	 * @return {?}
	 */
	function removeDebugNodeFromIndex(node) {
	    _nativeNodeToDebugNode.delete(node.nativeNode);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} a
	 * @param {?} b
	 * @return {?}
	 */
	function devModeEqual(a, b) {
	    var /** @type {?} */ isListLikeIterableA = isListLikeIterable(a);
	    var /** @type {?} */ isListLikeIterableB = isListLikeIterable(b);
	    if (isListLikeIterableA && isListLikeIterableB) {
	        return areIterablesEqual(a, b, devModeEqual);
	    }
	    else {
	        var /** @type {?} */ isAObject = a && (typeof a === 'object' || typeof a === 'function');
	        var /** @type {?} */ isBObject = b && (typeof b === 'object' || typeof b === 'function');
	        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
	            return true;
	        }
	        else {
	            return looseIdentical(a, b);
	        }
	    }
	}
	/**
	 * Indicates that the result of a {\@link Pipe} transformation has changed even though the
	 * reference
	 * has not changed.
	 *
	 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 * \@stable
	 */
	var WrappedValue = (function () {
	    /**
	     * @param {?} wrapped
	     */
	    function WrappedValue(wrapped) {
	        this.wrapped = wrapped;
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	    return WrappedValue;
	}());
	/**
	 * Helper class for unwrapping WrappedValue s
	 */
	var ValueUnwrapper = (function () {
	    function ValueUnwrapper() {
	        this.hasWrappedValue = false;
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    ValueUnwrapper.prototype.unwrap = function (value) {
	        if (value instanceof WrappedValue) {
	            this.hasWrappedValue = true;
	            return value.wrapped;
	        }
	        return value;
	    };
	    /**
	     * @return {?}
	     */
	    ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	    return ValueUnwrapper;
	}());
	/**
	 * Represents a basic change from a previous to a new value.
	 * \@stable
	 */
	var SimpleChange = (function () {
	    /**
	     * @param {?} previousValue
	     * @param {?} currentValue
	     * @param {?} firstChange
	     */
	    function SimpleChange(previousValue, currentValue, firstChange) {
	        this.previousValue = previousValue;
	        this.currentValue = currentValue;
	        this.firstChange = firstChange;
	    }
	    /**
	     * Check whether the new value is the first value assigned.
	     * @return {?}
	     */
	    SimpleChange.prototype.isFirstChange = function () { return this.firstChange; };
	    return SimpleChange;
	}());
	/**
	 * @param {?} obj
	 * @return {?}
	 */
	function isListLikeIterable(obj) {
	    if (!isJsObject(obj))
	        return false;
	    return Array.isArray(obj) ||
	        (!(obj instanceof Map) &&
	            getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	}
	/**
	 * @param {?} a
	 * @param {?} b
	 * @param {?} comparator
	 * @return {?}
	 */
	function areIterablesEqual(a, b, comparator) {
	    var /** @type {?} */ iterator1 = a[getSymbolIterator()]();
	    var /** @type {?} */ iterator2 = b[getSymbolIterator()]();
	    while (true) {
	        var /** @type {?} */ item1 = iterator1.next();
	        var /** @type {?} */ item2 = iterator2.next();
	        if (item1.done && item2.done)
	            return true;
	        if (item1.done || item2.done)
	            return false;
	        if (!comparator(item1.value, item2.value))
	            return false;
	    }
	}
	/**
	 * @param {?} obj
	 * @param {?} fn
	 * @return {?}
	 */
	function iterateListLike(obj, fn) {
	    if (Array.isArray(obj)) {
	        for (var /** @type {?} */ i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    }
	    else {
	        var /** @type {?} */ iterator = obj[getSymbolIterator()]();
	        var /** @type {?} */ item = void 0;
	        while (!((item = iterator.next()).done)) {
	            fn(item.value);
	        }
	    }
	}
	/**
	 * @param {?} o
	 * @return {?}
	 */
	function isJsObject(o) {
	    return o !== null && (typeof o === 'function' || typeof o === 'object');
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var DefaultIterableDifferFactory = (function () {
	    function DefaultIterableDifferFactory() {
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
	    /**
	     * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
	     * @template V
	     * @param {?=} cdRefOrTrackBy
	     * @param {?=} trackByFn
	     * @return {?}
	     */
	    DefaultIterableDifferFactory.prototype.create = function (cdRefOrTrackBy, trackByFn) {
	        return new DefaultIterableDiffer(trackByFn || (cdRefOrTrackBy));
	    };
	    return DefaultIterableDifferFactory;
	}());
	var trackByIdentity = function (index, item) { return item; };
	/**
	 * @deprecated v4.0.0 - Should not be part of public API.
	 */
	var DefaultIterableDiffer = (function () {
	    /**
	     * @param {?=} trackByFn
	     */
	    function DefaultIterableDiffer(trackByFn) {
	        this._length = 0;
	        this._collection = null;
	        this._linkedRecords = null;
	        this._unlinkedRecords = null;
	        this._previousItHead = null;
	        this._itHead = null;
	        this._itTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._movesHead = null;
	        this._movesTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	        this._identityChangesHead = null;
	        this._identityChangesTail = null;
	        this._trackByFn = trackByFn || trackByIdentity;
	    }
	    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._collection; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._length; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._itHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
	        var /** @type {?} */ nextIt = this._itHead;
	        var /** @type {?} */ nextRemove = this._removalsHead;
	        var /** @type {?} */ addRemoveOffset = 0;
	        var /** @type {?} */ moveOffsets = null;
	        while (nextIt || nextRemove) {
	            // Figure out which is the next record to process
	            // Order: remove, add, move
	            var /** @type {?} */ record = !nextRemove ||
	                nextIt && ((nextIt.currentIndex)) <
	                    getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? ((nextIt)) :
	                nextRemove;
	            var /** @type {?} */ adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
	            var /** @type {?} */ currentIndex = record.currentIndex;
	            // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	            if (record === nextRemove) {
	                addRemoveOffset--;
	                nextRemove = nextRemove._nextRemoved;
	            }
	            else {
	                nextIt = ((nextIt))._next;
	                if (record.previousIndex == null) {
	                    addRemoveOffset++;
	                }
	                else {
	                    // INVARIANT:  currentIndex < previousIndex
	                    if (!moveOffsets)
	                        moveOffsets = [];
	                    var /** @type {?} */ localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
	                    var /** @type {?} */ localCurrentIndex = ((currentIndex)) - addRemoveOffset;
	                    if (localMovePreviousIndex != localCurrentIndex) {
	                        for (var /** @type {?} */ i = 0; i < localMovePreviousIndex; i++) {
	                            var /** @type {?} */ offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
	                            var /** @type {?} */ index = offset + i;
	                            if (localCurrentIndex <= index && index < localMovePreviousIndex) {
	                                moveOffsets[i] = offset + 1;
	                            }
	                        }
	                        var /** @type {?} */ previousIndex = record.previousIndex;
	                        moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
	                    }
	                }
	            }
	            if (adjPreviousIndex !== currentIndex) {
	                fn(record, adjPreviousIndex, currentIndex);
	            }
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._movesHead; record !== null; record = record._nextMoved) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} collection
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.diff = function (collection) {
	        if (collection == null)
	            collection = [];
	        if (!isListLikeIterable(collection)) {
	            throw new Error("Error trying to diff '" + stringify(collection) + "'. Only arrays and iterables are allowed");
	        }
	        if (this.check(collection)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.onDestroy = function () { };
	    /**
	     * @param {?} collection
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.check = function (collection) {
	        var _this = this;
	        this._reset();
	        var /** @type {?} */ record = this._itHead;
	        var /** @type {?} */ mayBeDirty = false;
	        var /** @type {?} */ index;
	        var /** @type {?} */ item;
	        var /** @type {?} */ itemTrackBy;
	        if (Array.isArray(collection)) {
	            this._length = collection.length;
	            for (var /** @type {?} */ index_1 = 0; index_1 < this._length; index_1++) {
	                item = collection[index_1];
	                itemTrackBy = this._trackByFn(index_1, item);
	                if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                    record = this._mismatch(record, item, itemTrackBy, index_1);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
	                    }
	                    if (!looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                }
	                record = record._next;
	            }
	        }
	        else {
	            index = 0;
	            iterateListLike(collection, function (item) {
	                itemTrackBy = _this._trackByFn(index, item);
	                if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                    record = _this._mismatch(record, item, itemTrackBy, index);
	                    mayBeDirty = true;
	                }
	                else {
	                    if (mayBeDirty) {
	                        // TODO(misko): can we limit this to duplicates only?
	                        record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                    }
	                    if (!looseIdentical(record.item, item))
	                        _this._addIdentityChange(record, item);
	                }
	                record = record._next;
	                index++;
	            });
	            this._length = index;
	        }
	        this._truncate(record);
	        this._collection = collection;
	        return this.isDirty;
	    };
	    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this._additionsHead !== null || this._movesHead !== null ||
	                this._removalsHead !== null || this._identityChangesHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Reset the state of the change objects to show no changes. This means set previousKey to
	     * currentKey, and clear all of the queues (additions, moves, removals).
	     * Set the previousIndexes of moved and added items to their currentIndexes
	     * Reset the list of additions, moves and removals
	     *
	     * \@internal
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var /** @type {?} */ record = void 0;
	            var /** @type {?} */ nextRecord = void 0;
	            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                record.previousIndex = record.currentIndex;
	            }
	            this._additionsHead = this._additionsTail = null;
	            for (record = this._movesHead; record !== null; record = nextRecord) {
	                record.previousIndex = record.currentIndex;
	                nextRecord = record._nextMoved;
	            }
	            this._movesHead = this._movesTail = null;
	            this._removalsHead = this._removalsTail = null;
	            this._identityChangesHead = this._identityChangesTail = null;
	        }
	    };
	    /**
	     * This is the core function which handles differences between collections.
	     *
	     * - `record` is the record which we saw at this position last time. If null then it is a new
	     *   item.
	     * - `item` is the current item in the collection
	     * - `index` is the position of the item in the collection
	     *
	     * \@internal
	     * @param {?} record
	     * @param {?} item
	     * @param {?} itemTrackBy
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	        // The previous record after which we will append the current one.
	        var /** @type {?} */ previousRecord;
	        if (record === null) {
	            previousRecord = ((this._itTail));
	        }
	        else {
	            previousRecord = ((record._prev));
	            // Remove the record from the collection since we know it does not match the item.
	            this._remove(record);
	        }
	        // Attempt to see if we have seen the item before.
	        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	        if (record !== null) {
	            // We have seen this before, we need to move it forward in the collection.
	            // But first we need to check if identity changed, so we can update in view if necessary
	            if (!looseIdentical(record.item, item))
	                this._addIdentityChange(record, item);
	            this._moveAfter(record, previousRecord, index);
	        }
	        else {
	            // Never seen it, check evicted list.
	            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
	            if (record !== null) {
	                // It is an item which we have evicted earlier: reinsert it back into the list.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._reinsertAfter(record, previousRecord, index);
	            }
	            else {
	                // It is a new item: add it.
	                record =
	                    this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
	            }
	        }
	        return record;
	    };
	    /**
	     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	     *
	     * Use case: `[a, a]` => `[b, a, a]`
	     *
	     * If we did not have this check then the insertion of `b` would:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) leave `a` at index `1` as is. <-- this is wrong!
	     *   3) reinsert `a` at index 2. <-- this is wrong!
	     *
	     * The correct behavior is:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) reinsert `a` at index 1.
	     *   3) move `a` at from `1` to `2`.
	     *
	     *
	     * Double check that we have not evicted a duplicate item. We need to check if the item type may
	     * have already been removed:
	     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	     * at the end.
	     *
	     * \@internal
	     * @param {?} record
	     * @param {?} item
	     * @param {?} itemTrackBy
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	        var /** @type {?} */ reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
	        if (reinsertRecord !== null) {
	            record = this._reinsertAfter(reinsertRecord, /** @type {?} */ ((record._prev)), index);
	        }
	        else if (record.currentIndex != index) {
	            record.currentIndex = index;
	            this._addToMoves(record, index);
	        }
	        return record;
	    };
	    /**
	     * Get rid of any excess {\@link IterableChangeRecord_}s from the previous collection
	     *
	     * - `record` The first excess {\@link IterableChangeRecord_}.
	     *
	     * \@internal
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._truncate = function (record) {
	        // Anything after that needs to be removed;
	        while (record !== null) {
	            var /** @type {?} */ nextRecord = record._next;
	            this._addToRemovals(this._unlink(record));
	            record = nextRecord;
	        }
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.clear();
	        }
	        if (this._additionsTail !== null) {
	            this._additionsTail._nextAdded = null;
	        }
	        if (this._movesTail !== null) {
	            this._movesTail._nextMoved = null;
	        }
	        if (this._itTail !== null) {
	            this._itTail._next = null;
	        }
	        if (this._removalsTail !== null) {
	            this._removalsTail._nextRemoved = null;
	        }
	        if (this._identityChangesTail !== null) {
	            this._identityChangesTail._nextIdentityChange = null;
	        }
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.remove(record);
	        }
	        var /** @type {?} */ prev = record._prevRemoved;
	        var /** @type {?} */ next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	        this._unlink(record);
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	        this._insertAfter(record, prevRecord, index);
	        if (this._additionsTail === null) {
	            // todo(vicb)
	            // assert(this._additionsHead === null);
	            this._additionsTail = this._additionsHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_additionsTail._nextAdded === null);
	            // assert(record._nextAdded === null);
	            this._additionsTail = this._additionsTail._nextAdded = record;
	        }
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} prevRecord
	     * @param {?} index
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	        // todo(vicb)
	        // assert(record != prevRecord);
	        // assert(record._next === null);
	        // assert(record._prev === null);
	        var /** @type {?} */ next = prevRecord === null ? this._itHead : prevRecord._next;
	        // todo(vicb)
	        // assert(next != record);
	        // assert(prevRecord != record);
	        record._next = next;
	        record._prev = prevRecord;
	        if (next === null) {
	            this._itTail = record;
	        }
	        else {
	            next._prev = record;
	        }
	        if (prevRecord === null) {
	            this._itHead = record;
	        }
	        else {
	            prevRecord._next = record;
	        }
	        if (this._linkedRecords === null) {
	            this._linkedRecords = new _DuplicateMap();
	        }
	        this._linkedRecords.put(record);
	        record.currentIndex = index;
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._remove = function (record) {
	        return this._addToRemovals(this._unlink(record));
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._unlink = function (record) {
	        if (this._linkedRecords !== null) {
	            this._linkedRecords.remove(record);
	        }
	        var /** @type {?} */ prev = record._prev;
	        var /** @type {?} */ next = record._next;
	        // todo(vicb)
	        // assert((record._prev = null) === null);
	        // assert((record._next = null) === null);
	        if (prev === null) {
	            this._itHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        if (next === null) {
	            this._itTail = prev;
	        }
	        else {
	            next._prev = prev;
	        }
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} toIndex
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	        // todo(vicb)
	        // assert(record._nextMoved === null);
	        if (record.previousIndex === toIndex) {
	            return record;
	        }
	        if (this._movesTail === null) {
	            // todo(vicb)
	            // assert(_movesHead === null);
	            this._movesTail = this._movesHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_movesTail._nextMoved === null);
	            this._movesTail = this._movesTail._nextMoved = record;
	        }
	        return record;
	    };
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	        if (this._unlinkedRecords === null) {
	            this._unlinkedRecords = new _DuplicateMap();
	        }
	        this._unlinkedRecords.put(record);
	        record.currentIndex = null;
	        record._nextRemoved = null;
	        if (this._removalsTail === null) {
	            // todo(vicb)
	            // assert(_removalsHead === null);
	            this._removalsTail = this._removalsHead = record;
	            record._prevRemoved = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(_removalsTail._nextRemoved === null);
	            // assert(record._nextRemoved === null);
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = this._removalsTail._nextRemoved = record;
	        }
	        return record;
	    };
	    /**
	     * \@internal
	     * @param {?} record
	     * @param {?} item
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	        record.item = item;
	        if (this._identityChangesTail === null) {
	            this._identityChangesTail = this._identityChangesHead = record;
	        }
	        else {
	            this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	        }
	        return record;
	    };
	    /**
	     * @return {?}
	     */
	    DefaultIterableDiffer.prototype.toString = function () {
	        var /** @type {?} */ list = [];
	        this.forEachItem(function (record) { return list.push(record); });
	        var /** @type {?} */ previous = [];
	        this.forEachPreviousItem(function (record) { return previous.push(record); });
	        var /** @type {?} */ additions = [];
	        this.forEachAddedItem(function (record) { return additions.push(record); });
	        var /** @type {?} */ moves = [];
	        this.forEachMovedItem(function (record) { return moves.push(record); });
	        var /** @type {?} */ removals = [];
	        this.forEachRemovedItem(function (record) { return removals.push(record); });
	        var /** @type {?} */ identityChanges = [];
	        this.forEachIdentityChange(function (record) { return identityChanges.push(record); });
	        return 'collection: ' + list.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'moves: ' + moves.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n' +
	            'identityChanges: ' + identityChanges.join(', ') + '\n';
	    };
	    return DefaultIterableDiffer;
	}());
	/**
	 * \@stable
	 */
	var IterableChangeRecord_ = (function () {
	    /**
	     * @param {?} item
	     * @param {?} trackById
	     */
	    function IterableChangeRecord_(item, trackById) {
	        this.item = item;
	        this.trackById = trackById;
	        this.currentIndex = null;
	        this.previousIndex = null;
	        /**
	         * \@internal
	         */
	        this._nextPrevious = null;
	        /**
	         * \@internal
	         */
	        this._prev = null;
	        /**
	         * \@internal
	         */
	        this._next = null;
	        /**
	         * \@internal
	         */
	        this._prevDup = null;
	        /**
	         * \@internal
	         */
	        this._nextDup = null;
	        /**
	         * \@internal
	         */
	        this._prevRemoved = null;
	        /**
	         * \@internal
	         */
	        this._nextRemoved = null;
	        /**
	         * \@internal
	         */
	        this._nextAdded = null;
	        /**
	         * \@internal
	         */
	        this._nextMoved = null;
	        /**
	         * \@internal
	         */
	        this._nextIdentityChange = null;
	    }
	    /**
	     * @return {?}
	     */
	    IterableChangeRecord_.prototype.toString = function () {
	        return this.previousIndex === this.currentIndex ? stringify(this.item) :
	            stringify(this.item) + '[' +
	                stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
	    };
	    return IterableChangeRecord_;
	}());
	var _DuplicateItemRecordList = (function () {
	    function _DuplicateItemRecordList() {
	        /**
	         * \@internal
	         */
	        this._head = null;
	        /**
	         * \@internal
	         */
	        this._tail = null;
	    }
	    /**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateItemRecordList.prototype.add = function (record) {
	        if (this._head === null) {
	            this._head = this._tail = record;
	            record._nextDup = null;
	            record._prevDup = null;
	        }
	        else {
	            ((
	            // todo(vicb)
	            // assert(record.item ==  _head.item ||
	            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	            this._tail))._nextDup = record;
	            record._prevDup = this._tail;
	            record._nextDup = null;
	            this._tail = record;
	        }
	    };
	    /**
	     * @param {?} trackById
	     * @param {?} afterIndex
	     * @return {?}
	     */
	    _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
	        var /** @type {?} */ record;
	        for (record = this._head; record !== null; record = record._nextDup) {
	            if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                looseIdentical(record.trackById, trackById)) {
	                return record;
	            }
	        }
	        return null;
	    };
	    /**
	     * Remove one {\@link IterableChangeRecord_} from the list of duplicates.
	     *
	     * Returns whether the list of duplicates is empty.
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateItemRecordList.prototype.remove = function (record) {
	        // todo(vicb)
	        // assert(() {
	        //  // verify that the record being removed is in the list.
	        //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
	        //    if (identical(cursor, record)) return true;
	        //  }
	        //  return false;
	        //});
	        var /** @type {?} */ prev = record._prevDup;
	        var /** @type {?} */ next = record._nextDup;
	        if (prev === null) {
	            this._head = next;
	        }
	        else {
	            prev._nextDup = next;
	        }
	        if (next === null) {
	            this._tail = prev;
	        }
	        else {
	            next._prevDup = prev;
	        }
	        return this._head === null;
	    };
	    return _DuplicateItemRecordList;
	}());
	var _DuplicateMap = (function () {
	    function _DuplicateMap() {
	        this.map = new Map();
	    }
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateMap.prototype.put = function (record) {
	        var /** @type {?} */ key = record.trackById;
	        var /** @type {?} */ duplicates = this.map.get(key);
	        if (!duplicates) {
	            duplicates = new _DuplicateItemRecordList();
	            this.map.set(key, duplicates);
	        }
	        duplicates.add(record);
	    };
	    /**
	     * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
	     * have already iterated over, we use the afterIndex to pretend it is not there.
	     *
	     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	     * have any more `a`s needs to return the last `a` not the first or second.
	     * @param {?} trackById
	     * @param {?} afterIndex
	     * @return {?}
	     */
	    _DuplicateMap.prototype.get = function (trackById, afterIndex) {
	        var /** @type {?} */ key = trackById;
	        var /** @type {?} */ recordList = this.map.get(key);
	        return recordList ? recordList.get(trackById, afterIndex) : null;
	    };
	    /**
	     * Removes a {\@link IterableChangeRecord_} from the list of duplicates.
	     *
	     * The list of duplicates also is removed from the map if it gets empty.
	     * @param {?} record
	     * @return {?}
	     */
	    _DuplicateMap.prototype.remove = function (record) {
	        var /** @type {?} */ key = record.trackById;
	        var /** @type {?} */ recordList = ((this.map.get(key)));
	        // Remove the list of duplicates when it gets empty
	        if (recordList.remove(record)) {
	            this.map.delete(key);
	        }
	        return record;
	    };
	    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.map.size === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	    /**
	     * @return {?}
	     */
	    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
	    return _DuplicateMap;
	}());
	/**
	 * @param {?} item
	 * @param {?} addRemoveOffset
	 * @param {?} moveOffsets
	 * @return {?}
	 */
	function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
	    var /** @type {?} */ previousIndex = item.previousIndex;
	    if (previousIndex === null)
	        return previousIndex;
	    var /** @type {?} */ moveOffset = 0;
	    if (moveOffsets && previousIndex < moveOffsets.length) {
	        moveOffset = moveOffsets[previousIndex];
	    }
	    return previousIndex + addRemoveOffset + moveOffset;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var DefaultKeyValueDifferFactory = (function () {
	    function DefaultKeyValueDifferFactory() {
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
	    /**
	     * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
	     * @template K, V
	     * @param {?=} cd
	     * @return {?}
	     */
	    DefaultKeyValueDifferFactory.prototype.create = function (cd) {
	        return new DefaultKeyValueDiffer();
	    };
	    return DefaultKeyValueDifferFactory;
	}());
	var DefaultKeyValueDiffer = (function () {
	    function DefaultKeyValueDiffer() {
	        this._records = new Map();
	        this._mapHead = null;
	        this._appendAfter = null;
	        this._previousMapHead = null;
	        this._changesHead = null;
	        this._changesTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }
	    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this._additionsHead !== null || this._changesHead !== null ||
	                this._removalsHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	        var /** @type {?} */ record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    /**
	     * @param {?=} map
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.diff = function (map) {
	        if (!map) {
	            map = new Map();
	        }
	        else if (!(map instanceof Map || isJsObject(map))) {
	            throw new Error("Error trying to diff '" + stringify(map) + "'. Only maps and objects are allowed");
	        }
	        return this.check(map) ? this : null;
	    };
	    /**
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	    /**
	     * Check the current state of the map vs the previous.
	     * The algorithm is optimised for when the keys do no change.
	     * @param {?} map
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.check = function (map) {
	        var _this = this;
	        this._reset();
	        var /** @type {?} */ insertBefore = this._mapHead;
	        this._appendAfter = null;
	        this._forEach(map, function (value, key) {
	            if (insertBefore && insertBefore.key === key) {
	                _this._maybeAddToChanges(insertBefore, value);
	                _this._appendAfter = insertBefore;
	                insertBefore = insertBefore._next;
	            }
	            else {
	                var /** @type {?} */ record = _this._getOrCreateRecordForKey(key, value);
	                insertBefore = _this._insertBeforeOrAppend(insertBefore, record);
	            }
	        });
	        // Items remaining at the end of the list have been deleted
	        if (insertBefore) {
	            if (insertBefore._prev) {
	                insertBefore._prev._next = null;
	            }
	            this._removalsHead = insertBefore;
	            for (var /** @type {?} */ record = insertBefore; record !== null; record = record._nextRemoved) {
	                if (record === this._mapHead) {
	                    this._mapHead = null;
	                }
	                this._records.delete(record.key);
	                record._nextRemoved = record._next;
	                record.previousValue = record.currentValue;
	                record.currentValue = null;
	                record._prev = null;
	                record._next = null;
	            }
	        }
	        // Make sure tails have no next records from previous runs
	        if (this._changesTail)
	            this._changesTail._nextChanged = null;
	        if (this._additionsTail)
	            this._additionsTail._nextAdded = null;
	        return this.isDirty;
	    };
	    /**
	     * Inserts a record before `before` or append at the end of the list when `before` is null.
	     *
	     * Notes:
	     * - This method appends at `this._appendAfter`,
	     * - This method updates `this._appendAfter`,
	     * - The return value is the new value for the insertion pointer.
	     * @param {?} before
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._insertBeforeOrAppend = function (before, record) {
	        if (before) {
	            var /** @type {?} */ prev = before._prev;
	            record._next = before;
	            record._prev = prev;
	            before._prev = record;
	            if (prev) {
	                prev._next = record;
	            }
	            if (before === this._mapHead) {
	                this._mapHead = record;
	            }
	            this._appendAfter = before;
	            return before;
	        }
	        if (this._appendAfter) {
	            this._appendAfter._next = record;
	            record._prev = this._appendAfter;
	        }
	        else {
	            this._mapHead = record;
	        }
	        this._appendAfter = record;
	        return null;
	    };
	    /**
	     * @param {?} key
	     * @param {?} value
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._getOrCreateRecordForKey = function (key, value) {
	        if (this._records.has(key)) {
	            var /** @type {?} */ record_1 = ((this._records.get(key)));
	            this._maybeAddToChanges(record_1, value);
	            var /** @type {?} */ prev = record_1._prev;
	            var /** @type {?} */ next = record_1._next;
	            if (prev) {
	                prev._next = next;
	            }
	            if (next) {
	                next._prev = prev;
	            }
	            record_1._next = null;
	            record_1._prev = null;
	            return record_1;
	        }
	        var /** @type {?} */ record = new KeyValueChangeRecord_(key);
	        this._records.set(key, record);
	        record.currentValue = value;
	        this._addToAdditions(record);
	        return record;
	    };
	    /**
	     * \@internal
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var /** @type {?} */ record = void 0;
	            // let `_previousMapHead` contain the state of the map before the changes
	            this._previousMapHead = this._mapHead;
	            for (record = this._previousMapHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            // Update `record.previousValue` with the value of the item before the changes
	            // We need to update all changed items (that's those which have been added and changed)
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                record.previousValue = record.currentValue;
	            }
	            for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                record.previousValue = record.currentValue;
	            }
	            this._changesHead = this._changesTail = null;
	            this._additionsHead = this._additionsTail = null;
	            this._removalsHead = null;
	        }
	    };
	    /**
	     * @param {?} record
	     * @param {?} newValue
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
	        if (!looseIdentical(newValue, record.currentValue)) {
	            record.previousValue = record.currentValue;
	            record.currentValue = newValue;
	            this._addToChanges(record);
	        }
	    };
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	        if (this._additionsHead === null) {
	            this._additionsHead = this._additionsTail = record;
	        }
	        else {
	            ((this._additionsTail))._nextAdded = record;
	            this._additionsTail = record;
	        }
	    };
	    /**
	     * @param {?} record
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	        if (this._changesHead === null) {
	            this._changesHead = this._changesTail = record;
	        }
	        else {
	            ((this._changesTail))._nextChanged = record;
	            this._changesTail = record;
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype.toString = function () {
	        var /** @type {?} */ items = [];
	        var /** @type {?} */ previous = [];
	        var /** @type {?} */ changes = [];
	        var /** @type {?} */ additions = [];
	        var /** @type {?} */ removals = [];
	        this.forEachItem(function (r) { return items.push(stringify(r)); });
	        this.forEachPreviousItem(function (r) { return previous.push(stringify(r)); });
	        this.forEachChangedItem(function (r) { return changes.push(stringify(r)); });
	        this.forEachAddedItem(function (r) { return additions.push(stringify(r)); });
	        this.forEachRemovedItem(function (r) { return removals.push(stringify(r)); });
	        return 'map: ' + items.join(', ') + '\n' +
	            'previous: ' + previous.join(', ') + '\n' +
	            'additions: ' + additions.join(', ') + '\n' +
	            'changes: ' + changes.join(', ') + '\n' +
	            'removals: ' + removals.join(', ') + '\n';
	    };
	    /**
	     * \@internal
	     * @template K, V
	     * @param {?} obj
	     * @param {?} fn
	     * @return {?}
	     */
	    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	        if (obj instanceof Map) {
	            obj.forEach(fn);
	        }
	        else {
	            Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
	        }
	    };
	    return DefaultKeyValueDiffer;
	}());
	/**
	 * \@stable
	 */
	var KeyValueChangeRecord_ = (function () {
	    /**
	     * @param {?} key
	     */
	    function KeyValueChangeRecord_(key) {
	        this.key = key;
	        this.previousValue = null;
	        this.currentValue = null;
	        /**
	         * \@internal
	         */
	        this._nextPrevious = null;
	        /**
	         * \@internal
	         */
	        this._next = null;
	        /**
	         * \@internal
	         */
	        this._prev = null;
	        /**
	         * \@internal
	         */
	        this._nextAdded = null;
	        /**
	         * \@internal
	         */
	        this._nextRemoved = null;
	        /**
	         * \@internal
	         */
	        this._nextChanged = null;
	    }
	    /**
	     * @return {?}
	     */
	    KeyValueChangeRecord_.prototype.toString = function () {
	        return looseIdentical(this.previousValue, this.currentValue) ?
	            stringify(this.key) :
	            (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
	                stringify(this.currentValue) + ']');
	    };
	    return KeyValueChangeRecord_;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 * \@stable
	 */
	var IterableDiffers = (function () {
	    /**
	     * @param {?} factories
	     */
	    function IterableDiffers(factories) {
	        this.factories = factories;
	    }
	    /**
	     * @param {?} factories
	     * @param {?=} parent
	     * @return {?}
	     */
	    IterableDiffers.create = function (factories, parent) {
	        if (parent != null) {
	            var /** @type {?} */ copied = parent.factories.slice();
	            factories = factories.concat(copied);
	            return new IterableDiffers(factories);
	        }
	        else {
	            return new IterableDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
	     * inherited {\@link IterableDiffers} instance with the provided factories and return a new
	     * {\@link IterableDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	     * which will only be applied to the injector for this component and its children.
	     * This step is all that's required to make a new {\@link IterableDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * \@Component({
	     *   viewProviders: [
	     *     IterableDiffers.extend([new ImmutableListDiffer()])
	     *   ]
	     * })
	     * ```
	     * @param {?} factories
	     * @return {?}
	     */
	    IterableDiffers.extend = function (factories) {
	        return {
	            provide: IterableDiffers,
	            useFactory: function (parent) {
	                if (!parent) {
	                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new Error('Cannot extend IterableDiffers without a parent injector');
	                }
	                return IterableDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
	        };
	    };
	    /**
	     * @param {?} iterable
	     * @return {?}
	     */
	    IterableDiffers.prototype.find = function (iterable) {
	        var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(iterable); });
	        if (factory != null) {
	            return factory;
	        }
	        else {
	            throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
	        }
	    };
	    return IterableDiffers;
	}());
	/**
	 * @param {?} type
	 * @return {?}
	 */
	function getTypeNameForDebugging(type) {
	    return type['name'] || typeof type;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 * \@stable
	 */
	var KeyValueDiffers = (function () {
	    /**
	     * @param {?} factories
	     */
	    function KeyValueDiffers(factories) {
	        this.factories = factories;
	    }
	    /**
	     * @template S
	     * @param {?} factories
	     * @param {?=} parent
	     * @return {?}
	     */
	    KeyValueDiffers.create = function (factories, parent) {
	        if (parent) {
	            var /** @type {?} */ copied = parent.factories.slice();
	            factories = factories.concat(copied);
	        }
	        return new KeyValueDiffers(factories);
	    };
	    /**
	     * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
	     * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
	     * {\@link KeyValueDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	     * which will only be applied to the injector for this component and its children.
	     * This step is all that's required to make a new {\@link KeyValueDiffer} available.
	     *
	     * ### Example
	     *
	     * ```
	     * \@Component({
	     *   viewProviders: [
	     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	     *   ]
	     * })
	     * ```
	     * @template S
	     * @param {?} factories
	     * @return {?}
	     */
	    KeyValueDiffers.extend = function (factories) {
	        return {
	            provide: KeyValueDiffers,
	            useFactory: function (parent) {
	                if (!parent) {
	                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                    // to bootstrap(), which would override default pipes instead of extending them.
	                    throw new Error('Cannot extend KeyValueDiffers without a parent injector');
	                }
	                return KeyValueDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
	        };
	    };
	    /**
	     * @param {?} kv
	     * @return {?}
	     */
	    KeyValueDiffers.prototype.find = function (kv) {
	        var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(kv); });
	        if (factory) {
	            return factory;
	        }
	        throw new Error("Cannot find a differ supporting object '" + kv + "'");
	    };
	    return KeyValueDiffers;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	var keyValDiff = [new DefaultKeyValueDifferFactory()];
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	var iterableDiff = [new DefaultIterableDifferFactory()];
	var defaultIterableDiffers = new IterableDiffers(iterableDiff);
	var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @module
	 * @description
	 * Change detection enables data binding in Angular.
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @return {?}
	 */
	function _reflector() {
	    return reflector;
	}
	var _CORE_PLATFORM_PROVIDERS = [
	    // Set a default platform name for platforms that don't set it explicitly.
	    { provide: PLATFORM_ID, useValue: 'unknown' },
	    PlatformRef_,
	    { provide: PlatformRef, useExisting: PlatformRef_ },
	    { provide: Reflector, useFactory: _reflector, deps: [] },
	    { provide: ReflectorReader, useExisting: Reflector },
	    TestabilityRegistry,
	    Console,
	];
	/**
	 * This platform has to be included in any other platform
	 *
	 * \@experimental
	 */
	var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@experimental i18n support is experimental.
	 */
	var LOCALE_ID = new InjectionToken('LocaleId');
	/**
	 * \@experimental i18n support is experimental.
	 */
	var TRANSLATIONS = new InjectionToken('Translations');
	/**
	 * \@experimental i18n support is experimental.
	 */
	var TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
	var MissingTranslationStrategy = {};
	MissingTranslationStrategy.Error = 0;
	MissingTranslationStrategy.Warning = 1;
	MissingTranslationStrategy.Ignore = 2;
	MissingTranslationStrategy[MissingTranslationStrategy.Error] = "Error";
	MissingTranslationStrategy[MissingTranslationStrategy.Warning] = "Warning";
	MissingTranslationStrategy[MissingTranslationStrategy.Ignore] = "Ignore";
	var SecurityContext = {};
	SecurityContext.NONE = 0;
	SecurityContext.HTML = 1;
	SecurityContext.STYLE = 2;
	SecurityContext.SCRIPT = 3;
	SecurityContext.URL = 4;
	SecurityContext.RESOURCE_URL = 5;
	SecurityContext[SecurityContext.NONE] = "NONE";
	SecurityContext[SecurityContext.HTML] = "HTML";
	SecurityContext[SecurityContext.STYLE] = "STYLE";
	SecurityContext[SecurityContext.SCRIPT] = "SCRIPT";
	SecurityContext[SecurityContext.URL] = "URL";
	SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL";
	/**
	 * Sanitizer is used by the views to sanitize potentially dangerous values.
	 *
	 * \@stable
	 * @abstract
	 */
	var Sanitizer = (function () {
	    function Sanitizer() {
	    }
	    /**
	     * @abstract
	     * @param {?} context
	     * @param {?} value
	     * @return {?}
	     */
	    Sanitizer.prototype.sanitize = function (context, value) { };
	    return Sanitizer;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Node instance data.
	 *
	 * We have a separate type per NodeType to save memory
	 * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)
	 *
	 * To keep our code monomorphic,
	 * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).
	 * This way, no usage site can get a `NodeData` from view.nodes and then use it for different
	 * purposes.
	 */
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asTextData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asElementData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asProviderData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asPureExpressionData(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function asQueryList(view, index) {
	    return (view.nodes[index]);
	}
	/**
	 * @abstract
	 */
	var DebugContext = (function () {
	    function DebugContext() {
	    }
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.view = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.nodeIndex = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.injector = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.component = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.providerTokens = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.references = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.context = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.componentRenderElement = function () { };
	    /**
	     * @abstract
	     * @return {?}
	     */
	    DebugContext.prototype.renderNode = function () { };
	    /**
	     * @abstract
	     * @param {?} console
	     * @param {...?} values
	     * @return {?}
	     */
	    DebugContext.prototype.logError = function (console) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	    };
	    return DebugContext;
	}());
	/**
	 * This object is used to prevent cycles in the source files and to have a place where
	 * debug mode can hook it. It is lazily filled when `isDevMode` is known.
	 */
	var Services = {
	    setCurrentNode: /** @type {?} */ ((undefined)),
	    createRootView: /** @type {?} */ ((undefined)),
	    createEmbeddedView: /** @type {?} */ ((undefined)),
	    checkAndUpdateView: /** @type {?} */ ((undefined)),
	    checkNoChangesView: /** @type {?} */ ((undefined)),
	    destroyView: /** @type {?} */ ((undefined)),
	    resolveDep: /** @type {?} */ ((undefined)),
	    createDebugContext: /** @type {?} */ ((undefined)),
	    handleEvent: /** @type {?} */ ((undefined)),
	    updateDirectives: /** @type {?} */ ((undefined)),
	    updateRenderer: /** @type {?} */ ((undefined)),
	    dirtyParentQueries: /** @type {?} */ ((undefined)),
	};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} context
	 * @param {?} oldValue
	 * @param {?} currValue
	 * @param {?} isFirstCheck
	 * @return {?}
	 */
	function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {
	    var /** @type {?} */ msg = "ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
	    if (isFirstCheck) {
	        msg +=
	            " It seems like the view has been created after its parent and its children have been dirty checked." +
	                " Has it been created in a change detection hook ?";
	    }
	    return viewDebugError(msg, context);
	}
	/**
	 * @param {?} err
	 * @param {?} context
	 * @return {?}
	 */
	function viewWrappedDebugError(err, context) {
	    if (!(err instanceof Error)) {
	        // errors that are not Error instances don't have a stack,
	        // so it is ok to wrap them into a new Error object...
	        err = new Error(err.toString());
	    }
	    _addDebugContext(err, context);
	    return err;
	}
	/**
	 * @param {?} msg
	 * @param {?} context
	 * @return {?}
	 */
	function viewDebugError(msg, context) {
	    var /** @type {?} */ err = new Error(msg);
	    _addDebugContext(err, context);
	    return err;
	}
	/**
	 * @param {?} err
	 * @param {?} context
	 * @return {?}
	 */
	function _addDebugContext(err, context) {
	    ((err))[ERROR_DEBUG_CONTEXT] = context;
	    ((err))[ERROR_LOGGER] = context.logError.bind(context);
	}
	/**
	 * @param {?} err
	 * @return {?}
	 */
	function isViewDebugError(err) {
	    return !!getDebugContext(err);
	}
	/**
	 * @param {?} action
	 * @return {?}
	 */
	function viewDestroyedError(action) {
	    return new Error("ViewDestroyedError: Attempt to use a destroyed view: " + action);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NOOP = function () { };
	var _tokenKeyCache = new Map();
	/**
	 * @param {?} token
	 * @return {?}
	 */
	function tokenKey(token) {
	    var /** @type {?} */ key = _tokenKeyCache.get(token);
	    if (!key) {
	        key = stringify(token) + '_' + _tokenKeyCache.size;
	        _tokenKeyCache.set(token, key);
	    }
	    return key;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIdx
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function unwrapValue(view, nodeIdx, bindingIdx, value) {
	    if (value instanceof WrappedValue) {
	        value = value.wrapped;
	        var /** @type {?} */ globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;
	        var /** @type {?} */ oldValue = view.oldValues[globalBindingIdx];
	        if (oldValue instanceof WrappedValue) {
	            oldValue = oldValue.wrapped;
	        }
	        view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);
	    }
	    return value;
	}
	var UNDEFINED_RENDERER_TYPE_ID = '$$undefined';
	var EMPTY_RENDERER_TYPE_ID = '$$empty';
	/**
	 * @param {?} values
	 * @return {?}
	 */
	function createRendererType2(values) {
	    return {
	        id: UNDEFINED_RENDERER_TYPE_ID,
	        styles: values.styles,
	        encapsulation: values.encapsulation,
	        data: values.data
	    };
	}
	var _renderCompCount = 0;
	/**
	 * @param {?=} type
	 * @return {?}
	 */
	function resolveRendererType2(type) {
	    if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {
	        // first time we see this RendererType2. Initialize it...
	        var /** @type {?} */ isFilled = ((type.encapsulation != null && type.encapsulation !== ViewEncapsulation.None) ||
	            type.styles.length || Object.keys(type.data).length);
	        if (isFilled) {
	            type.id = "c" + _renderCompCount++;
	        }
	        else {
	            type.id = EMPTY_RENDERER_TYPE_ID;
	        }
	    }
	    if (type && type.id === EMPTY_RENDERER_TYPE_ID) {
	        type = null;
	    }
	    return type || null;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkBinding(view, def, bindingIdx, value) {
	    var /** @type {?} */ oldValues = view.oldValues;
	    if ((view.state & 1 /* FirstCheck */) ||
	        !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {
	        return true;
	    }
	    return false;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkAndUpdateBinding(view, def, bindingIdx, value) {
	    if (checkBinding(view, def, bindingIdx, value)) {
	        view.oldValues[def.bindingIndex + bindingIdx] = value;
	        return true;
	    }
	    return false;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkBindingNoChanges(view, def, bindingIdx, value) {
	    var /** @type {?} */ oldValue = view.oldValues[def.bindingIndex + bindingIdx];
	    if ((view.state & 1 /* FirstCheck */) || !devModeEqual(oldValue, value)) {
	        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.index), oldValue, value, (view.state & 1 /* FirstCheck */) !== 0);
	    }
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function markParentViewsForCheck(view) {
	    var /** @type {?} */ currView = view;
	    while (currView) {
	        if (currView.def.flags & 2 /* OnPush */) {
	            currView.state |= 2 /* ChecksEnabled */;
	        }
	        currView = currView.viewContainerParent || currView.parent;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} eventName
	 * @param {?} event
	 * @return {?}
	 */
	function dispatchEvent(view, nodeIndex, eventName, event) {
	    var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	    var /** @type {?} */ startView = nodeDef.flags & 16777216 /* ComponentView */ ? asElementData(view, nodeIndex).componentView : view;
	    markParentViewsForCheck(startView);
	    return Services.handleEvent(view, nodeIndex, eventName, event);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function declaredViewContainer(view) {
	    if (view.parent) {
	        var /** @type {?} */ parentView = view.parent;
	        return asElementData(parentView, /** @type {?} */ ((view.parentNodeDef)).index);
	    }
	    return null;
	}
	/**
	 * for component views, this is the host element.
	 * for embedded views, this is the index of the parent node
	 * that contains the view container.
	 * @param {?} view
	 * @return {?}
	 */
	function viewParentEl(view) {
	    var /** @type {?} */ parentView = view.parent;
	    if (parentView) {
	        return ((view.parentNodeDef)).parent;
	    }
	    else {
	        return null;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function renderNode(view, def) {
	    switch (def.flags & 100673535 /* Types */) {
	        case 1 /* TypeElement */:
	            return asElementData(view, def.index).renderElement;
	        case 2 /* TypeText */:
	            return asTextData(view, def.index).renderText;
	    }
	}
	/**
	 * @param {?} target
	 * @param {?} name
	 * @return {?}
	 */
	function elementEventFullName(target, name) {
	    return target ? target + ":" + name : name;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function isComponentView(view) {
	    return !!view.parent && !!(((view.parentNodeDef)).flags & 16384 /* Component */);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function isEmbeddedView(view) {
	    return !!view.parent && !(((view.parentNodeDef)).flags & 16384 /* Component */);
	}
	/**
	 * @param {?} queryId
	 * @return {?}
	 */
	function filterQueryId(queryId) {
	    return 1 << (queryId % 32);
	}
	/**
	 * @param {?} matchedQueriesDsl
	 * @return {?}
	 */
	function splitMatchedQueriesDsl(matchedQueriesDsl) {
	    var /** @type {?} */ matchedQueries = {};
	    var /** @type {?} */ matchedQueryIds = 0;
	    var /** @type {?} */ references = {};
	    if (matchedQueriesDsl) {
	        matchedQueriesDsl.forEach(function (_a) {
	            var queryId = _a[0], valueType = _a[1];
	            if (typeof queryId === 'number') {
	                matchedQueries[queryId] = valueType;
	                matchedQueryIds |= filterQueryId(queryId);
	            }
	            else {
	                references[queryId] = valueType;
	            }
	        });
	    }
	    return { matchedQueries: matchedQueries, references: references, matchedQueryIds: matchedQueryIds };
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function getParentRenderElement(view, renderHost, def) {
	    var /** @type {?} */ renderParent = def.renderParent;
	    if (renderParent) {
	        if ((renderParent.flags & 1 /* TypeElement */) === 0 ||
	            (renderParent.flags & 16777216 /* ComponentView */) === 0 ||
	            (((renderParent.element)).componentRendererType && ((((renderParent.element)).componentRendererType)).encapsulation ===
	                ViewEncapsulation.Native)) {
	            // only children of non components, or children of components with native encapsulation should
	            // be attached.
	            return asElementData(view, /** @type {?} */ ((def.renderParent)).index).renderElement;
	        }
	    }
	    else {
	        return renderHost;
	    }
	}
	var VIEW_DEFINITION_CACHE = new WeakMap();
	/**
	 * @param {?} factory
	 * @return {?}
	 */
	function resolveViewDefinition(factory) {
	    var /** @type {?} */ value = ((VIEW_DEFINITION_CACHE.get(factory)));
	    if (!value) {
	        value = factory(function () { return NOOP; });
	        value.factory = factory;
	        VIEW_DEFINITION_CACHE.set(factory, value);
	    }
	    return value;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function rootRenderNodes(view) {
	    var /** @type {?} */ renderNodes = [];
	    visitRootRenderNodes(view, 0 /* Collect */, undefined, undefined, renderNodes);
	    return renderNodes;
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {
	    // We need to re-compute the parent node in case the nodes have been moved around manually
	    if (action === 3 /* RemoveChild */) {
	        parentNode = view.renderer.parentNode(renderNode(view, /** @type {?} */ ((view.def.lastRenderRootNode))));
	    }
	    visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @param {?} startIndex
	 * @param {?} endIndex
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {
	    for (var /** @type {?} */ i = startIndex; i <= endIndex; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if (nodeDef.flags & (1 /* TypeElement */ | 2 /* TypeText */ | 4 /* TypeNgContent */)) {
	            visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);
	        }
	        // jump to next sibling
	        i += nodeDef.childCount;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} ngContentIndex
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {
	    var /** @type {?} */ compView = view;
	    while (compView && !isComponentView(compView)) {
	        compView = compView.parent;
	    }
	    var /** @type {?} */ hostView = ((compView)).parent;
	    var /** @type {?} */ hostElDef = viewParentEl(/** @type {?} */ ((compView)));
	    var /** @type {?} */ startIndex = ((hostElDef)).index + 1;
	    var /** @type {?} */ endIndex = ((hostElDef)).index + ((hostElDef)).childCount;
	    for (var /** @type {?} */ i = startIndex; i <= endIndex; i++) {
	        var /** @type {?} */ nodeDef = ((hostView)).def.nodes[i];
	        if (nodeDef.ngContentIndex === ngContentIndex) {
	            visitRenderNode(/** @type {?} */ ((hostView)), nodeDef, action, parentNode, nextSibling, target);
	        }
	        // jump to next sibling
	        i += nodeDef.childCount;
	    }
	    if (!((hostView)).parent) {
	        // a root view
	        var /** @type {?} */ projectedNodes = view.root.projectableNodes[ngContentIndex];
	        if (projectedNodes) {
	            for (var /** @type {?} */ i = 0; i < projectedNodes.length; i++) {
	                execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);
	            }
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {
	    if (nodeDef.flags & 4 /* TypeNgContent */) {
	        visitProjectedRenderNodes(view, /** @type {?} */ ((nodeDef.ngContent)).index, action, parentNode, nextSibling, target);
	    }
	    else {
	        var /** @type {?} */ rn = renderNode(view, nodeDef);
	        if (action === 3 /* RemoveChild */ && (nodeDef.flags & 16777216 /* ComponentView */) &&
	            (nodeDef.bindingFlags & 48 /* CatSyntheticProperty */)) {
	            // Note: we might need to do both actions.
	            if (nodeDef.bindingFlags & (16 /* SyntheticProperty */)) {
	                execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
	            }
	            if (nodeDef.bindingFlags & (32 /* SyntheticHostProperty */)) {
	                var /** @type {?} */ compView = asElementData(view, nodeDef.index).componentView;
	                execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);
	            }
	        }
	        else {
	            execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
	        }
	        if (nodeDef.flags & 8388608 /* EmbeddedViews */) {
	            var /** @type {?} */ embeddedViews = ((asElementData(view, nodeDef.index).viewContainer))._embeddedViews;
	            for (var /** @type {?} */ k = 0; k < embeddedViews.length; k++) {
	                visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);
	            }
	        }
	        if (nodeDef.flags & 1 /* TypeElement */ && !((nodeDef.element)).name) {
	            visitSiblingRenderNodes(view, action, nodeDef.index + 1, nodeDef.index + nodeDef.childCount, parentNode, nextSibling, target);
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} renderNode
	 * @param {?} action
	 * @param {?} parentNode
	 * @param {?} nextSibling
	 * @param {?=} target
	 * @return {?}
	 */
	function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {
	    var /** @type {?} */ renderer = view.renderer;
	    switch (action) {
	        case 1 /* AppendChild */:
	            renderer.appendChild(parentNode, renderNode);
	            break;
	        case 2 /* InsertBefore */:
	            renderer.insertBefore(parentNode, renderNode, nextSibling);
	            break;
	        case 3 /* RemoveChild */:
	            renderer.removeChild(parentNode, renderNode);
	            break;
	        case 0 /* Collect */:
	            ((target)).push(renderNode);
	            break;
	    }
	}
	var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
	/**
	 * @param {?} name
	 * @return {?}
	 */
	function splitNamespace(name) {
	    if (name[0] === ':') {
	        var /** @type {?} */ match = ((name.match(NS_PREFIX_RE)));
	        return [match[1], match[2]];
	    }
	    return ['', name];
	}
	/**
	 * @param {?} bindings
	 * @return {?}
	 */
	function calcBindingFlags(bindings) {
	    var /** @type {?} */ flags = 0;
	    for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	        flags |= bindings[i].flags;
	    }
	    return flags;
	}
	/**
	 * @param {?} valueCount
	 * @param {?} constAndInterp
	 * @return {?}
	 */
	function interpolate(valueCount, constAndInterp) {
	    var /** @type {?} */ result = '';
	    for (var /** @type {?} */ i = 0; i < valueCount * 2; i = i + 2) {
	        result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
	    }
	    return result + constAndInterp[valueCount * 2];
	}
	/**
	 * @param {?} valueCount
	 * @param {?} c0
	 * @param {?} a1
	 * @param {?} c1
	 * @param {?=} a2
	 * @param {?=} c2
	 * @param {?=} a3
	 * @param {?=} c3
	 * @param {?=} a4
	 * @param {?=} c4
	 * @param {?=} a5
	 * @param {?=} c5
	 * @param {?=} a6
	 * @param {?=} c6
	 * @param {?=} a7
	 * @param {?=} c7
	 * @param {?=} a8
	 * @param {?=} c8
	 * @param {?=} a9
	 * @param {?=} c9
	 * @return {?}
	 */
	function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	    switch (valueCount) {
	        case 1:
	            return c0 + _toStringWithNull(a1) + c1;
	        case 2:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	        case 3:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3;
	        case 4:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4;
	        case 5:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	        case 6:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	        case 7:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7;
	        case 8:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	        case 9:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	        default:
	            throw new Error("Does not support more than 9 expressions");
	    }
	}
	/**
	 * @param {?} v
	 * @return {?}
	 */
	function _toStringWithNull(v) {
	    return v != null ? v.toString() : '';
	}
	var EMPTY_ARRAY = [];
	var EMPTY_MAP = {};
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} flags
	 * @param {?} matchedQueriesDsl
	 * @param {?} ngContentIndex
	 * @param {?} childCount
	 * @param {?=} handleEvent
	 * @param {?=} templateFactory
	 * @return {?}
	 */
	function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {
	    flags |= 1 /* TypeElement */;
	    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;
	    var /** @type {?} */ template = templateFactory ? resolveViewDefinition(templateFactory) : null;
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,
	        bindings: [],
	        bindingFlags: 0,
	        outputs: [],
	        element: {
	            ns: null,
	            name: null,
	            attrs: null, template: template,
	            componentProvider: null,
	            componentView: null,
	            componentRendererType: null,
	            publicProviders: null,
	            allProviders: null,
	            handleEvent: handleEvent || NOOP
	        },
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} flags
	 * @param {?} matchedQueriesDsl
	 * @param {?} ngContentIndex
	 * @param {?} childCount
	 * @param {?} namespaceAndName
	 * @param {?=} fixedAttrs
	 * @param {?=} bindings
	 * @param {?=} outputs
	 * @param {?=} handleEvent
	 * @param {?=} componentView
	 * @param {?=} componentRendererType
	 * @return {?}
	 */
	function elementDef(flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs, bindings, outputs, handleEvent, componentView, componentRendererType) {
	    if (fixedAttrs === void 0) { fixedAttrs = []; }
	    if (!handleEvent) {
	        handleEvent = NOOP;
	    }
	    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;
	    var /** @type {?} */ ns = ((null));
	    var /** @type {?} */ name = ((null));
	    if (namespaceAndName) {
	        _b = splitNamespace(namespaceAndName), ns = _b[0], name = _b[1];
	    }
	    bindings = bindings || [];
	    var /** @type {?} */ bindingDefs = new Array(bindings.length);
	    for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	        var _c = bindings[i], bindingFlags = _c[0], namespaceAndName_1 = _c[1], suffixOrSecurityContext = _c[2];
	        var _d = splitNamespace(namespaceAndName_1), ns_1 = _d[0], name_1 = _d[1];
	        var /** @type {?} */ securityContext = ((undefined));
	        var /** @type {?} */ suffix = ((undefined));
	        switch (bindingFlags & 15 /* Types */) {
	            case 4 /* TypeElementStyle */:
	                suffix = (suffixOrSecurityContext);
	                break;
	            case 1 /* TypeElementAttribute */:
	            case 8 /* TypeProperty */:
	                securityContext = (suffixOrSecurityContext);
	                break;
	        }
	        bindingDefs[i] =
	            { flags: bindingFlags, ns: ns_1, name: name_1, nonMinifiedName: name_1, securityContext: securityContext, suffix: suffix };
	    }
	    outputs = outputs || [];
	    var /** @type {?} */ outputDefs = new Array(outputs.length);
	    for (var /** @type {?} */ i = 0; i < outputs.length; i++) {
	        var _e = outputs[i], target = _e[0], eventName = _e[1];
	        outputDefs[i] = {
	            type: 0 /* ElementOutput */,
	            target: /** @type {?} */ (target), eventName: eventName,
	            propName: null
	        };
	    }
	    fixedAttrs = fixedAttrs || [];
	    var /** @type {?} */ attrs = (fixedAttrs.map(function (_a) {
	        var namespaceAndName = _a[0], value = _a[1];
	        var _b = splitNamespace(namespaceAndName), ns = _b[0], name = _b[1];
	        return [ns, name, value];
	    }));
	    componentRendererType = resolveRendererType2(componentRendererType);
	    if (componentView) {
	        flags |= 16777216 /* ComponentView */;
	    }
	    flags |= 1 /* TypeElement */;
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references, ngContentIndex: ngContentIndex, childCount: childCount,
	        bindings: bindingDefs,
	        bindingFlags: calcBindingFlags(bindingDefs),
	        outputs: outputDefs,
	        element: {
	            ns: ns,
	            name: name,
	            attrs: attrs,
	            template: null,
	            // will bet set by the view definition
	            componentProvider: null,
	            componentView: componentView || null,
	            componentRendererType: componentRendererType,
	            publicProviders: null,
	            allProviders: null,
	            handleEvent: handleEvent || NOOP,
	        },
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: null
	    };
	    var _b;
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function createElement(view, renderHost, def) {
	    var /** @type {?} */ elDef = ((def.element));
	    var /** @type {?} */ rootSelectorOrNode = view.root.selectorOrNode;
	    var /** @type {?} */ renderer = view.renderer;
	    var /** @type {?} */ el;
	    if (view.parent || !rootSelectorOrNode) {
	        if (elDef.name) {
	            el = renderer.createElement(elDef.name, elDef.ns);
	        }
	        else {
	            el = renderer.createComment('');
	        }
	        var /** @type {?} */ parentEl = getParentRenderElement(view, renderHost, def);
	        if (parentEl) {
	            renderer.appendChild(parentEl, el);
	        }
	    }
	    else {
	        el = renderer.selectRootElement(rootSelectorOrNode);
	    }
	    if (elDef.attrs) {
	        for (var /** @type {?} */ i = 0; i < elDef.attrs.length; i++) {
	            var _a = elDef.attrs[i], ns = _a[0], name = _a[1], value = _a[2];
	            renderer.setAttribute(el, name, value, ns);
	        }
	    }
	    return el;
	}
	/**
	 * @param {?} view
	 * @param {?} compView
	 * @param {?} def
	 * @param {?} el
	 * @return {?}
	 */
	function listenToElementOutputs(view, compView, def, el) {
	    for (var /** @type {?} */ i = 0; i < def.outputs.length; i++) {
	        var /** @type {?} */ output = def.outputs[i];
	        var /** @type {?} */ handleEventClosure = renderEventHandlerClosure(view, def.index, elementEventFullName(output.target, output.eventName));
	        var /** @type {?} */ listenTarget = output.target;
	        var /** @type {?} */ listenerView = view;
	        if (output.target === 'component') {
	            listenTarget = null;
	            listenerView = compView;
	        }
	        var /** @type {?} */ disposable = (listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure)); /** @type {?} */
	        ((view.disposables))[def.outputIndex + i] = disposable;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} index
	 * @param {?} eventName
	 * @return {?}
	 */
	function renderEventHandlerClosure(view, index, eventName) {
	    return function (event) { return dispatchEvent(view, index, eventName, event); };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ bindLen = def.bindings.length;
	    var /** @type {?} */ changed = false;
	    if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0))
	        changed = true;
	    if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1))
	        changed = true;
	    if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2))
	        changed = true;
	    if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3))
	        changed = true;
	    if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4))
	        changed = true;
	    if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5))
	        changed = true;
	    if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6))
	        changed = true;
	    if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7))
	        changed = true;
	    if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8))
	        changed = true;
	    if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9))
	        changed = true;
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateElementDynamic(view, def, values) {
	    var /** @type {?} */ changed = false;
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        if (checkAndUpdateElementValue(view, def, i, values[i]))
	            changed = true;
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @return {?}
	 */
	function checkAndUpdateElementValue(view, def, bindingIdx, value) {
	    if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {
	        return false;
	    }
	    var /** @type {?} */ binding = def.bindings[bindingIdx];
	    var /** @type {?} */ elData = asElementData(view, def.index);
	    var /** @type {?} */ renderNode$$1 = elData.renderElement;
	    var /** @type {?} */ name = ((binding.name));
	    switch (binding.flags & 15 /* Types */) {
	        case 1 /* TypeElementAttribute */:
	            setElementAttribute(view, binding, renderNode$$1, binding.ns, name, value);
	            break;
	        case 2 /* TypeElementClass */:
	            setElementClass(view, renderNode$$1, name, value);
	            break;
	        case 4 /* TypeElementStyle */:
	            setElementStyle(view, binding, renderNode$$1, name, value);
	            break;
	        case 8 /* TypeProperty */:
	            var /** @type {?} */ bindView = (def.flags & 16777216 /* ComponentView */ &&
	                binding.flags & 32 /* SyntheticHostProperty */) ?
	                elData.componentView :
	                view;
	            setElementProperty(bindView, binding, renderNode$$1, name, value);
	            break;
	    }
	    return true;
	}
	/**
	 * @param {?} view
	 * @param {?} binding
	 * @param {?} renderNode
	 * @param {?} ns
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementAttribute(view, binding, renderNode$$1, ns, name, value) {
	    var /** @type {?} */ securityContext = binding.securityContext;
	    var /** @type {?} */ renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
	    renderValue = renderValue != null ? renderValue.toString() : null;
	    var /** @type {?} */ renderer = view.renderer;
	    if (value != null) {
	        renderer.setAttribute(renderNode$$1, name, renderValue, ns);
	    }
	    else {
	        renderer.removeAttribute(renderNode$$1, name, ns);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} renderNode
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementClass(view, renderNode$$1, name, value) {
	    var /** @type {?} */ renderer = view.renderer;
	    if (value) {
	        renderer.addClass(renderNode$$1, name);
	    }
	    else {
	        renderer.removeClass(renderNode$$1, name);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} binding
	 * @param {?} renderNode
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementStyle(view, binding, renderNode$$1, name, value) {
	    var /** @type {?} */ renderValue = view.root.sanitizer.sanitize(SecurityContext.STYLE, /** @type {?} */ (value));
	    if (renderValue != null) {
	        renderValue = renderValue.toString();
	        var /** @type {?} */ unit = binding.suffix;
	        if (unit != null) {
	            renderValue = renderValue + unit;
	        }
	    }
	    else {
	        renderValue = null;
	    }
	    var /** @type {?} */ renderer = view.renderer;
	    if (renderValue != null) {
	        renderer.setStyle(renderNode$$1, name, renderValue);
	    }
	    else {
	        renderer.removeStyle(renderNode$$1, name);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} binding
	 * @param {?} renderNode
	 * @param {?} name
	 * @param {?} value
	 * @return {?}
	 */
	function setElementProperty(view, binding, renderNode$$1, name, value) {
	    var /** @type {?} */ securityContext = binding.securityContext;
	    var /** @type {?} */ renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
	    view.renderer.setProperty(renderNode$$1, name, renderValue);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} ngContentIndex
	 * @param {?} index
	 * @return {?}
	 */
	function ngContentDef(ngContentIndex, index) {
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: 4 /* TypeNgContent */,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {}, ngContentIndex: ngContentIndex,
	        childCount: 0,
	        bindings: [],
	        bindingFlags: 0,
	        outputs: [],
	        element: null,
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: { index: index }
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function appendNgContent(view, renderHost, def) {
	    var /** @type {?} */ parentEl = getParentRenderElement(view, renderHost, def);
	    if (!parentEl) {
	        // Nothing to do if there is no parent element.
	        return;
	    }
	    var /** @type {?} */ ngContentIndex = ((def.ngContent)).index;
	    visitProjectedRenderNodes(view, ngContentIndex, 1 /* AppendChild */, parentEl, null, undefined);
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} parentView
	 * @param {?} elementData
	 * @param {?} viewIndex
	 * @param {?} view
	 * @return {?}
	 */
	function attachEmbeddedView(parentView, elementData, viewIndex, view) {
	    var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	    if (viewIndex === null || viewIndex === undefined) {
	        viewIndex = embeddedViews.length;
	    }
	    view.viewContainerParent = parentView;
	    addToArray(embeddedViews, /** @type {?} */ ((viewIndex)), view);
	    var /** @type {?} */ dvcElementData = declaredViewContainer(view);
	    if (dvcElementData && dvcElementData !== elementData) {
	        var /** @type {?} */ projectedViews = dvcElementData.template._projectedViews;
	        if (!projectedViews) {
	            projectedViews = dvcElementData.template._projectedViews = [];
	        }
	        projectedViews.push(view);
	    }
	    Services.dirtyParentQueries(view);
	    var /** @type {?} */ prevView = ((viewIndex)) > 0 ? embeddedViews[((viewIndex)) - 1] : null;
	    renderAttachEmbeddedView(elementData, prevView, view);
	}
	/**
	 * @param {?} elementData
	 * @param {?=} viewIndex
	 * @return {?}
	 */
	function detachEmbeddedView(elementData, viewIndex) {
	    var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	    if (viewIndex == null || viewIndex >= embeddedViews.length) {
	        viewIndex = embeddedViews.length - 1;
	    }
	    if (viewIndex < 0) {
	        return null;
	    }
	    var /** @type {?} */ view = embeddedViews[viewIndex];
	    view.viewContainerParent = null;
	    removeFromArray(embeddedViews, viewIndex);
	    var /** @type {?} */ dvcElementData = declaredViewContainer(view);
	    if (dvcElementData && dvcElementData !== elementData) {
	        var /** @type {?} */ projectedViews = dvcElementData.template._projectedViews;
	        removeFromArray(projectedViews, projectedViews.indexOf(view));
	    }
	    Services.dirtyParentQueries(view);
	    renderDetachView(view);
	    return view;
	}
	/**
	 * @param {?} elementData
	 * @param {?} oldViewIndex
	 * @param {?} newViewIndex
	 * @return {?}
	 */
	function moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {
	    var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	    var /** @type {?} */ view = embeddedViews[oldViewIndex];
	    removeFromArray(embeddedViews, oldViewIndex);
	    if (newViewIndex == null) {
	        newViewIndex = embeddedViews.length;
	    }
	    addToArray(embeddedViews, newViewIndex, view);
	    // Note: Don't need to change projectedViews as the order in there
	    // as always invalid...
	    Services.dirtyParentQueries(view);
	    renderDetachView(view);
	    var /** @type {?} */ prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;
	    renderAttachEmbeddedView(elementData, prevView, view);
	    return view;
	}
	/**
	 * @param {?} elementData
	 * @param {?} prevView
	 * @param {?} view
	 * @return {?}
	 */
	function renderAttachEmbeddedView(elementData, prevView, view) {
	    var /** @type {?} */ prevRenderNode = prevView ? renderNode(prevView, /** @type {?} */ ((prevView.def.lastRenderRootNode))) :
	        elementData.renderElement;
	    var /** @type {?} */ parentNode = view.renderer.parentNode(prevRenderNode);
	    var /** @type {?} */ nextSibling = view.renderer.nextSibling(prevRenderNode);
	    // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!
	    // However, browsers automatically do `appendChild` when there is no `nextSibling`.
	    visitRootRenderNodes(view, 2 /* InsertBefore */, parentNode, nextSibling, undefined);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function renderDetachView(view) {
	    visitRootRenderNodes(view, 3 /* RemoveChild */, null, null, undefined);
	}
	/**
	 * @param {?} arr
	 * @param {?} index
	 * @param {?} value
	 * @return {?}
	 */
	function addToArray(arr, index, value) {
	    // perf: array.push is faster than array.splice!
	    if (index >= arr.length) {
	        arr.push(value);
	    }
	    else {
	        arr.splice(index, 0, value);
	    }
	}
	/**
	 * @param {?} arr
	 * @param {?} index
	 * @return {?}
	 */
	function removeFromArray(arr, index) {
	    // perf: array.pop is faster than array.splice!
	    if (index >= arr.length - 1) {
	        arr.pop();
	    }
	    else {
	        arr.splice(index, 1);
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var EMPTY_CONTEXT = new Object();
	/**
	 * @param {?} selector
	 * @param {?} componentType
	 * @param {?} viewDefFactory
	 * @param {?} inputs
	 * @param {?} outputs
	 * @param {?} ngContentSelectors
	 * @return {?}
	 */
	function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {
	    return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);
	}
	/**
	 * @param {?} componentFactory
	 * @return {?}
	 */
	function getComponentViewDefinitionFactory(componentFactory) {
	    return ((componentFactory)).viewDefFactory;
	}
	var ComponentFactory_ = (function (_super) {
	    __extends(ComponentFactory_, _super);
	    /**
	     * @param {?} selector
	     * @param {?} componentType
	     * @param {?} viewDefFactory
	     * @param {?} _inputs
	     * @param {?} _outputs
	     * @param {?} ngContentSelectors
	     */
	    function ComponentFactory_(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {
	        var _this = 
	        // Attention: this ctor is called as top level function.
	        // Putting any logic in here will destroy closure tree shaking!
	        _super.call(this) || this;
	        _this.selector = selector;
	        _this.componentType = componentType;
	        _this._inputs = _inputs;
	        _this._outputs = _outputs;
	        _this.ngContentSelectors = ngContentSelectors;
	        _this.viewDefFactory = viewDefFactory;
	        return _this;
	    }
	    Object.defineProperty(ComponentFactory_.prototype, "inputs", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ inputsArr = [];
	            var /** @type {?} */ inputs = ((this._inputs));
	            for (var /** @type {?} */ propName in inputs) {
	                var /** @type {?} */ templateName = inputs[propName];
	                inputsArr.push({ propName: propName, templateName: templateName });
	            }
	            return inputsArr;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentFactory_.prototype, "outputs", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ outputsArr = [];
	            for (var /** @type {?} */ propName in this._outputs) {
	                var /** @type {?} */ templateName = this._outputs[propName];
	                outputsArr.push({ propName: propName, templateName: templateName });
	            }
	            return outputsArr;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a new component.
	     * @param {?} injector
	     * @param {?=} projectableNodes
	     * @param {?=} rootSelectorOrNode
	     * @param {?=} ngModule
	     * @return {?}
	     */
	    ComponentFactory_.prototype.create = function (injector, projectableNodes, rootSelectorOrNode, ngModule) {
	        if (!ngModule) {
	            throw new Error('ngModule should be provided');
	        }
	        var /** @type {?} */ viewDef = resolveViewDefinition(this.viewDefFactory);
	        var /** @type {?} */ componentNodeIndex = ((((viewDef.nodes[0].element)).componentProvider)).index;
	        var /** @type {?} */ view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);
	        var /** @type {?} */ component = asProviderData(view, componentNodeIndex).instance;
	        view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);
	        return new ComponentRef_(view, new ViewRef_(view), component);
	    };
	    return ComponentFactory_;
	}(ComponentFactory));
	var ComponentRef_ = (function (_super) {
	    __extends(ComponentRef_, _super);
	    /**
	     * @param {?} _view
	     * @param {?} _viewRef
	     * @param {?} _component
	     */
	    function ComponentRef_(_view, _viewRef, _component) {
	        var _this = _super.call(this) || this;
	        _this._view = _view;
	        _this._viewRef = _viewRef;
	        _this._component = _component;
	        _this._elDef = _this._view.def.nodes[0];
	        return _this;
	    }
	    Object.defineProperty(ComponentRef_.prototype, "location", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return new ElementRef(asElementData(this._view, this._elDef.index).renderElement);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return new Injector_(this._view, this._elDef); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ComponentRef_.prototype, "instance", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._component; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ComponentRef_.prototype, "hostView", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._viewRef; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._viewRef; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    Object.defineProperty(ComponentRef_.prototype, "componentType", {
	        /**
	         * @return {?}
	         */
	        get: function () { return (this._component.constructor); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ComponentRef_.prototype.destroy = function () { this._viewRef.destroy(); };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    ComponentRef_.prototype.onDestroy = function (callback) { this._viewRef.onDestroy(callback); };
	    return ComponentRef_;
	}(ComponentRef));
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} elData
	 * @return {?}
	 */
	function createViewContainerData(view, elDef, elData) {
	    return new ViewContainerRef_(view, elDef, elData);
	}
	var ViewContainerRef_ = (function () {
	    /**
	     * @param {?} _view
	     * @param {?} _elDef
	     * @param {?} _data
	     */
	    function ViewContainerRef_(_view, _elDef, _data) {
	        this._view = _view;
	        this._elDef = _elDef;
	        this._data = _data;
	        /**
	         * \@internal
	         */
	        this._embeddedViews = [];
	    }
	    Object.defineProperty(ViewContainerRef_.prototype, "element", {
	        /**
	         * @return {?}
	         */
	        get: function () { return new ElementRef(this._data.renderElement); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return new Injector_(this._view, this._elDef); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ view = this._view;
	            var /** @type {?} */ elDef = this._elDef.parent;
	            while (!elDef && view) {
	                elDef = viewParentEl(view);
	                view = ((view.parent));
	            }
	            return view ? new Injector_(view, elDef) : new Injector_(this._view, null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.clear = function () {
	        var /** @type {?} */ len = this._embeddedViews.length;
	        for (var /** @type {?} */ i = len - 1; i >= 0; i--) {
	            var /** @type {?} */ view = ((detachEmbeddedView(this._data, i)));
	            Services.destroyView(view);
	        }
	    };
	    /**
	     * @param {?} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.get = function (index) {
	        var /** @type {?} */ view = this._embeddedViews[index];
	        if (view) {
	            var /** @type {?} */ ref = new ViewRef_(view);
	            ref.attachToViewContainerRef(this);
	            return ref;
	        }
	        return null;
	    };
	    Object.defineProperty(ViewContainerRef_.prototype, "length", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._embeddedViews.length; },
	        enumerable: true,
	        configurable: true
	    });
	    
	    /**
	     * @template C
	     * @param {?} templateRef
	     * @param {?=} context
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	        var /** @type {?} */ viewRef = templateRef.createEmbeddedView(context || ({}));
	        this.insert(viewRef, index);
	        return viewRef;
	    };
	    /**
	     * @template C
	     * @param {?} componentFactory
	     * @param {?=} index
	     * @param {?=} injector
	     * @param {?=} projectableNodes
	     * @param {?=} ngModuleRef
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes, ngModuleRef) {
	        var /** @type {?} */ contextInjector = injector || this.parentInjector;
	        if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {
	            ngModuleRef = contextInjector.get(NgModuleRef);
	        }
	        var /** @type {?} */ componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);
	        this.insert(componentRef.hostView, index);
	        return componentRef;
	    };
	    /**
	     * @param {?} viewRef
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.insert = function (viewRef, index) {
	        var /** @type {?} */ viewRef_ = (viewRef);
	        var /** @type {?} */ viewData = viewRef_._view;
	        attachEmbeddedView(this._view, this._data, index, viewData);
	        viewRef_.attachToViewContainerRef(this);
	        return viewRef;
	    };
	    /**
	     * @param {?} viewRef
	     * @param {?} currentIndex
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
	        var /** @type {?} */ previousIndex = this._embeddedViews.indexOf(viewRef._view);
	        moveEmbeddedView(this._data, previousIndex, currentIndex);
	        return viewRef;
	    };
	    /**
	     * @param {?} viewRef
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.indexOf = function (viewRef) {
	        return this._embeddedViews.indexOf(((viewRef))._view);
	    };
	    /**
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.remove = function (index) {
	        var /** @type {?} */ viewData = detachEmbeddedView(this._data, index);
	        if (viewData) {
	            Services.destroyView(viewData);
	        }
	    };
	    /**
	     * @param {?=} index
	     * @return {?}
	     */
	    ViewContainerRef_.prototype.detach = function (index) {
	        var /** @type {?} */ view = detachEmbeddedView(this._data, index);
	        return view ? new ViewRef_(view) : null;
	    };
	    return ViewContainerRef_;
	}());
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function createChangeDetectorRef(view) {
	    return new ViewRef_(view);
	}
	var ViewRef_ = (function () {
	    /**
	     * @param {?} _view
	     */
	    function ViewRef_(_view) {
	        this._view = _view;
	        this._viewContainerRef = null;
	        this._appRef = null;
	    }
	    Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	        /**
	         * @return {?}
	         */
	        get: function () { return rootRenderNodes(this._view); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "context", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this._view.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef_.prototype, "destroyed", {
	        /**
	         * @return {?}
	         */
	        get: function () { return (this._view.state & 8 /* Destroyed */) !== 0; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.markForCheck = function () { markParentViewsForCheck(this._view); };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.detach = function () { this._view.state &= ~2 /* ChecksEnabled */; };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.detectChanges = function () { Services.checkAndUpdateView(this._view); };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.checkNoChanges = function () { Services.checkNoChangesView(this._view); };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.reattach = function () { this._view.state |= 2 /* ChecksEnabled */; };
	    /**
	     * @param {?} callback
	     * @return {?}
	     */
	    ViewRef_.prototype.onDestroy = function (callback) {
	        if (!this._view.disposables) {
	            this._view.disposables = [];
	        }
	        this._view.disposables.push(/** @type {?} */ (callback));
	    };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.destroy = function () {
	        if (this._appRef) {
	            this._appRef.detachView(this);
	        }
	        else if (this._viewContainerRef) {
	            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));
	        }
	        Services.destroyView(this._view);
	    };
	    /**
	     * @return {?}
	     */
	    ViewRef_.prototype.detachFromAppRef = function () {
	        this._appRef = null;
	        renderDetachView(this._view);
	        Services.dirtyParentQueries(this._view);
	    };
	    /**
	     * @param {?} appRef
	     * @return {?}
	     */
	    ViewRef_.prototype.attachToAppRef = function (appRef) {
	        if (this._viewContainerRef) {
	            throw new Error('This view is already attached to a ViewContainer!');
	        }
	        this._appRef = appRef;
	    };
	    /**
	     * @param {?} vcRef
	     * @return {?}
	     */
	    ViewRef_.prototype.attachToViewContainerRef = function (vcRef) {
	        if (this._appRef) {
	            throw new Error('This view is already attached directly to the ApplicationRef!');
	        }
	        this._viewContainerRef = vcRef;
	    };
	    return ViewRef_;
	}());
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createTemplateData(view, def) {
	    return new TemplateRef_(view, def);
	}
	var TemplateRef_ = (function (_super) {
	    __extends(TemplateRef_, _super);
	    /**
	     * @param {?} _parentView
	     * @param {?} _def
	     */
	    function TemplateRef_(_parentView, _def) {
	        var _this = _super.call(this) || this;
	        _this._parentView = _parentView;
	        _this._def = _def;
	        return _this;
	    }
	    /**
	     * @param {?} context
	     * @return {?}
	     */
	    TemplateRef_.prototype.createEmbeddedView = function (context) {
	        return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, context));
	    };
	    Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return new ElementRef(asElementData(this._parentView, this._def.index).renderElement);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return TemplateRef_;
	}(TemplateRef));
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @return {?}
	 */
	function createInjector(view, elDef) {
	    return new Injector_(view, elDef);
	}
	var Injector_ = (function () {
	    /**
	     * @param {?} view
	     * @param {?} elDef
	     */
	    function Injector_(view, elDef) {
	        this.view = view;
	        this.elDef = elDef;
	    }
	    /**
	     * @param {?} token
	     * @param {?=} notFoundValue
	     * @return {?}
	     */
	    Injector_.prototype.get = function (token, notFoundValue) {
	        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }
	        var /** @type {?} */ allowPrivateServices = this.elDef ? (this.elDef.flags & 16777216 /* ComponentView */) !== 0 : false;
	        return Services.resolveDep(this.view, this.elDef, allowPrivateServices, { flags: 0 /* None */, token: token, tokenKey: tokenKey(token) }, notFoundValue);
	    };
	    return Injector_;
	}());
	/**
	 * @param {?} view
	 * @param {?} index
	 * @return {?}
	 */
	function nodeValue(view, index) {
	    var /** @type {?} */ def = view.def.nodes[index];
	    if (def.flags & 1 /* TypeElement */) {
	        var /** @type {?} */ elData = asElementData(view, def.index);
	        return ((def.element)).template ? elData.template : elData.renderElement;
	    }
	    else if (def.flags & 2 /* TypeText */) {
	        return asTextData(view, def.index).renderText;
	    }
	    else if (def.flags & (10112 /* CatProvider */ | 8 /* TypePipe */)) {
	        return asProviderData(view, def.index).instance;
	    }
	    throw new Error("Illegal state: read nodeValue for node index " + index);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function createRendererV1(view) {
	    return new RendererAdapter(view.renderer);
	}
	var RendererAdapter = (function () {
	    /**
	     * @param {?} delegate
	     */
	    function RendererAdapter(delegate) {
	        this.delegate = delegate;
	    }
	    /**
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    RendererAdapter.prototype.selectRootElement = function (selectorOrNode) {
	        return this.delegate.selectRootElement(selectorOrNode);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} namespaceAndName
	     * @return {?}
	     */
	    RendererAdapter.prototype.createElement = function (parent, namespaceAndName) {
	        var _a = splitNamespace(namespaceAndName), ns = _a[0], name = _a[1];
	        var /** @type {?} */ el = this.delegate.createElement(name, ns);
	        if (parent) {
	            this.delegate.appendChild(parent, el);
	        }
	        return el;
	    };
	    /**
	     * @param {?} hostElement
	     * @return {?}
	     */
	    RendererAdapter.prototype.createViewRoot = function (hostElement) { return hostElement; };
	    /**
	     * @param {?} parentElement
	     * @return {?}
	     */
	    RendererAdapter.prototype.createTemplateAnchor = function (parentElement) {
	        var /** @type {?} */ comment = this.delegate.createComment('');
	        if (parentElement) {
	            this.delegate.appendChild(parentElement, comment);
	        }
	        return comment;
	    };
	    /**
	     * @param {?} parentElement
	     * @param {?} value
	     * @return {?}
	     */
	    RendererAdapter.prototype.createText = function (parentElement, value) {
	        var /** @type {?} */ node = this.delegate.createText(value);
	        if (parentElement) {
	            this.delegate.appendChild(parentElement, node);
	        }
	        return node;
	    };
	    /**
	     * @param {?} parentElement
	     * @param {?} nodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.projectNodes = function (parentElement, nodes) {
	        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	            this.delegate.appendChild(parentElement, nodes[i]);
	        }
	    };
	    /**
	     * @param {?} node
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.attachViewAfter = function (node, viewRootNodes) {
	        var /** @type {?} */ parentElement = this.delegate.parentNode(node);
	        var /** @type {?} */ nextSibling = this.delegate.nextSibling(node);
	        for (var /** @type {?} */ i = 0; i < viewRootNodes.length; i++) {
	            this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);
	        }
	    };
	    /**
	     * @param {?} viewRootNodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.detachView = function (viewRootNodes) {
	        for (var /** @type {?} */ i = 0; i < viewRootNodes.length; i++) {
	            var /** @type {?} */ node = viewRootNodes[i];
	            var /** @type {?} */ parentElement = this.delegate.parentNode(node);
	            this.delegate.removeChild(parentElement, node);
	        }
	    };
	    /**
	     * @param {?} hostElement
	     * @param {?} viewAllNodes
	     * @return {?}
	     */
	    RendererAdapter.prototype.destroyView = function (hostElement, viewAllNodes) {
	        for (var /** @type {?} */ i = 0; i < viewAllNodes.length; i++) {
	            ((this.delegate.destroyNode))(viewAllNodes[i]);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    RendererAdapter.prototype.listen = function (renderElement, name, callback) {
	        return this.delegate.listen(renderElement, name, /** @type {?} */ (callback));
	    };
	    /**
	     * @param {?} target
	     * @param {?} name
	     * @param {?} callback
	     * @return {?}
	     */
	    RendererAdapter.prototype.listenGlobal = function (target, name, callback) {
	        return this.delegate.listen(target, name, /** @type {?} */ (callback));
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	        this.delegate.setProperty(renderElement, propertyName, propertyValue);
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} namespaceAndName
	     * @param {?} attributeValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementAttribute = function (renderElement, namespaceAndName, attributeValue) {
	        var _a = splitNamespace(namespaceAndName), ns = _a[0], name = _a[1];
	        if (attributeValue != null) {
	            this.delegate.setAttribute(renderElement, name, attributeValue, ns);
	        }
	        else {
	            this.delegate.removeAttribute(renderElement, name, ns);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} propertyName
	     * @param {?} propertyValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
	    /**
	     * @param {?} renderElement
	     * @param {?} className
	     * @param {?} isAdd
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementClass = function (renderElement, className, isAdd) {
	        if (isAdd) {
	            this.delegate.addClass(renderElement, className);
	        }
	        else {
	            this.delegate.removeClass(renderElement, className);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} styleName
	     * @param {?} styleValue
	     * @return {?}
	     */
	    RendererAdapter.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	        if (styleValue != null) {
	            this.delegate.setStyle(renderElement, styleName, styleValue);
	        }
	        else {
	            this.delegate.removeStyle(renderElement, styleName);
	        }
	    };
	    /**
	     * @param {?} renderElement
	     * @param {?} methodName
	     * @param {?} args
	     * @return {?}
	     */
	    RendererAdapter.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	        ((renderElement))[methodName].apply(renderElement, args);
	    };
	    /**
	     * @param {?} renderNode
	     * @param {?} text
	     * @return {?}
	     */
	    RendererAdapter.prototype.setText = function (renderNode$$1, text) { this.delegate.setValue(renderNode$$1, text); };
	    /**
	     * @return {?}
	     */
	    RendererAdapter.prototype.animate = function () { throw new Error('Renderer.animate is no longer supported!'); };
	    return RendererAdapter;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var RendererV1TokenKey = tokenKey(Renderer);
	var Renderer2TokenKey = tokenKey(Renderer2);
	var ElementRefTokenKey = tokenKey(ElementRef);
	var ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
	var TemplateRefTokenKey = tokenKey(TemplateRef);
	var ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
	var InjectorRefTokenKey = tokenKey(Injector);
	var NOT_CREATED = new Object();
	/**
	 * @param {?} flags
	 * @param {?} matchedQueries
	 * @param {?} childCount
	 * @param {?} ctor
	 * @param {?} deps
	 * @param {?=} props
	 * @param {?=} outputs
	 * @return {?}
	 */
	function directiveDef(flags, matchedQueries, childCount, ctor, deps, props, outputs) {
	    var /** @type {?} */ bindings = [];
	    if (props) {
	        for (var /** @type {?} */ prop in props) {
	            var _a = props[prop], bindingIndex = _a[0], nonMinifiedName = _a[1];
	            bindings[bindingIndex] = {
	                flags: 8 /* TypeProperty */,
	                name: prop, nonMinifiedName: nonMinifiedName,
	                ns: null,
	                securityContext: null,
	                suffix: null
	            };
	        }
	    }
	    var /** @type {?} */ outputDefs = [];
	    if (outputs) {
	        for (var /** @type {?} */ propName in outputs) {
	            outputDefs.push({ type: 1 /* DirectiveOutput */, propName: propName, target: null, eventName: outputs[propName] });
	        }
	    }
	    flags |= 8192 /* TypeDirective */;
	    return _def(flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);
	}
	/**
	 * @param {?} flags
	 * @param {?} ctor
	 * @param {?} deps
	 * @return {?}
	 */
	function pipeDef(flags, ctor, deps) {
	    flags |= 8 /* TypePipe */;
	    return _def(flags, null, 0, ctor, ctor, deps);
	}
	/**
	 * @param {?} flags
	 * @param {?} matchedQueries
	 * @param {?} token
	 * @param {?} value
	 * @param {?} deps
	 * @return {?}
	 */
	function providerDef(flags, matchedQueries, token, value, deps) {
	    return _def(flags, matchedQueries, 0, token, value, deps);
	}
	/**
	 * @param {?} flags
	 * @param {?} matchedQueriesDsl
	 * @param {?} childCount
	 * @param {?} token
	 * @param {?} value
	 * @param {?} deps
	 * @param {?=} bindings
	 * @param {?=} outputs
	 * @return {?}
	 */
	function _def(flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {
	    var _a = splitMatchedQueriesDsl(matchedQueriesDsl), matchedQueries = _a.matchedQueries, references = _a.references, matchedQueryIds = _a.matchedQueryIds;
	    if (!outputs) {
	        outputs = [];
	    }
	    if (!bindings) {
	        bindings = [];
	    }
	    var /** @type {?} */ depDefs = deps.map(function (value) {
	        var /** @type {?} */ token;
	        var /** @type {?} */ flags;
	        if (Array.isArray(value)) {
	            flags = value[0], token = value[1];
	        }
	        else {
	            flags = 0 /* None */;
	            token = value;
	        }
	        return { flags: flags, token: token, tokenKey: tokenKey(token) };
	    });
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0, matchedQueries: matchedQueries, matchedQueryIds: matchedQueryIds, references: references,
	        ngContentIndex: -1, childCount: childCount, bindings: bindings,
	        bindingFlags: calcBindingFlags(bindings), outputs: outputs,
	        element: null,
	        provider: { token: token, tokenKey: tokenKey(token), value: value, deps: depDefs },
	        text: null,
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createProviderInstance(view, def) {
	    return def.flags & 2048 /* LazyProvider */ ? NOT_CREATED : _createProviderInstance(view, def);
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createPipeInstance(view, def) {
	    // deps are looked up from component.
	    var /** @type {?} */ compView = view;
	    while (compView.parent && !isComponentView(compView)) {
	        compView = compView.parent;
	    }
	    // pipes can see the private services of the component
	    var /** @type {?} */ allowPrivateServices = true;
	    // pipes are always eager and classes!
	    return createClass(/** @type {?} */ ((compView.parent)), /** @type {?} */ ((viewParentEl(compView))), allowPrivateServices, /** @type {?} */ ((def.provider)).value, /** @type {?} */ ((def.provider)).deps);
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createDirectiveInstance(view, def) {
	    // components can see other private services, other directives can't.
	    var /** @type {?} */ allowPrivateServices = (def.flags & 16384 /* Component */) > 0;
	    // directives are always eager and classes!
	    var /** @type {?} */ instance = createClass(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((def.provider)).value, /** @type {?} */ ((def.provider)).deps);
	    if (def.outputs.length) {
	        for (var /** @type {?} */ i = 0; i < def.outputs.length; i++) {
	            var /** @type {?} */ output = def.outputs[i];
	            var /** @type {?} */ subscription = instance[((output.propName))].subscribe(eventHandlerClosure(view, /** @type {?} */ ((def.parent)).index, output.eventName)); /** @type {?} */
	            ((view.disposables))[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);
	        }
	    }
	    return instance;
	}
	/**
	 * @param {?} view
	 * @param {?} index
	 * @param {?} eventName
	 * @return {?}
	 */
	function eventHandlerClosure(view, index, eventName) {
	    return function (event) { return dispatchEvent(view, index, eventName, event); };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ providerData = asProviderData(view, def.index);
	    var /** @type {?} */ directive = providerData.instance;
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ changes = ((undefined));
	    var /** @type {?} */ bindLen = def.bindings.length;
	    if (bindLen > 0 && checkBinding(view, def, 0, v0)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 0, v0, changes);
	    }
	    if (bindLen > 1 && checkBinding(view, def, 1, v1)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 1, v1, changes);
	    }
	    if (bindLen > 2 && checkBinding(view, def, 2, v2)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 2, v2, changes);
	    }
	    if (bindLen > 3 && checkBinding(view, def, 3, v3)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 3, v3, changes);
	    }
	    if (bindLen > 4 && checkBinding(view, def, 4, v4)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 4, v4, changes);
	    }
	    if (bindLen > 5 && checkBinding(view, def, 5, v5)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 5, v5, changes);
	    }
	    if (bindLen > 6 && checkBinding(view, def, 6, v6)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 6, v6, changes);
	    }
	    if (bindLen > 7 && checkBinding(view, def, 7, v7)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 7, v7, changes);
	    }
	    if (bindLen > 8 && checkBinding(view, def, 8, v8)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 8, v8, changes);
	    }
	    if (bindLen > 9 && checkBinding(view, def, 9, v9)) {
	        changed = true;
	        changes = updateProp(view, providerData, def, 9, v9, changes);
	    }
	    if (changes) {
	        directive.ngOnChanges(changes);
	    }
	    if ((view.state & 1 /* FirstCheck */) && (def.flags & 32768 /* OnInit */)) {
	        directive.ngOnInit();
	    }
	    if (def.flags & 131072 /* DoCheck */) {
	        directive.ngDoCheck();
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateDirectiveDynamic(view, def, values) {
	    var /** @type {?} */ providerData = asProviderData(view, def.index);
	    var /** @type {?} */ directive = providerData.instance;
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ changes = ((undefined));
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        if (checkBinding(view, def, i, values[i])) {
	            changed = true;
	            changes = updateProp(view, providerData, def, i, values[i], changes);
	        }
	    }
	    if (changes) {
	        directive.ngOnChanges(changes);
	    }
	    if ((view.state & 1 /* FirstCheck */) && (def.flags & 32768 /* OnInit */)) {
	        directive.ngOnInit();
	    }
	    if (def.flags & 131072 /* DoCheck */) {
	        directive.ngDoCheck();
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function _createProviderInstance(view, def) {
	    // private services can see other private services
	    var /** @type {?} */ allowPrivateServices = (def.flags & 4096 /* PrivateProvider */) > 0;
	    var /** @type {?} */ providerDef = def.provider;
	    var /** @type {?} */ injectable;
	    switch (def.flags & 100673535 /* Types */) {
	        case 256 /* TypeClassProvider */:
	            injectable = createClass(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((providerDef)).value, /** @type {?} */ ((providerDef)).deps);
	            break;
	        case 512 /* TypeFactoryProvider */:
	            injectable = callFactory(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((providerDef)).value, /** @type {?} */ ((providerDef)).deps);
	            break;
	        case 1024 /* TypeUseExistingProvider */:
	            injectable = resolveDep(view, /** @type {?} */ ((def.parent)), allowPrivateServices, /** @type {?} */ ((providerDef)).deps[0]);
	            break;
	        case 128 /* TypeValueProvider */:
	            injectable = ((providerDef)).value;
	            break;
	    }
	    return injectable;
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @param {?} ctor
	 * @param {?} deps
	 * @return {?}
	 */
	function createClass(view, elDef, allowPrivateServices, ctor, deps) {
	    var /** @type {?} */ len = deps.length;
	    var /** @type {?} */ injectable;
	    switch (len) {
	        case 0:
	            injectable = new ctor();
	            break;
	        case 1:
	            injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));
	            break;
	        case 2:
	            injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
	            break;
	        case 3:
	            injectable = new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
	            break;
	        default:
	            var /** @type {?} */ depValues = new Array(len);
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
	            }
	            injectable = new (ctor.bind.apply(ctor, [void 0].concat(depValues)))();
	    }
	    return injectable;
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @param {?} factory
	 * @param {?} deps
	 * @return {?}
	 */
	function callFactory(view, elDef, allowPrivateServices, factory, deps) {
	    var /** @type {?} */ len = deps.length;
	    var /** @type {?} */ injectable;
	    switch (len) {
	        case 0:
	            injectable = factory();
	            break;
	        case 1:
	            injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));
	            break;
	        case 2:
	            injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
	            break;
	        case 3:
	            injectable = factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
	            break;
	        default:
	            var /** @type {?} */ depValues = Array(len);
	            for (var /** @type {?} */ i = 0; i < len; i++) {
	                depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
	            }
	            injectable = factory.apply(void 0, depValues);
	    }
	    return injectable;
	}
	// This default value is when checking the hierarchy for a token.
	//
	// It means both:
	// - the token is not provided by the current injector,
	// - only the element injectors should be checked (ie do not check module injectors
	//
	//          mod1
	//         /
	//       el1   mod2
	//         \  /
	//         el2
	//
	// When requesting el2.injector.get(token), we should check in the following order and return the
	// first found value:
	// - el2.injector.get(token, default)
	// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module
	// - mod2.injector.get(token, default)
	var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @param {?} depDef
	 * @param {?=} notFoundValue
	 * @return {?}
	 */
	function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue) {
	    if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }
	    if (depDef.flags & 8 /* Value */) {
	        return depDef.token;
	    }
	    var /** @type {?} */ startView = view;
	    if (depDef.flags & 2 /* Optional */) {
	        notFoundValue = null;
	    }
	    var /** @type {?} */ tokenKey$$1 = depDef.tokenKey;
	    if (elDef && (depDef.flags & 1 /* SkipSelf */)) {
	        allowPrivateServices = false;
	        elDef = ((elDef.parent));
	    }
	    while (view) {
	        if (elDef) {
	            switch (tokenKey$$1) {
	                case RendererV1TokenKey: {
	                    var /** @type {?} */ compView = findCompView(view, elDef, allowPrivateServices);
	                    return createRendererV1(compView);
	                }
	                case Renderer2TokenKey: {
	                    var /** @type {?} */ compView = findCompView(view, elDef, allowPrivateServices);
	                    return compView.renderer;
	                }
	                case ElementRefTokenKey:
	                    return new ElementRef(asElementData(view, elDef.index).renderElement);
	                case ViewContainerRefTokenKey:
	                    return asElementData(view, elDef.index).viewContainer;
	                case TemplateRefTokenKey: {
	                    if (((elDef.element)).template) {
	                        return asElementData(view, elDef.index).template;
	                    }
	                    break;
	                }
	                case ChangeDetectorRefTokenKey: {
	                    var /** @type {?} */ cdView = findCompView(view, elDef, allowPrivateServices);
	                    return createChangeDetectorRef(cdView);
	                }
	                case InjectorRefTokenKey:
	                    return createInjector(view, elDef);
	                default:
	                    var /** @type {?} */ providerDef_1 = (((allowPrivateServices ? ((elDef.element)).allProviders : ((elDef.element)).publicProviders)))[tokenKey$$1];
	                    if (providerDef_1) {
	                        var /** @type {?} */ providerData = asProviderData(view, providerDef_1.index);
	                        if (providerData.instance === NOT_CREATED) {
	                            providerData.instance = _createProviderInstance(view, providerDef_1);
	                        }
	                        return providerData.instance;
	                    }
	            }
	        }
	        allowPrivateServices = isComponentView(view);
	        elDef = ((viewParentEl(view)));
	        view = ((view.parent));
	    }
	    var /** @type {?} */ value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);
	    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||
	        notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
	        // Return the value from the root element injector when
	        // - it provides it
	        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	        // - the module injector should not be checked
	        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
	        return value;
	    }
	    return startView.root.ngModule.injector.get(depDef.token, notFoundValue);
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} allowPrivateServices
	 * @return {?}
	 */
	function findCompView(view, elDef, allowPrivateServices) {
	    var /** @type {?} */ compView;
	    if (allowPrivateServices) {
	        compView = asElementData(view, elDef.index).componentView;
	    }
	    else {
	        compView = view;
	        while (compView.parent && !isComponentView(compView)) {
	            compView = compView.parent;
	        }
	    }
	    return compView;
	}
	/**
	 * @param {?} view
	 * @param {?} providerData
	 * @param {?} def
	 * @param {?} bindingIdx
	 * @param {?} value
	 * @param {?} changes
	 * @return {?}
	 */
	function updateProp(view, providerData, def, bindingIdx, value, changes) {
	    if (def.flags & 16384 /* Component */) {
	        var /** @type {?} */ compView = asElementData(view, /** @type {?} */ ((def.parent)).index).componentView;
	        if (compView.def.flags & 2 /* OnPush */) {
	            compView.state |= 2 /* ChecksEnabled */;
	        }
	    }
	    var /** @type {?} */ binding = def.bindings[bindingIdx];
	    var /** @type {?} */ propName = ((binding.name));
	    // Note: This is still safe with Closure Compiler as
	    // the user passed in the property name as an object has to `providerDef`,
	    // so Closure Compiler will have renamed the property correctly already.
	    providerData.instance[propName] = value;
	    if (def.flags & 262144 /* OnChanges */) {
	        changes = changes || {};
	        var /** @type {?} */ oldValue = view.oldValues[def.bindingIndex + bindingIdx];
	        if (oldValue instanceof WrappedValue) {
	            oldValue = oldValue.wrapped;
	        }
	        var /** @type {?} */ binding_1 = def.bindings[bindingIdx];
	        changes[((binding_1.nonMinifiedName))] =
	            new SimpleChange(oldValue, value, (view.state & 1 /* FirstCheck */) !== 0);
	    }
	    view.oldValues[def.bindingIndex + bindingIdx] = value;
	    return changes;
	}
	/**
	 * @param {?} view
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callLifecycleHooksChildrenFirst(view, lifecycles) {
	    if (!(view.def.nodeFlags & lifecycles)) {
	        return;
	    }
	    var /** @type {?} */ nodes = view.def.nodes;
	    for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	        var /** @type {?} */ nodeDef = nodes[i];
	        var /** @type {?} */ parent = nodeDef.parent;
	        if (!parent && nodeDef.flags & lifecycles) {
	            // matching root node (e.g. a pipe)
	            callProviderLifecycles(view, i, nodeDef.flags & lifecycles);
	        }
	        if ((nodeDef.childFlags & lifecycles) === 0) {
	            // no child matches one of the lifecycles
	            i += nodeDef.childCount;
	        }
	        while (parent && (parent.flags & 1 /* TypeElement */) &&
	            i === parent.index + parent.childCount) {
	            // last child of an element
	            if (parent.directChildFlags & lifecycles) {
	                callElementProvidersLifecycles(view, parent, lifecycles);
	            }
	            parent = parent.parent;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} elDef
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callElementProvidersLifecycles(view, elDef, lifecycles) {
	    for (var /** @type {?} */ i = elDef.index + 1; i <= elDef.index + elDef.childCount; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if (nodeDef.flags & lifecycles) {
	            callProviderLifecycles(view, i, nodeDef.flags & lifecycles);
	        }
	        // only visit direct children
	        i += nodeDef.childCount;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} index
	 * @param {?} lifecycles
	 * @return {?}
	 */
	function callProviderLifecycles(view, index, lifecycles) {
	    var /** @type {?} */ provider = asProviderData(view, index).instance;
	    if (provider === NOT_CREATED) {
	        return;
	    }
	    Services.setCurrentNode(view, index);
	    if (lifecycles & 524288 /* AfterContentInit */) {
	        provider.ngAfterContentInit();
	    }
	    if (lifecycles & 1048576 /* AfterContentChecked */) {
	        provider.ngAfterContentChecked();
	    }
	    if (lifecycles & 2097152 /* AfterViewInit */) {
	        provider.ngAfterViewInit();
	    }
	    if (lifecycles & 4194304 /* AfterViewChecked */) {
	        provider.ngAfterViewChecked();
	    }
	    if (lifecycles & 65536 /* OnDestroy */) {
	        provider.ngOnDestroy();
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} argCount
	 * @return {?}
	 */
	function purePipeDef(argCount) {
	    // argCount + 1 to include the pipe as first arg
	    return _pureExpressionDef(64 /* TypePurePipe */, new Array(argCount + 1));
	}
	/**
	 * @param {?} argCount
	 * @return {?}
	 */
	function pureArrayDef(argCount) {
	    return _pureExpressionDef(16 /* TypePureArray */, new Array(argCount));
	}
	/**
	 * @param {?} propertyNames
	 * @return {?}
	 */
	function pureObjectDef(propertyNames) {
	    return _pureExpressionDef(32 /* TypePureObject */, propertyNames);
	}
	/**
	 * @param {?} flags
	 * @param {?} propertyNames
	 * @return {?}
	 */
	function _pureExpressionDef(flags, propertyNames) {
	    var /** @type {?} */ bindings = new Array(propertyNames.length);
	    for (var /** @type {?} */ i = 0; i < propertyNames.length; i++) {
	        var /** @type {?} */ prop = propertyNames[i];
	        bindings[i] = {
	            flags: 8 /* TypeProperty */,
	            name: prop,
	            ns: null,
	            nonMinifiedName: prop,
	            securityContext: null,
	            suffix: null
	        };
	    }
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {},
	        ngContentIndex: -1,
	        childCount: 0, bindings: bindings,
	        bindingFlags: calcBindingFlags(bindings),
	        outputs: [],
	        element: null,
	        provider: null,
	        text: null,
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @return {?}
	 */
	function createPureExpression(view, def) {
	    return { value: undefined };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ bindLen = bindings.length;
	    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
	        changed = true;
	    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
	        changed = true;
	    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
	        changed = true;
	    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
	        changed = true;
	    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
	        changed = true;
	    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
	        changed = true;
	    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
	        changed = true;
	    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
	        changed = true;
	    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
	        changed = true;
	    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
	        changed = true;
	    if (changed) {
	        var /** @type {?} */ data = asPureExpressionData(view, def.index);
	        var /** @type {?} */ value = void 0;
	        switch (def.flags & 100673535 /* Types */) {
	            case 16 /* TypePureArray */:
	                value = new Array(bindings.length);
	                if (bindLen > 0)
	                    value[0] = v0;
	                if (bindLen > 1)
	                    value[1] = v1;
	                if (bindLen > 2)
	                    value[2] = v2;
	                if (bindLen > 3)
	                    value[3] = v3;
	                if (bindLen > 4)
	                    value[4] = v4;
	                if (bindLen > 5)
	                    value[5] = v5;
	                if (bindLen > 6)
	                    value[6] = v6;
	                if (bindLen > 7)
	                    value[7] = v7;
	                if (bindLen > 8)
	                    value[8] = v8;
	                if (bindLen > 9)
	                    value[9] = v9;
	                break;
	            case 32 /* TypePureObject */:
	                value = {};
	                if (bindLen > 0)
	                    value[((bindings[0].name))] = v0;
	                if (bindLen > 1)
	                    value[((bindings[1].name))] = v1;
	                if (bindLen > 2)
	                    value[((bindings[2].name))] = v2;
	                if (bindLen > 3)
	                    value[((bindings[3].name))] = v3;
	                if (bindLen > 4)
	                    value[((bindings[4].name))] = v4;
	                if (bindLen > 5)
	                    value[((bindings[5].name))] = v5;
	                if (bindLen > 6)
	                    value[((bindings[6].name))] = v6;
	                if (bindLen > 7)
	                    value[((bindings[7].name))] = v7;
	                if (bindLen > 8)
	                    value[((bindings[8].name))] = v8;
	                if (bindLen > 9)
	                    value[((bindings[9].name))] = v9;
	                break;
	            case 64 /* TypePurePipe */:
	                var /** @type {?} */ pipe = v0;
	                switch (bindLen) {
	                    case 1:
	                        value = pipe.transform(v0);
	                        break;
	                    case 2:
	                        value = pipe.transform(v1);
	                        break;
	                    case 3:
	                        value = pipe.transform(v1, v2);
	                        break;
	                    case 4:
	                        value = pipe.transform(v1, v2, v3);
	                        break;
	                    case 5:
	                        value = pipe.transform(v1, v2, v3, v4);
	                        break;
	                    case 6:
	                        value = pipe.transform(v1, v2, v3, v4, v5);
	                        break;
	                    case 7:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6);
	                        break;
	                    case 8:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);
	                        break;
	                    case 9:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);
	                        break;
	                    case 10:
	                        value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);
	                        break;
	                }
	                break;
	        }
	        data.value = value;
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdatePureExpressionDynamic(view, def, values) {
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ changed = false;
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        // Note: We need to loop over all values, so that
	        // the old values are updates as well!
	        if (checkAndUpdateBinding(view, def, i, values[i])) {
	            changed = true;
	        }
	    }
	    if (changed) {
	        var /** @type {?} */ data = asPureExpressionData(view, def.index);
	        var /** @type {?} */ value = void 0;
	        switch (def.flags & 100673535 /* Types */) {
	            case 16 /* TypePureArray */:
	                value = values;
	                break;
	            case 32 /* TypePureObject */:
	                value = {};
	                for (var /** @type {?} */ i = 0; i < values.length; i++) {
	                    value[((bindings[i].name))] = values[i];
	                }
	                break;
	            case 64 /* TypePurePipe */:
	                var /** @type {?} */ pipe = values[0];
	                var /** @type {?} */ params = values.slice(1);
	                value = pipe.transform.apply(pipe, params);
	                break;
	        }
	        data.value = value;
	    }
	    return changed;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} flags
	 * @param {?} id
	 * @param {?} bindings
	 * @return {?}
	 */
	function queryDef(flags, id, bindings) {
	    var /** @type {?} */ bindingDefs = [];
	    for (var /** @type {?} */ propName in bindings) {
	        var /** @type {?} */ bindingType = bindings[propName];
	        bindingDefs.push({ propName: propName, bindingType: bindingType });
	    }
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        ngContentIndex: -1,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {},
	        childCount: 0,
	        bindings: [],
	        bindingFlags: 0,
	        outputs: [],
	        element: null,
	        provider: null,
	        text: null,
	        query: { id: id, filterId: filterQueryId(id), bindings: bindingDefs },
	        ngContent: null
	    };
	}
	/**
	 * @return {?}
	 */
	function createQuery() {
	    return new QueryList();
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function dirtyParentQueries(view) {
	    var /** @type {?} */ queryIds = view.def.nodeMatchedQueries;
	    while (view.parent && isEmbeddedView(view)) {
	        var /** @type {?} */ tplDef = ((view.parentNodeDef));
	        view = view.parent;
	        // content queries
	        var /** @type {?} */ end = tplDef.index + tplDef.childCount;
	        for (var /** @type {?} */ i = 0; i <= end; i++) {
	            var /** @type {?} */ nodeDef = view.def.nodes[i];
	            if ((nodeDef.flags & 33554432 /* TypeContentQuery */) &&
	                (nodeDef.flags & 268435456 /* DynamicQuery */) &&
	                (((nodeDef.query)).filterId & queryIds) === ((nodeDef.query)).filterId) {
	                asQueryList(view, i).setDirty();
	            }
	            if ((nodeDef.flags & 1 /* TypeElement */ && i + nodeDef.childCount < tplDef.index) ||
	                !(nodeDef.childFlags & 33554432 /* TypeContentQuery */) ||
	                !(nodeDef.childFlags & 268435456 /* DynamicQuery */)) {
	                // skip elements that don't contain the template element or no query.
	                i += nodeDef.childCount;
	            }
	        }
	    }
	    // view queries
	    if (view.def.nodeFlags & 67108864 /* TypeViewQuery */) {
	        for (var /** @type {?} */ i = 0; i < view.def.nodes.length; i++) {
	            var /** @type {?} */ nodeDef = view.def.nodes[i];
	            if ((nodeDef.flags & 67108864 /* TypeViewQuery */) && (nodeDef.flags & 268435456 /* DynamicQuery */)) {
	                asQueryList(view, i).setDirty();
	            }
	            // only visit the root nodes
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @return {?}
	 */
	function checkAndUpdateQuery(view, nodeDef) {
	    var /** @type {?} */ queryList = asQueryList(view, nodeDef.index);
	    if (!queryList.dirty) {
	        return;
	    }
	    var /** @type {?} */ directiveInstance;
	    var /** @type {?} */ newValues = ((undefined));
	    if (nodeDef.flags & 33554432 /* TypeContentQuery */) {
	        var /** @type {?} */ elementDef_1 = ((((nodeDef.parent)).parent));
	        newValues = calcQueryValues(view, elementDef_1.index, elementDef_1.index + elementDef_1.childCount, /** @type {?} */ ((nodeDef.query)), []);
	        directiveInstance = asProviderData(view, /** @type {?} */ ((nodeDef.parent)).index).instance;
	    }
	    else if (nodeDef.flags & 67108864 /* TypeViewQuery */) {
	        newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, /** @type {?} */ ((nodeDef.query)), []);
	        directiveInstance = view.component;
	    }
	    queryList.reset(newValues);
	    var /** @type {?} */ bindings = ((nodeDef.query)).bindings;
	    var /** @type {?} */ notify = false;
	    for (var /** @type {?} */ i = 0; i < bindings.length; i++) {
	        var /** @type {?} */ binding = bindings[i];
	        var /** @type {?} */ boundValue = void 0;
	        switch (binding.bindingType) {
	            case 0 /* First */:
	                boundValue = queryList.first;
	                break;
	            case 1 /* All */:
	                boundValue = queryList;
	                notify = true;
	                break;
	        }
	        directiveInstance[binding.propName] = boundValue;
	    }
	    if (notify) {
	        queryList.notifyOnChanges();
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} startIndex
	 * @param {?} endIndex
	 * @param {?} queryDef
	 * @param {?} values
	 * @return {?}
	 */
	function calcQueryValues(view, startIndex, endIndex, queryDef, values) {
	    for (var /** @type {?} */ i = startIndex; i <= endIndex; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        var /** @type {?} */ valueType = nodeDef.matchedQueries[queryDef.id];
	        if (valueType != null) {
	            values.push(getQueryValue(view, nodeDef, valueType));
	        }
	        if (nodeDef.flags & 1 /* TypeElement */ && ((nodeDef.element)).template &&
	            (((((nodeDef.element)).template)).nodeMatchedQueries & queryDef.filterId) ===
	                queryDef.filterId) {
	            // check embedded views that were attached at the place of their template.
	            var /** @type {?} */ elementData = asElementData(view, i);
	            if (nodeDef.flags & 8388608 /* EmbeddedViews */) {
	                var /** @type {?} */ embeddedViews = ((elementData.viewContainer))._embeddedViews;
	                for (var /** @type {?} */ k = 0; k < embeddedViews.length; k++) {
	                    var /** @type {?} */ embeddedView = embeddedViews[k];
	                    var /** @type {?} */ dvc = declaredViewContainer(embeddedView);
	                    if (dvc && dvc === elementData) {
	                        calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);
	                    }
	                }
	            }
	            var /** @type {?} */ projectedViews = elementData.template._projectedViews;
	            if (projectedViews) {
	                for (var /** @type {?} */ k = 0; k < projectedViews.length; k++) {
	                    var /** @type {?} */ projectedView = projectedViews[k];
	                    calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);
	                }
	            }
	        }
	        if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {
	            // if no child matches the query, skip the children.
	            i += nodeDef.childCount;
	        }
	    }
	    return values;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} queryValueType
	 * @return {?}
	 */
	function getQueryValue(view, nodeDef, queryValueType) {
	    if (queryValueType != null) {
	        // a match
	        var /** @type {?} */ value = void 0;
	        switch (queryValueType) {
	            case 1 /* RenderElement */:
	                value = asElementData(view, nodeDef.index).renderElement;
	                break;
	            case 0 /* ElementRef */:
	                value = new ElementRef(asElementData(view, nodeDef.index).renderElement);
	                break;
	            case 2 /* TemplateRef */:
	                value = asElementData(view, nodeDef.index).template;
	                break;
	            case 3 /* ViewContainerRef */:
	                value = asElementData(view, nodeDef.index).viewContainer;
	                break;
	            case 4 /* Provider */:
	                value = asProviderData(view, nodeDef.index).instance;
	                break;
	        }
	        return value;
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} ngContentIndex
	 * @param {?} constants
	 * @return {?}
	 */
	function textDef(ngContentIndex, constants) {
	    var /** @type {?} */ bindings = new Array(constants.length - 1);
	    for (var /** @type {?} */ i = 1; i < constants.length; i++) {
	        bindings[i - 1] = {
	            flags: 8 /* TypeProperty */,
	            name: null,
	            ns: null,
	            nonMinifiedName: null,
	            securityContext: null,
	            suffix: constants[i]
	        };
	    }
	    var /** @type {?} */ flags = 2;
	    return {
	        // will bet set by the view definition
	        index: -1,
	        parent: null,
	        renderParent: null,
	        bindingIndex: -1,
	        outputIndex: -1,
	        // regular values
	        flags: flags,
	        childFlags: 0,
	        directChildFlags: 0,
	        childMatchedQueries: 0,
	        matchedQueries: {},
	        matchedQueryIds: 0,
	        references: {}, ngContentIndex: ngContentIndex,
	        childCount: 0, bindings: bindings,
	        bindingFlags: calcBindingFlags(bindings),
	        outputs: [],
	        element: null,
	        provider: null,
	        text: { prefix: constants[0] },
	        query: null,
	        ngContent: null
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} renderHost
	 * @param {?} def
	 * @return {?}
	 */
	function createText(view, renderHost, def) {
	    var /** @type {?} */ renderNode$$1;
	    var /** @type {?} */ renderer = view.renderer;
	    renderNode$$1 = renderer.createText(/** @type {?} */ ((def.text)).prefix);
	    var /** @type {?} */ parentEl = getParentRenderElement(view, renderHost, def);
	    if (parentEl) {
	        renderer.appendChild(parentEl, renderNode$$1);
	    }
	    return { renderText: renderNode$$1 };
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ changed = false;
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ bindLen = bindings.length;
	    if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
	        changed = true;
	    if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
	        changed = true;
	    if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
	        changed = true;
	    if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
	        changed = true;
	    if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
	        changed = true;
	    if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
	        changed = true;
	    if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
	        changed = true;
	    if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
	        changed = true;
	    if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
	        changed = true;
	    if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
	        changed = true;
	    if (changed) {
	        var /** @type {?} */ value = ((def.text)).prefix;
	        if (bindLen > 0)
	            value += _addInterpolationPart(v0, bindings[0]);
	        if (bindLen > 1)
	            value += _addInterpolationPart(v1, bindings[1]);
	        if (bindLen > 2)
	            value += _addInterpolationPart(v2, bindings[2]);
	        if (bindLen > 3)
	            value += _addInterpolationPart(v3, bindings[3]);
	        if (bindLen > 4)
	            value += _addInterpolationPart(v4, bindings[4]);
	        if (bindLen > 5)
	            value += _addInterpolationPart(v5, bindings[5]);
	        if (bindLen > 6)
	            value += _addInterpolationPart(v6, bindings[6]);
	        if (bindLen > 7)
	            value += _addInterpolationPart(v7, bindings[7]);
	        if (bindLen > 8)
	            value += _addInterpolationPart(v8, bindings[8]);
	        if (bindLen > 9)
	            value += _addInterpolationPart(v9, bindings[9]);
	        var /** @type {?} */ renderNode$$1 = asTextData(view, def.index).renderText;
	        view.renderer.setValue(renderNode$$1, value);
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} def
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateTextDynamic(view, def, values) {
	    var /** @type {?} */ bindings = def.bindings;
	    var /** @type {?} */ changed = false;
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        // Note: We need to loop over all values, so that
	        // the old values are updates as well!
	        if (checkAndUpdateBinding(view, def, i, values[i])) {
	            changed = true;
	        }
	    }
	    if (changed) {
	        var /** @type {?} */ value = '';
	        for (var /** @type {?} */ i = 0; i < values.length; i++) {
	            value = value + _addInterpolationPart(values[i], bindings[i]);
	        }
	        value = ((def.text)).prefix + value;
	        var /** @type {?} */ renderNode$$1 = asTextData(view, def.index).renderText;
	        view.renderer.setValue(renderNode$$1, value);
	    }
	    return changed;
	}
	/**
	 * @param {?} value
	 * @param {?} binding
	 * @return {?}
	 */
	function _addInterpolationPart(value, binding) {
	    var /** @type {?} */ valueStr = value != null ? value.toString() : '';
	    return valueStr + binding.suffix;
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @param {?} flags
	 * @param {?} nodes
	 * @param {?=} updateDirectives
	 * @param {?=} updateRenderer
	 * @return {?}
	 */
	function viewDef(flags, nodes, updateDirectives, updateRenderer) {
	    // clone nodes and set auto calculated values
	    var /** @type {?} */ viewBindingCount = 0;
	    var /** @type {?} */ viewDisposableCount = 0;
	    var /** @type {?} */ viewNodeFlags = 0;
	    var /** @type {?} */ viewRootNodeFlags = 0;
	    var /** @type {?} */ viewMatchedQueries = 0;
	    var /** @type {?} */ currentParent = null;
	    var /** @type {?} */ currentElementHasPublicProviders = false;
	    var /** @type {?} */ currentElementHasPrivateProviders = false;
	    var /** @type {?} */ lastRenderRootNode = null;
	    for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	        while (currentParent && i > currentParent.index + currentParent.childCount) {
	            var /** @type {?} */ newParent = currentParent.parent;
	            if (newParent) {
	                newParent.childFlags |= ((currentParent.childFlags));
	                newParent.childMatchedQueries |= currentParent.childMatchedQueries;
	            }
	            currentParent = newParent;
	        }
	        var /** @type {?} */ node = nodes[i];
	        node.index = i;
	        node.parent = currentParent;
	        node.bindingIndex = viewBindingCount;
	        node.outputIndex = viewDisposableCount;
	        // renderParent needs to account for ng-container!
	        var /** @type {?} */ currentRenderParent = void 0;
	        if (currentParent && currentParent.flags & 1 /* TypeElement */ &&
	            !((currentParent.element)).name) {
	            currentRenderParent = currentParent.renderParent;
	        }
	        else {
	            currentRenderParent = currentParent;
	        }
	        node.renderParent = currentRenderParent;
	        if (node.element) {
	            var /** @type {?} */ elDef = node.element;
	            elDef.publicProviders =
	                currentParent ? ((currentParent.element)).publicProviders : Object.create(null);
	            elDef.allProviders = elDef.publicProviders;
	            // Note: We assume that all providers of an element are before any child element!
	            currentElementHasPublicProviders = false;
	            currentElementHasPrivateProviders = false;
	        }
	        validateNode(currentParent, node, nodes.length);
	        viewNodeFlags |= node.flags;
	        viewMatchedQueries |= node.matchedQueryIds;
	        if (node.element && node.element.template) {
	            viewMatchedQueries |= node.element.template.nodeMatchedQueries;
	        }
	        if (currentParent) {
	            currentParent.childFlags |= node.flags;
	            currentParent.directChildFlags |= node.flags;
	            currentParent.childMatchedQueries |= node.matchedQueryIds;
	            if (node.element && node.element.template) {
	                currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;
	            }
	        }
	        else {
	            viewRootNodeFlags |= node.flags;
	        }
	        viewBindingCount += node.bindings.length;
	        viewDisposableCount += node.outputs.length;
	        if (!currentRenderParent && (node.flags & 3 /* CatRenderNode */)) {
	            lastRenderRootNode = node;
	        }
	        if (node.flags & 10112 /* CatProvider */) {
	            if (!currentElementHasPublicProviders) {
	                currentElementHasPublicProviders = true; /** @type {?} */
	                ((((
	                // Use prototypical inheritance to not get O(n^2) complexity...
	                currentParent)).element)).publicProviders =
	                    Object.create(/** @type {?} */ ((((currentParent)).element)).publicProviders); /** @type {?} */
	                ((((currentParent)).element)).allProviders = ((((currentParent)).element)).publicProviders;
	            }
	            var /** @type {?} */ isPrivateService = (node.flags & 4096 /* PrivateProvider */) !== 0;
	            var /** @type {?} */ isComponent = (node.flags & 16384 /* Component */) !== 0;
	            if (!isPrivateService || isComponent) {
	                ((((((currentParent)).element)).publicProviders))[((node.provider)).tokenKey] = node;
	            }
	            else {
	                if (!currentElementHasPrivateProviders) {
	                    currentElementHasPrivateProviders = true; /** @type {?} */
	                    ((((
	                    // Use protoyypical inheritance to not get O(n^2) complexity...
	                    currentParent)).element)).allProviders =
	                        Object.create(/** @type {?} */ ((((currentParent)).element)).publicProviders);
	                } /** @type {?} */
	                ((((((currentParent)).element)).allProviders))[((node.provider)).tokenKey] = node;
	            }
	            if (isComponent) {
	                ((((currentParent)).element)).componentProvider = node;
	            }
	        }
	        if (node.childCount) {
	            currentParent = node;
	        }
	    }
	    while (currentParent) {
	        var /** @type {?} */ newParent = currentParent.parent;
	        if (newParent) {
	            newParent.childFlags |= currentParent.childFlags;
	            newParent.childMatchedQueries |= currentParent.childMatchedQueries;
	        }
	        currentParent = newParent;
	    }
	    var /** @type {?} */ handleEvent = function (view, nodeIndex, eventName, event) { return ((((nodes[nodeIndex].element)).handleEvent))(view, eventName, event); };
	    return {
	        // Will be filled later...
	        factory: null,
	        nodeFlags: viewNodeFlags,
	        rootNodeFlags: viewRootNodeFlags,
	        nodeMatchedQueries: viewMatchedQueries, flags: flags,
	        nodes: nodes,
	        updateDirectives: updateDirectives || NOOP,
	        updateRenderer: updateRenderer || NOOP,
	        handleEvent: handleEvent || NOOP,
	        bindingCount: viewBindingCount,
	        outputCount: viewDisposableCount, lastRenderRootNode: lastRenderRootNode
	    };
	}
	/**
	 * @param {?} parent
	 * @param {?} node
	 * @param {?} nodeCount
	 * @return {?}
	 */
	function validateNode(parent, node, nodeCount) {
	    var /** @type {?} */ template = node.element && node.element.template;
	    if (template) {
	        if (!template.lastRenderRootNode) {
	            throw new Error("Illegal State: Embedded templates without nodes are not allowed!");
	        }
	        if (template.lastRenderRootNode &&
	            template.lastRenderRootNode.flags & 8388608 /* EmbeddedViews */) {
	            throw new Error("Illegal State: Last root node of a template can't have embedded views, at index " + node.index + "!");
	        }
	    }
	    if (node.flags & 10112 /* CatProvider */) {
	        var /** @type {?} */ parentFlags = parent ? parent.flags : 0;
	        if ((parentFlags & 1 /* TypeElement */) === 0) {
	            throw new Error("Illegal State: Provider/Directive nodes need to be children of elements or anchors, at index " + node.index + "!");
	        }
	    }
	    if (node.query) {
	        if (node.flags & 33554432 /* TypeContentQuery */ &&
	            (!parent || (parent.flags & 8192 /* TypeDirective */) === 0)) {
	            throw new Error("Illegal State: Content Query nodes need to be children of directives, at index " + node.index + "!");
	        }
	        if (node.flags & 67108864 /* TypeViewQuery */ && parent) {
	            throw new Error("Illegal State: View Query nodes have to be top level nodes, at index " + node.index + "!");
	        }
	    }
	    if (node.childCount) {
	        var /** @type {?} */ parentEnd = parent ? parent.index + parent.childCount : nodeCount - 1;
	        if (node.index <= parentEnd && node.index + node.childCount > parentEnd) {
	            throw new Error("Illegal State: childCount of node leads outside of parent, at index " + node.index + "!");
	        }
	    }
	}
	/**
	 * @param {?} parent
	 * @param {?} anchorDef
	 * @param {?=} context
	 * @return {?}
	 */
	function createEmbeddedView(parent, anchorDef$$1, context) {
	    // embedded views are seen as siblings to the anchor, so we need
	    // to get the parent of the anchor and use it as parentIndex.
	    var /** @type {?} */ view = createView(parent.root, parent.renderer, parent, anchorDef$$1, /** @type {?} */ ((((anchorDef$$1.element)).template)));
	    initView(view, parent.component, context);
	    createViewNodes(view);
	    return view;
	}
	/**
	 * @param {?} root
	 * @param {?} def
	 * @param {?=} context
	 * @return {?}
	 */
	function createRootView(root, def, context) {
	    var /** @type {?} */ view = createView(root, root.renderer, null, null, def);
	    initView(view, context, context);
	    createViewNodes(view);
	    return view;
	}
	/**
	 * @param {?} root
	 * @param {?} renderer
	 * @param {?} parent
	 * @param {?} parentNodeDef
	 * @param {?} def
	 * @return {?}
	 */
	function createView(root, renderer, parent, parentNodeDef, def) {
	    var /** @type {?} */ nodes = new Array(def.nodes.length);
	    var /** @type {?} */ disposables = def.outputCount ? new Array(def.outputCount) : null;
	    var /** @type {?} */ view = {
	        def: def,
	        parent: parent,
	        viewContainerParent: null, parentNodeDef: parentNodeDef,
	        context: null,
	        component: null, nodes: nodes,
	        state: 1 /* FirstCheck */ | 2 /* ChecksEnabled */, root: root, renderer: renderer,
	        oldValues: new Array(def.bindingCount), disposables: disposables
	    };
	    return view;
	}
	/**
	 * @param {?} view
	 * @param {?} component
	 * @param {?} context
	 * @return {?}
	 */
	function initView(view, component, context) {
	    view.component = component;
	    view.context = context;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function createViewNodes(view) {
	    var /** @type {?} */ renderHost;
	    if (isComponentView(view)) {
	        var /** @type {?} */ hostDef = view.parentNodeDef;
	        renderHost = asElementData(/** @type {?} */ ((view.parent)), /** @type {?} */ ((((hostDef)).parent)).index).renderElement;
	    }
	    var /** @type {?} */ def = view.def;
	    var /** @type {?} */ nodes = view.nodes;
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        Services.setCurrentNode(view, i);
	        var /** @type {?} */ nodeData = void 0;
	        switch (nodeDef.flags & 100673535 /* Types */) {
	            case 1 /* TypeElement */:
	                var /** @type {?} */ el = (createElement(view, renderHost, nodeDef));
	                var /** @type {?} */ componentView = ((undefined));
	                if (nodeDef.flags & 16777216 /* ComponentView */) {
	                    var /** @type {?} */ compViewDef = resolveViewDefinition(/** @type {?} */ ((((nodeDef.element)).componentView)));
	                    var /** @type {?} */ rendererType = ((nodeDef.element)).componentRendererType;
	                    var /** @type {?} */ compRenderer = void 0;
	                    if (!rendererType) {
	                        compRenderer = view.root.renderer;
	                    }
	                    else {
	                        compRenderer = view.root.rendererFactory.createRenderer(el, rendererType);
	                    }
	                    componentView = createView(view.root, compRenderer, view, /** @type {?} */ ((nodeDef.element)).componentProvider, compViewDef);
	                }
	                listenToElementOutputs(view, componentView, nodeDef, el);
	                nodeData = ({
	                    renderElement: el,
	                    componentView: componentView,
	                    viewContainer: null,
	                    template: /** @type {?} */ ((nodeDef.element)).template ? createTemplateData(view, nodeDef) : undefined
	                });
	                if (nodeDef.flags & 8388608 /* EmbeddedViews */) {
	                    nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);
	                }
	                break;
	            case 2 /* TypeText */:
	                nodeData = (createText(view, renderHost, nodeDef));
	                break;
	            case 256 /* TypeClassProvider */:
	            case 512 /* TypeFactoryProvider */:
	            case 1024 /* TypeUseExistingProvider */:
	            case 128 /* TypeValueProvider */: {
	                var /** @type {?} */ instance = createProviderInstance(view, nodeDef);
	                nodeData = ({ instance: instance });
	                break;
	            }
	            case 8 /* TypePipe */: {
	                var /** @type {?} */ instance = createPipeInstance(view, nodeDef);
	                nodeData = ({ instance: instance });
	                break;
	            }
	            case 8192 /* TypeDirective */: {
	                var /** @type {?} */ instance = createDirectiveInstance(view, nodeDef);
	                nodeData = ({ instance: instance });
	                if (nodeDef.flags & 16384 /* Component */) {
	                    var /** @type {?} */ compView = asElementData(view, /** @type {?} */ ((nodeDef.parent)).index).componentView;
	                    initView(compView, instance, instance);
	                }
	                break;
	            }
	            case 16 /* TypePureArray */:
	            case 32 /* TypePureObject */:
	            case 64 /* TypePurePipe */:
	                nodeData = (createPureExpression(view, nodeDef));
	                break;
	            case 33554432 /* TypeContentQuery */:
	            case 67108864 /* TypeViewQuery */:
	                nodeData = (createQuery());
	                break;
	            case 4 /* TypeNgContent */:
	                appendNgContent(view, renderHost, nodeDef);
	                // no runtime data needed for NgContent...
	                nodeData = undefined;
	                break;
	        }
	        nodes[i] = nodeData;
	    }
	    // Create the ViewData.nodes of component views after we created everything else,
	    // so that e.g. ng-content works
	    execComponentViewsAction(view, ViewAction.CreateViewNodes);
	    // fill static content and view queries
	    execQueriesAction(view, 33554432 /* TypeContentQuery */ | 67108864 /* TypeViewQuery */, 134217728 /* StaticQuery */, 0 /* CheckAndUpdate */);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function checkNoChangesView(view) {
	    Services.updateDirectives(view, 1 /* CheckNoChanges */);
	    execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);
	    Services.updateRenderer(view, 1 /* CheckNoChanges */);
	    execComponentViewsAction(view, ViewAction.CheckNoChanges);
	    // Note: We don't check queries for changes as we didn't do this in v2.x.
	    // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function checkAndUpdateView(view) {
	    Services.updateDirectives(view, 0 /* CheckAndUpdate */);
	    execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);
	    execQueriesAction(view, 33554432 /* TypeContentQuery */, 268435456 /* DynamicQuery */, 0 /* CheckAndUpdate */);
	    callLifecycleHooksChildrenFirst(view, 1048576 /* AfterContentChecked */ |
	        (view.state & 1 /* FirstCheck */ ? 524288 /* AfterContentInit */ : 0));
	    Services.updateRenderer(view, 0 /* CheckAndUpdate */);
	    execComponentViewsAction(view, ViewAction.CheckAndUpdate);
	    execQueriesAction(view, 67108864 /* TypeViewQuery */, 268435456 /* DynamicQuery */, 0 /* CheckAndUpdate */);
	    callLifecycleHooksChildrenFirst(view, 4194304 /* AfterViewChecked */ |
	        (view.state & 1 /* FirstCheck */ ? 2097152 /* AfterViewInit */ : 0));
	    if (view.def.flags & 2 /* OnPush */) {
	        view.state &= ~2 /* ChecksEnabled */;
	    }
	    view.state &= ~1 /* FirstCheck */;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    if (argStyle === 0 /* Inline */) {
	        return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    }
	    else {
	        return checkAndUpdateNodeDynamic(view, nodeDef, v0);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ changed = false;
	    switch (nodeDef.flags & 100673535 /* Types */) {
	        case 1 /* TypeElement */:
	            changed = checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	        case 2 /* TypeText */:
	            changed = checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	        case 8192 /* TypeDirective */:
	            changed =
	                checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	        case 16 /* TypePureArray */:
	        case 32 /* TypePureObject */:
	        case 64 /* TypePurePipe */:
	            changed =
	                checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	            break;
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} values
	 * @return {?}
	 */
	function checkAndUpdateNodeDynamic(view, nodeDef, values) {
	    var /** @type {?} */ changed = false;
	    switch (nodeDef.flags & 100673535 /* Types */) {
	        case 1 /* TypeElement */:
	            changed = checkAndUpdateElementDynamic(view, nodeDef, values);
	            break;
	        case 2 /* TypeText */:
	            changed = checkAndUpdateTextDynamic(view, nodeDef, values);
	            break;
	        case 8192 /* TypeDirective */:
	            changed = checkAndUpdateDirectiveDynamic(view, nodeDef, values);
	            break;
	        case 16 /* TypePureArray */:
	        case 32 /* TypePureObject */:
	        case 64 /* TypePurePipe */:
	            changed = checkAndUpdatePureExpressionDynamic(view, nodeDef, values);
	            break;
	    }
	    if (changed) {
	        // Update oldValues after all bindings have been updated,
	        // as a setter for a property might update other properties.
	        var /** @type {?} */ bindLen = nodeDef.bindings.length;
	        var /** @type {?} */ bindingStart = nodeDef.bindingIndex;
	        var /** @type {?} */ oldValues = view.oldValues;
	        for (var /** @type {?} */ i = 0; i < bindLen; i++) {
	            oldValues[bindingStart + i] = values[i];
	        }
	    }
	    return changed;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    if (argStyle === 0 /* Inline */) {
	        checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    }
	    else {
	        checkNoChangesNodeDynamic(view, nodeDef, v0);
	    }
	    // Returning false is ok here as we would have thrown in case of a change.
	    return false;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} v0
	 * @param {?} v1
	 * @param {?} v2
	 * @param {?} v3
	 * @param {?} v4
	 * @param {?} v5
	 * @param {?} v6
	 * @param {?} v7
	 * @param {?} v8
	 * @param {?} v9
	 * @return {?}
	 */
	function checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ bindLen = nodeDef.bindings.length;
	    if (bindLen > 0)
	        checkBindingNoChanges(view, nodeDef, 0, v0);
	    if (bindLen > 1)
	        checkBindingNoChanges(view, nodeDef, 1, v1);
	    if (bindLen > 2)
	        checkBindingNoChanges(view, nodeDef, 2, v2);
	    if (bindLen > 3)
	        checkBindingNoChanges(view, nodeDef, 3, v3);
	    if (bindLen > 4)
	        checkBindingNoChanges(view, nodeDef, 4, v4);
	    if (bindLen > 5)
	        checkBindingNoChanges(view, nodeDef, 5, v5);
	    if (bindLen > 6)
	        checkBindingNoChanges(view, nodeDef, 6, v6);
	    if (bindLen > 7)
	        checkBindingNoChanges(view, nodeDef, 7, v7);
	    if (bindLen > 8)
	        checkBindingNoChanges(view, nodeDef, 8, v8);
	    if (bindLen > 9)
	        checkBindingNoChanges(view, nodeDef, 9, v9);
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} values
	 * @return {?}
	 */
	function checkNoChangesNodeDynamic(view, nodeDef, values) {
	    for (var /** @type {?} */ i = 0; i < values.length; i++) {
	        checkBindingNoChanges(view, nodeDef, i, values[i]);
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @return {?}
	 */
	function checkNoChangesQuery(view, nodeDef) {
	    var /** @type {?} */ queryList = asQueryList(view, nodeDef.index);
	    if (queryList.dirty) {
	        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.index), "Query " + ((nodeDef.query)).id + " not dirty", "Query " + ((nodeDef.query)).id + " dirty", (view.state & 1 /* FirstCheck */) !== 0);
	    }
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function destroyView(view) {
	    if (view.state & 8 /* Destroyed */) {
	        return;
	    }
	    execEmbeddedViewsAction(view, ViewAction.Destroy);
	    execComponentViewsAction(view, ViewAction.Destroy);
	    callLifecycleHooksChildrenFirst(view, 65536 /* OnDestroy */);
	    if (view.disposables) {
	        for (var /** @type {?} */ i = 0; i < view.disposables.length; i++) {
	            view.disposables[i]();
	        }
	    }
	    if (view.renderer.destroyNode) {
	        destroyViewNodes(view);
	    }
	    if (isComponentView(view)) {
	        view.renderer.destroy();
	    }
	    view.state |= 8 /* Destroyed */;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function destroyViewNodes(view) {
	    var /** @type {?} */ len = view.def.nodes.length;
	    for (var /** @type {?} */ i = 0; i < len; i++) {
	        var /** @type {?} */ def = view.def.nodes[i];
	        if (def.flags & 1 /* TypeElement */) {
	            ((view.renderer.destroyNode))(asElementData(view, i).renderElement);
	        }
	        else if (def.flags & 2 /* TypeText */) {
	            ((view.renderer.destroyNode))(asTextData(view, i).renderText);
	        }
	    }
	}
	var ViewAction = {};
	ViewAction.CreateViewNodes = 0;
	ViewAction.CheckNoChanges = 1;
	ViewAction.CheckAndUpdate = 2;
	ViewAction.Destroy = 3;
	ViewAction[ViewAction.CreateViewNodes] = "CreateViewNodes";
	ViewAction[ViewAction.CheckNoChanges] = "CheckNoChanges";
	ViewAction[ViewAction.CheckAndUpdate] = "CheckAndUpdate";
	ViewAction[ViewAction.Destroy] = "Destroy";
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function execComponentViewsAction(view, action) {
	    var /** @type {?} */ def = view.def;
	    if (!(def.nodeFlags & 16777216 /* ComponentView */)) {
	        return;
	    }
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        if (nodeDef.flags & 16777216 /* ComponentView */) {
	            // a leaf
	            callViewAction(asElementData(view, i).componentView, action);
	        }
	        else if ((nodeDef.childFlags & 16777216 /* ComponentView */) === 0) {
	            // a parent with leafs
	            // no child is a component,
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function execEmbeddedViewsAction(view, action) {
	    var /** @type {?} */ def = view.def;
	    if (!(def.nodeFlags & 8388608 /* EmbeddedViews */)) {
	        return;
	    }
	    for (var /** @type {?} */ i = 0; i < def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = def.nodes[i];
	        if (nodeDef.flags & 8388608 /* EmbeddedViews */) {
	            // a leaf
	            var /** @type {?} */ embeddedViews = ((asElementData(view, i).viewContainer))._embeddedViews;
	            for (var /** @type {?} */ k = 0; k < embeddedViews.length; k++) {
	                callViewAction(embeddedViews[k], action);
	            }
	        }
	        else if ((nodeDef.childFlags & 8388608 /* EmbeddedViews */) === 0) {
	            // a parent with leafs
	            // no child is a component,
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} action
	 * @return {?}
	 */
	function callViewAction(view, action) {
	    var /** @type {?} */ viewState = view.state;
	    switch (action) {
	        case ViewAction.CheckNoChanges:
	            if ((viewState & 2 /* ChecksEnabled */) &&
	                (viewState & (4 /* Errored */ | 8 /* Destroyed */)) === 0) {
	                checkNoChangesView(view);
	            }
	            break;
	        case ViewAction.CheckAndUpdate:
	            if ((viewState & 2 /* ChecksEnabled */) &&
	                (viewState & (4 /* Errored */ | 8 /* Destroyed */)) === 0) {
	                checkAndUpdateView(view);
	            }
	            break;
	        case ViewAction.Destroy:
	            destroyView(view);
	            break;
	        case ViewAction.CreateViewNodes:
	            createViewNodes(view);
	            break;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} queryFlags
	 * @param {?} staticDynamicQueryFlag
	 * @param {?} checkType
	 * @return {?}
	 */
	function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {
	    if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {
	        return;
	    }
	    var /** @type {?} */ nodeCount = view.def.nodes.length;
	    for (var /** @type {?} */ i = 0; i < nodeCount; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {
	            Services.setCurrentNode(view, nodeDef.index);
	            switch (checkType) {
	                case 0 /* CheckAndUpdate */:
	                    checkAndUpdateQuery(view, nodeDef);
	                    break;
	                case 1 /* CheckNoChanges */:
	                    checkNoChangesQuery(view, nodeDef);
	                    break;
	            }
	        }
	        if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {
	            // no child has a matching query
	            // then skip the children
	            i += nodeDef.childCount;
	        }
	    }
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var initialized = false;
	/**
	 * @return {?}
	 */
	function initServicesIfNeeded() {
	    if (initialized) {
	        return;
	    }
	    initialized = true;
	    var /** @type {?} */ services = isDevMode() ? createDebugServices() : createProdServices();
	    Services.setCurrentNode = services.setCurrentNode;
	    Services.createRootView = services.createRootView;
	    Services.createEmbeddedView = services.createEmbeddedView;
	    Services.checkAndUpdateView = services.checkAndUpdateView;
	    Services.checkNoChangesView = services.checkNoChangesView;
	    Services.destroyView = services.destroyView;
	    Services.resolveDep = resolveDep;
	    Services.createDebugContext = services.createDebugContext;
	    Services.handleEvent = services.handleEvent;
	    Services.updateDirectives = services.updateDirectives;
	    Services.updateRenderer = services.updateRenderer;
	    Services.dirtyParentQueries = dirtyParentQueries;
	}
	/**
	 * @return {?}
	 */
	function createProdServices() {
	    return {
	        setCurrentNode: function () { },
	        createRootView: createProdRootView,
	        createEmbeddedView: createEmbeddedView,
	        checkAndUpdateView: checkAndUpdateView,
	        checkNoChangesView: checkNoChangesView,
	        destroyView: destroyView,
	        createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },
	        handleEvent: function (view, nodeIndex, eventName, event) { return view.def.handleEvent(view, nodeIndex, eventName, event); },
	        updateDirectives: function (view, checkType) { return view.def.updateDirectives(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :
	            prodCheckNoChangesNode, view); },
	        updateRenderer: function (view, checkType) { return view.def.updateRenderer(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :
	            prodCheckNoChangesNode, view); },
	    };
	}
	/**
	 * @return {?}
	 */
	function createDebugServices() {
	    return {
	        setCurrentNode: debugSetCurrentNode,
	        createRootView: debugCreateRootView,
	        createEmbeddedView: debugCreateEmbeddedView,
	        checkAndUpdateView: debugCheckAndUpdateView,
	        checkNoChangesView: debugCheckNoChangesView,
	        destroyView: debugDestroyView,
	        createDebugContext: function (view, nodeIndex) { return new DebugContext_(view, nodeIndex); },
	        handleEvent: debugHandleEvent,
	        updateDirectives: debugUpdateDirectives,
	        updateRenderer: debugUpdateRenderer
	    };
	}
	/**
	 * @param {?} elInjector
	 * @param {?} projectableNodes
	 * @param {?} rootSelectorOrNode
	 * @param {?} def
	 * @param {?} ngModule
	 * @param {?=} context
	 * @return {?}
	 */
	function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
	    var /** @type {?} */ rendererFactory = ngModule.injector.get(RendererFactory2);
	    return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);
	}
	/**
	 * @param {?} elInjector
	 * @param {?} projectableNodes
	 * @param {?} rootSelectorOrNode
	 * @param {?} def
	 * @param {?} ngModule
	 * @param {?=} context
	 * @return {?}
	 */
	function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
	    var /** @type {?} */ rendererFactory = ngModule.injector.get(RendererFactory2);
	    var /** @type {?} */ root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);
	    return callWithDebugContext(DebugAction.create, createRootView, null, [root, def, context]);
	}
	/**
	 * @param {?} elInjector
	 * @param {?} ngModule
	 * @param {?} rendererFactory
	 * @param {?} projectableNodes
	 * @param {?} rootSelectorOrNode
	 * @return {?}
	 */
	function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {
	    var /** @type {?} */ sanitizer = ngModule.injector.get(Sanitizer);
	    var /** @type {?} */ renderer = rendererFactory.createRenderer(null, null);
	    return {
	        ngModule: ngModule,
	        injector: elInjector, projectableNodes: projectableNodes,
	        selectorOrNode: rootSelectorOrNode, sanitizer: sanitizer, rendererFactory: rendererFactory, renderer: renderer
	    };
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function prodCheckAndUpdateNode(view, nodeIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	    checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    return (nodeDef.flags & 112 /* CatPureExpression */) ?
	        asPureExpressionData(view, nodeIndex).value :
	        undefined;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} argStyle
	 * @param {?=} v0
	 * @param {?=} v1
	 * @param {?=} v2
	 * @param {?=} v3
	 * @param {?=} v4
	 * @param {?=} v5
	 * @param {?=} v6
	 * @param {?=} v7
	 * @param {?=} v8
	 * @param {?=} v9
	 * @return {?}
	 */
	function prodCheckNoChangesNode(view, nodeIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
	    var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	    checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
	    return (nodeDef.flags & 112 /* CatPureExpression */) ?
	        asPureExpressionData(view, nodeIndex).value :
	        undefined;
	}
	/**
	 * @param {?} parent
	 * @param {?} anchorDef
	 * @param {?=} context
	 * @return {?}
	 */
	function debugCreateEmbeddedView(parent, anchorDef, context) {
	    return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parent, anchorDef, context]);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function debugCheckAndUpdateView(view) {
	    return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function debugCheckNoChangesView(view) {
	    return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function debugDestroyView(view) {
	    return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);
	}
	var DebugAction = {};
	DebugAction.create = 0;
	DebugAction.detectChanges = 1;
	DebugAction.checkNoChanges = 2;
	DebugAction.destroy = 3;
	DebugAction.handleEvent = 4;
	DebugAction[DebugAction.create] = "create";
	DebugAction[DebugAction.detectChanges] = "detectChanges";
	DebugAction[DebugAction.checkNoChanges] = "checkNoChanges";
	DebugAction[DebugAction.destroy] = "destroy";
	DebugAction[DebugAction.handleEvent] = "handleEvent";
	var _currentAction;
	var _currentView;
	var _currentNodeIndex;
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function debugSetCurrentNode(view, nodeIndex) {
	    _currentView = view;
	    _currentNodeIndex = nodeIndex;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @param {?} eventName
	 * @param {?} event
	 * @return {?}
	 */
	function debugHandleEvent(view, nodeIndex, eventName, event) {
	    debugSetCurrentNode(view, nodeIndex);
	    return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);
	}
	/**
	 * @param {?} view
	 * @param {?} checkType
	 * @return {?}
	 */
	function debugUpdateDirectives(view, checkType) {
	    if (view.state & 8 /* Destroyed */) {
	        throw viewDestroyedError(DebugAction[_currentAction]);
	    }
	    debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));
	    return view.def.updateDirectives(debugCheckDirectivesFn, view);
	    /**
	     * @param {?} view
	     * @param {?} nodeIndex
	     * @param {?} argStyle
	     * @param {...?} values
	     * @return {?}
	     */
	    function debugCheckDirectivesFn(view, nodeIndex, argStyle) {
	        var values = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            values[_i - 3] = arguments[_i];
	        }
	        var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	        if (checkType === 0 /* CheckAndUpdate */) {
	            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
	        }
	        else {
	            debugCheckNoChangesNode(view, nodeDef, argStyle, values);
	        }
	        if (nodeDef.flags & 8192 /* TypeDirective */) {
	            debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));
	        }
	        return (nodeDef.flags & 112 /* CatPureExpression */) ?
	            asPureExpressionData(view, nodeDef.index).value :
	            undefined;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} checkType
	 * @return {?}
	 */
	function debugUpdateRenderer(view, checkType) {
	    if (view.state & 8 /* Destroyed */) {
	        throw viewDestroyedError(DebugAction[_currentAction]);
	    }
	    debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));
	    return view.def.updateRenderer(debugCheckRenderNodeFn, view);
	    /**
	     * @param {?} view
	     * @param {?} nodeIndex
	     * @param {?} argStyle
	     * @param {...?} values
	     * @return {?}
	     */
	    function debugCheckRenderNodeFn(view, nodeIndex, argStyle) {
	        var values = [];
	        for (var _i = 3; _i < arguments.length; _i++) {
	            values[_i - 3] = arguments[_i];
	        }
	        var /** @type {?} */ nodeDef = view.def.nodes[nodeIndex];
	        if (checkType === 0 /* CheckAndUpdate */) {
	            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
	        }
	        else {
	            debugCheckNoChangesNode(view, nodeDef, argStyle, values);
	        }
	        if (nodeDef.flags & 3 /* CatRenderNode */) {
	            debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));
	        }
	        return (nodeDef.flags & 112 /* CatPureExpression */) ?
	            asPureExpressionData(view, nodeDef.index).value :
	            undefined;
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?} givenValues
	 * @return {?}
	 */
	function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {
	    var /** @type {?} */ changed = ((checkAndUpdateNode)).apply(void 0, [view, nodeDef, argStyle].concat(givenValues));
	    if (changed) {
	        var /** @type {?} */ values = argStyle === 1 /* Dynamic */ ? givenValues[0] : givenValues;
	        if (nodeDef.flags & 8192 /* TypeDirective */) {
	            var /** @type {?} */ bindingValues = {};
	            for (var /** @type {?} */ i = 0; i < nodeDef.bindings.length; i++) {
	                var /** @type {?} */ binding = nodeDef.bindings[i];
	                var /** @type {?} */ value = values[i];
	                if (binding.flags & 8 /* TypeProperty */) {
	                    bindingValues[normalizeDebugBindingName(/** @type {?} */ ((binding.nonMinifiedName)))] =
	                        normalizeDebugBindingValue(value);
	                }
	            }
	            var /** @type {?} */ elDef = ((nodeDef.parent));
	            var /** @type {?} */ el = asElementData(view, elDef.index).renderElement;
	            if (!((elDef.element)).name) {
	                // a comment.
	                view.renderer.setValue(el, "bindings=" + JSON.stringify(bindingValues, null, 2));
	            }
	            else {
	                // a regular element.
	                for (var /** @type {?} */ attr in bindingValues) {
	                    var /** @type {?} */ value = bindingValues[attr];
	                    if (value != null) {
	                        view.renderer.setAttribute(el, attr, value);
	                    }
	                    else {
	                        view.renderer.removeAttribute(el, attr);
	                    }
	                }
	            }
	        }
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} argStyle
	 * @param {?} values
	 * @return {?}
	 */
	function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {
	    ((checkNoChangesNode)).apply(void 0, [view, nodeDef, argStyle].concat(values));
	}
	/**
	 * @param {?} name
	 * @return {?}
	 */
	function normalizeDebugBindingName(name) {
	    // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers
	    name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
	    return "ng-reflect-" + name;
	}
	var CAMEL_CASE_REGEXP = /([A-Z])/g;
	/**
	 * @param {?} input
	 * @return {?}
	 */
	function camelCaseToDashCase(input) {
	    return input.replace(CAMEL_CASE_REGEXP, function () {
	        var m = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            m[_i] = arguments[_i];
	        }
	        return '-' + m[1].toLowerCase();
	    });
	}
	/**
	 * @param {?} value
	 * @return {?}
	 */
	function normalizeDebugBindingValue(value) {
	    try {
	        // Limit the size of the value as otherwise the DOM just gets polluted.
	        return value != null ? value.toString().slice(0, 30) : value;
	    }
	    catch (e) {
	        return '[ERROR] Exception while trying to serialize the value';
	    }
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function nextDirectiveWithBinding(view, nodeIndex) {
	    for (var /** @type {?} */ i = nodeIndex; i < view.def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if (nodeDef.flags & 8192 /* TypeDirective */ && nodeDef.bindings && nodeDef.bindings.length) {
	            return i;
	        }
	    }
	    return null;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function nextRenderNodeWithBinding(view, nodeIndex) {
	    for (var /** @type {?} */ i = nodeIndex; i < view.def.nodes.length; i++) {
	        var /** @type {?} */ nodeDef = view.def.nodes[i];
	        if ((nodeDef.flags & 3 /* CatRenderNode */) && nodeDef.bindings && nodeDef.bindings.length) {
	            return i;
	        }
	    }
	    return null;
	}
	var DebugContext_ = (function () {
	    /**
	     * @param {?} view
	     * @param {?} nodeIndex
	     */
	    function DebugContext_(view, nodeIndex) {
	        this.view = view;
	        this.nodeIndex = nodeIndex;
	        if (nodeIndex == null) {
	            this.nodeIndex = nodeIndex = 0;
	        }
	        this.nodeDef = view.def.nodes[nodeIndex];
	        var elDef = this.nodeDef;
	        var elView = view;
	        while (elDef && (elDef.flags & 1 /* TypeElement */) === 0) {
	            elDef = elDef.parent;
	        }
	        if (!elDef) {
	            while (!elDef && elView) {
	                elDef = viewParentEl(elView);
	                elView = elView.parent;
	            }
	        }
	        this.elDef = elDef;
	        this.elView = elView;
	    }
	    Object.defineProperty(DebugContext_.prototype, "elOrCompView", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            // Has to be done lazily as we use the DebugContext also during creation of elements...
	            return asElementData(this.elView, this.elDef.index).componentView || this.view;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "injector", {
	        /**
	         * @return {?}
	         */
	        get: function () { return createInjector(this.elView, this.elDef); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "component", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.elOrCompView.component; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "context", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.elOrCompView.context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "providerTokens", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ tokens = [];
	            if (this.elDef) {
	                for (var /** @type {?} */ i = this.elDef.index + 1; i <= this.elDef.index + this.elDef.childCount; i++) {
	                    var /** @type {?} */ childDef = this.elView.def.nodes[i];
	                    if (childDef.flags & 10112 /* CatProvider */) {
	                        tokens.push(/** @type {?} */ ((childDef.provider)).token);
	                    }
	                    i += childDef.childCount;
	                }
	            }
	            return tokens;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "references", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ references = {};
	            if (this.elDef) {
	                collectReferences(this.elView, this.elDef, references);
	                for (var /** @type {?} */ i = this.elDef.index + 1; i <= this.elDef.index + this.elDef.childCount; i++) {
	                    var /** @type {?} */ childDef = this.elView.def.nodes[i];
	                    if (childDef.flags & 10112 /* CatProvider */) {
	                        collectReferences(this.elView, childDef, references);
	                    }
	                    i += childDef.childCount;
	                }
	            }
	            return references;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "componentRenderElement", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            var /** @type {?} */ elData = findHostElement(this.elOrCompView);
	            return elData ? elData.renderElement : undefined;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugContext_.prototype, "renderNode", {
	        /**
	         * @return {?}
	         */
	        get: function () {
	            return this.nodeDef.flags & 2 /* TypeText */ ? renderNode(this.view, this.nodeDef) :
	                renderNode(this.elView, this.elDef);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} console
	     * @param {...?} values
	     * @return {?}
	     */
	    DebugContext_.prototype.logError = function (console) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var /** @type {?} */ logViewDef;
	        var /** @type {?} */ logNodeIndex;
	        if (this.nodeDef.flags & 2 /* TypeText */) {
	            logViewDef = this.view.def;
	            logNodeIndex = this.nodeDef.index;
	        }
	        else {
	            logViewDef = this.elView.def;
	            logNodeIndex = this.elDef.index;
	        }
	        // Note: we only generate a log function for text and element nodes
	        // to make the generated code as small as possible.
	        var /** @type {?} */ renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);
	        var /** @type {?} */ currRenderNodeIndex = -1;
	        var /** @type {?} */ nodeLogger = function () {
	            currRenderNodeIndex++;
	            if (currRenderNodeIndex === renderNodeIndex) {
	                return (_a = console.error).bind.apply(_a, [console].concat(values));
	            }
	            else {
	                return NOOP;
	            }
	            var _a;
	        }; /** @type {?} */
	        ((logViewDef.factory))(nodeLogger);
	        if (currRenderNodeIndex < renderNodeIndex) {
	            console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');
	            console.error.apply(console, values);
	        }
	    };
	    return DebugContext_;
	}());
	/**
	 * @param {?} viewDef
	 * @param {?} nodeIndex
	 * @return {?}
	 */
	function getRenderNodeIndex(viewDef$$1, nodeIndex) {
	    var /** @type {?} */ renderNodeIndex = -1;
	    for (var /** @type {?} */ i = 0; i <= nodeIndex; i++) {
	        var /** @type {?} */ nodeDef = viewDef$$1.nodes[i];
	        if (nodeDef.flags & 3 /* CatRenderNode */) {
	            renderNodeIndex++;
	        }
	    }
	    return renderNodeIndex;
	}
	/**
	 * @param {?} view
	 * @return {?}
	 */
	function findHostElement(view) {
	    while (view && !isComponentView(view)) {
	        view = ((view.parent));
	    }
	    if (view.parent) {
	        return asElementData(view.parent, /** @type {?} */ ((viewParentEl(view))).index);
	    }
	    return null;
	}
	/**
	 * @param {?} view
	 * @param {?} nodeDef
	 * @param {?} references
	 * @return {?}
	 */
	function collectReferences(view, nodeDef, references) {
	    for (var /** @type {?} */ refName in nodeDef.references) {
	        references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);
	    }
	}
	/**
	 * @param {?} action
	 * @param {?} fn
	 * @param {?} self
	 * @param {?} args
	 * @return {?}
	 */
	function callWithDebugContext(action, fn, self, args) {
	    var /** @type {?} */ oldAction = _currentAction;
	    var /** @type {?} */ oldView = _currentView;
	    var /** @type {?} */ oldNodeIndex = _currentNodeIndex;
	    try {
	        _currentAction = action;
	        var /** @type {?} */ result = fn.apply(self, args);
	        _currentView = oldView;
	        _currentNodeIndex = oldNodeIndex;
	        _currentAction = oldAction;
	        return result;
	    }
	    catch (e) {
	        if (isViewDebugError(e) || !_currentView) {
	            throw e;
	        }
	        _currentView.state |= 4 /* Errored */;
	        throw viewWrappedDebugError(e, /** @type {?} */ ((getCurrentDebugContext())));
	    }
	}
	/**
	 * @return {?}
	 */
	function getCurrentDebugContext() {
	    return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;
	}
	var DebugRendererFactory2 = (function () {
	    /**
	     * @param {?} delegate
	     */
	    function DebugRendererFactory2(delegate) {
	        this.delegate = delegate;
	    }
	    /**
	     * @param {?} element
	     * @param {?} renderData
	     * @return {?}
	     */
	    DebugRendererFactory2.prototype.createRenderer = function (element, renderData) {
	        return new DebugRenderer2(this.delegate.createRenderer(element, renderData));
	    };
	    return DebugRendererFactory2;
	}());
	var DebugRenderer2 = (function () {
	    /**
	     * @param {?} delegate
	     */
	    function DebugRenderer2(delegate) {
	        this.delegate = delegate;
	    }
	    Object.defineProperty(DebugRenderer2.prototype, "data", {
	        /**
	         * @return {?}
	         */
	        get: function () { return this.delegate.data; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DebugRenderer2.prototype.destroyNode = function (node) {
	        removeDebugNodeFromIndex(/** @type {?} */ ((getDebugNode(node))));
	        if (this.delegate.destroyNode) {
	            this.delegate.destroyNode(node);
	        }
	    };
	    /**
	     * @return {?}
	     */
	    DebugRenderer2.prototype.destroy = function () { this.delegate.destroy(); };
	    /**
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DebugRenderer2.prototype.createElement = function (name, namespace) {
	        var /** @type {?} */ el = this.delegate.createElement(name, namespace);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            var /** @type {?} */ debugEl = new DebugElement(el, null, debugCtx);
	            debugEl.name = name;
	            indexDebugNode(debugEl);
	        }
	        return el;
	    };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.createComment = function (value) {
	        var /** @type {?} */ comment = this.delegate.createComment(value);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            indexDebugNode(new DebugNode(comment, null, debugCtx));
	        }
	        return comment;
	    };
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.createText = function (value) {
	        var /** @type {?} */ text = this.delegate.createText(value);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            indexDebugNode(new DebugNode(text, null, debugCtx));
	        }
	        return text;
	    };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @return {?}
	     */
	    DebugRenderer2.prototype.appendChild = function (parent, newChild) {
	        var /** @type {?} */ debugEl = getDebugNode(parent);
	        var /** @type {?} */ debugChildEl = getDebugNode(newChild);
	        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
	            debugEl.addChild(debugChildEl);
	        }
	        this.delegate.appendChild(parent, newChild);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} newChild
	     * @param {?} refChild
	     * @return {?}
	     */
	    DebugRenderer2.prototype.insertBefore = function (parent, newChild, refChild) {
	        var /** @type {?} */ debugEl = getDebugNode(parent);
	        var /** @type {?} */ debugChildEl = getDebugNode(newChild);
	        var /** @type {?} */ debugRefEl = ((getDebugNode(refChild)));
	        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
	            debugEl.insertBefore(debugRefEl, debugChildEl);
	        }
	        this.delegate.insertBefore(parent, newChild, refChild);
	    };
	    /**
	     * @param {?} parent
	     * @param {?} oldChild
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeChild = function (parent, oldChild) {
	        var /** @type {?} */ debugEl = getDebugNode(parent);
	        var /** @type {?} */ debugChildEl = getDebugNode(oldChild);
	        if (debugEl && debugChildEl && debugEl instanceof DebugElement) {
	            debugEl.removeChild(debugChildEl);
	        }
	        this.delegate.removeChild(parent, oldChild);
	    };
	    /**
	     * @param {?} selectorOrNode
	     * @return {?}
	     */
	    DebugRenderer2.prototype.selectRootElement = function (selectorOrNode) {
	        var /** @type {?} */ el = this.delegate.selectRootElement(selectorOrNode);
	        var /** @type {?} */ debugCtx = getCurrentDebugContext();
	        if (debugCtx) {
	            indexDebugNode(new DebugElement(el, null, debugCtx));
	        }
	        return el;
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setAttribute = function (el, name, value, namespace) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            var /** @type {?} */ fullName = namespace ? namespace + ':' + name : name;
	            debugEl.attributes[fullName] = value;
	        }
	        this.delegate.setAttribute(el, name, value, namespace);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?=} namespace
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeAttribute = function (el, name, namespace) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            var /** @type {?} */ fullName = namespace ? namespace + ':' + name : name;
	            debugEl.attributes[fullName] = null;
	        }
	        this.delegate.removeAttribute(el, name, namespace);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DebugRenderer2.prototype.addClass = function (el, name) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.classes[name] = true;
	        }
	        this.delegate.addClass(el, name);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeClass = function (el, name) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.classes[name] = false;
	        }
	        this.delegate.removeClass(el, name);
	    };
	    /**
	     * @param {?} el
	     * @param {?} style
	     * @param {?} value
	     * @param {?} flags
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setStyle = function (el, style, value, flags) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.styles[style] = value;
	        }
	        this.delegate.setStyle(el, style, value, flags);
	    };
	    /**
	     * @param {?} el
	     * @param {?} style
	     * @param {?} flags
	     * @return {?}
	     */
	    DebugRenderer2.prototype.removeStyle = function (el, style, flags) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.styles[style] = null;
	        }
	        this.delegate.removeStyle(el, style, flags);
	    };
	    /**
	     * @param {?} el
	     * @param {?} name
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setProperty = function (el, name, value) {
	        var /** @type {?} */ debugEl = getDebugNode(el);
	        if (debugEl && debugEl instanceof DebugElement) {
	            debugEl.properties[name] = value;
	        }
	        this.delegate.setProperty(el, name, value);
	    };
	    /**
	     * @param {?} target
	     * @param {?} eventName
	     * @param {?} callback
	     * @return {?}
	     */
	    DebugRenderer2.prototype.listen = function (target, eventName, callback) {
	        if (typeof target !== 'string') {
	            var /** @type {?} */ debugEl = getDebugNode(target);
	            if (debugEl) {
	                debugEl.listeners.push(new EventListener(eventName, callback));
	            }
	        }
	        return this.delegate.listen(target, eventName, callback);
	    };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DebugRenderer2.prototype.parentNode = function (node) { return this.delegate.parentNode(node); };
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    DebugRenderer2.prototype.nextSibling = function (node) { return this.delegate.nextSibling(node); };
	    /**
	     * @param {?} node
	     * @param {?} value
	     * @return {?}
	     */
	    DebugRenderer2.prototype.setValue = function (node, value) { return this.delegate.setValue(node, value); };
	    return DebugRenderer2;
	}());
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @return {?}
	 */
	function _iterableDiffersFactory() {
	    return defaultIterableDiffers;
	}
	/**
	 * @return {?}
	 */
	function _keyValueDiffersFactory() {
	    return defaultKeyValueDiffers;
	}
	/**
	 * @param {?=} locale
	 * @return {?}
	 */
	function _localeFactory(locale) {
	    return locale || 'en-US';
	}
	/**
	 * @return {?}
	 */
	function _initViewEngine() {
	    initServicesIfNeeded();
	}
	/**
	 * This module includes the providers of \@angular/core that are needed
	 * to bootstrap components via `ApplicationRef`.
	 *
	 * \@experimental
	 */
	var ApplicationModule = (function () {
	    /**
	     * @param {?} appRef
	     */
	    function ApplicationModule(appRef) {
	    }
	    return ApplicationModule;
	}());
	ApplicationModule.decorators = [
	    { type: NgModule, args: [{
	                providers: [
	                    ApplicationRef_,
	                    { provide: ApplicationRef, useExisting: ApplicationRef_ },
	                    ApplicationInitStatus,
	                    Compiler,
	                    APP_ID_RANDOM_PROVIDER,
	                    { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
	                    { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
	                    {
	                        provide: LOCALE_ID,
	                        useFactory: _localeFactory,
	                        deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
	                    },
	                    { provide: APP_INITIALIZER, useValue: _initViewEngine, multi: true },
	                ]
	            },] },
	];
	/**
	 * @nocollapse
	 */
	ApplicationModule.ctorParameters = function () { return [
	    { type: ApplicationRef, },
	]; };
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var LifecycleHooks = {};
	LifecycleHooks.OnInit = 0;
	LifecycleHooks.OnDestroy = 1;
	LifecycleHooks.DoCheck = 2;
	LifecycleHooks.OnChanges = 3;
	LifecycleHooks.AfterContentInit = 4;
	LifecycleHooks.AfterContentChecked = 5;
	LifecycleHooks.AfterViewInit = 6;
	LifecycleHooks.AfterViewChecked = 7;
	LifecycleHooks[LifecycleHooks.OnInit] = "OnInit";
	LifecycleHooks[LifecycleHooks.OnDestroy] = "OnDestroy";
	LifecycleHooks[LifecycleHooks.DoCheck] = "DoCheck";
	LifecycleHooks[LifecycleHooks.OnChanges] = "OnChanges";
	LifecycleHooks[LifecycleHooks.AfterContentInit] = "AfterContentInit";
	LifecycleHooks[LifecycleHooks.AfterContentChecked] = "AfterContentChecked";
	LifecycleHooks[LifecycleHooks.AfterViewInit] = "AfterViewInit";
	LifecycleHooks[LifecycleHooks.AfterViewChecked] = "AfterViewChecked";
	var LIFECYCLE_HOOKS_VALUES = [
	    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
	    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
	    LifecycleHooks.AfterViewChecked
	];
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * \@experimental Animation support is experimental.
	 */
	/**
	 * `trigger` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `trigger` Creates an animation trigger which will a list of {\@link state state} and {\@link
	 * transition transition} entries that will be evaluated when the expression bound to the trigger
	 * changes.
	 *
	 * Triggers are registered within the component annotation data under the {\@link
	 * Component#animations-anchor animations section}. An animation trigger can be placed on an element
	 * within a template by referencing the name of the trigger followed by the expression value that the
	 * trigger is bound to (in the form of `[\@triggerName]="expression"`.
	 *
	 * ### Usage
	 *
	 * `trigger` will create an animation trigger reference based on the provided `name` value. The
	 * provided `animation` value is expected to be an array consisting of {\@link state state} and {\@link
	 * transition transition} declarations.
	 *
	 * ```typescript
	 * \@Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'my-component-tpl.html',
	 *   animations: [
	 *     trigger("myAnimationTrigger", [
	 *       state(...),
	 *       state(...),
	 *       transition(...),
	 *       transition(...)
	 *     ])
	 *   ]
	 * })
	 * class MyComponent {
	 *   myStatusExp = "something";
	 * }
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger` animation
	 * trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	 * tools/gulp-tasks/validate-commit-message.js ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} name
	 * @param {?} definitions
	 * @return {?}
	 */
	function trigger$1(name, definitions) {
	    return { name: name, definitions: definitions };
	}
	/**
	 * `animate` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `animate` specifies an animation step that will apply the provided `styles` data for a given
	 * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
	 * to be used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link
	 * transition transition}.
	 *
	 * ### Usage
	 *
	 * The `animate` function accepts two input parameters: `timing` and `styles`:
	 *
	 * - `timing` is a string based value that can be a combination of a duration with optional delay
	 * and easing values. The format for the expression breaks down to `duration delay easing`
	 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	 * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
	 * `duration` value in millisecond form.
	 * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
	 * keyframes keyframes}. If left empty then the styles from the destination state will be collected
	 * and used (this is useful when describing an animation step that will complete an animation by
	 * {\@link transition#the-final-animate-call animating to the final state}).
	 *
	 * ```typescript
	 * // various functions for specifying timing data
	 * animate(500, style(...))
	 * animate("1s", style(...))
	 * animate("100ms 0.5s", style(...))
	 * animate("5s ease", style(...))
	 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	 *
	 * // either style() of keyframes() can be used
	 * animate(500, style({ background: "red" }))
	 * animate(500, keyframes([
	 *   style({ background: "blue" })),
	 *   style({ background: "red" }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} timings
	 * @param {?=} styles
	 * @return {?}
	 */
	function animate$1(timings, styles) {
	    if (styles === void 0) { styles = null; }
	    return { type: 4 /* Animate */, styles: styles, timings: timings };
	}
	/**
	 * `group` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are
	 * useful when a series of styles must be animated/closed off at different statrting/ending times.
	 *
	 * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
	 * transition} and it will only continue to the next instruction once all of the inner animation
	 * steps have completed.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `group` animation function can either consist of {\@link
	 * style style} or {\@link animate animate} function calls. Each call to `style()` or `animate()`
	 * within a group will be executed instantly (use {\@link keyframes keyframes} or a {\@link
	 * animate#usage animate() with a delay value} to offset styles to be applied at a later time).
	 *
	 * ```typescript
	 * group([
	 *   animate("1s", { background: "black" }))
	 *   animate("2s", { color: "white" }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @return {?}
	 */
	function group$1(steps) {
	    return { type: 3 /* Group */, steps: steps };
	}
	/**
	 * `sequence` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by
	 * default when an array is passed as animation data into {\@link transition transition}.)
	 *
	 * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
	 * transition} and it will only continue to the next instruction once each of the inner animation
	 * steps have completed.
	 *
	 * To perform animation styling in parallel with other animation steps then have a look at the
	 * {\@link group group} animation function.
	 *
	 * ### Usage
	 *
	 * The `steps` data that is passed into the `sequence` animation function can either consist of
	 * {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply the
	 * provided styling data immediately while a call to `animate()` will apply its styling data over a
	 * given time depending on its timing data.
	 *
	 * ```typescript
	 * sequence([
	 *   style({ opacity: 0 })),
	 *   animate("1s", { opacity: 1 }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @return {?}
	 */
	function sequence$1(steps) {
	    return { type: 2 /* Sequence */, steps: steps };
	}
	/**
	 * `style` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `style` declares a key/value object containing CSS properties/styles that can then be used for
	 * {\@link state animation states}, within an {\@link sequence animation sequence}, or as styling data
	 * for both {\@link animate animate} and {\@link keyframes keyframes}.
	 *
	 * ### Usage
	 *
	 * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
	 * to be defined.
	 *
	 * ```typescript
	 * // string values are used for css properties
	 * style({ background: "red", color: "blue" })
	 *
	 * // numerical (pixel) values are also supported
	 * style({ width: 100, height: 0 })
	 * ```
	 *
	 * #### Auto-styles (using `*`)
	 *
	 * When an asterix (`*`) character is used as a value then it will be detected from the element
	 * being animated and applied as animation data when the animation starts.
	 *
	 * This feature proves useful for a state depending on layout and/or environment factors; in such
	 * cases the styles are calculated just before the animation starts.
	 *
	 * ```typescript
	 * // the steps below will animate from 0 to the
	 * // actual height of the element
	 * style({ height: 0 }),
	 * animate("1s", style({ height: "*" }))
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} tokens
	 * @return {?}
	 */
	function style$1(tokens) {
	    return { type: 6 /* Style */, styles: tokens };
	}
	/**
	 * `state` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `state` declares an animation state within the given trigger. When a state is active within a
	 * component then its associated styles will persist on the element that the trigger is attached to
	 * (even when the animation ends).
	 *
	 * To animate between states, have a look at the animation {\@link transition transition} DSL
	 * function. To register states to an animation trigger please have a look at the {\@link trigger
	 * trigger} function.
	 *
	 * #### The `void` state
	 *
	 * The `void` state value is a reserved word that angular uses to determine when the element is not
	 * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	 * associated element is void).
	 *
	 * #### The `*` (default) state
	 *
	 * The `*` state (when styled) is a fallback state that will be used if the state that is being
	 * animated is not declared within the trigger.
	 *
	 * ### Usage
	 *
	 * `state` will declare an animation state with its associated styles
	 * within the given trigger.
	 *
	 * - `stateNameExpr` can be one or more state names separated by commas.
	 * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
	 * the state has been reached.
	 *
	 * ```typescript
	 * // "void" is a reserved name for a state and is used to represent
	 * // the state in which an element is detached from from the application.
	 * state("void", style({ height: 0 }))
	 *
	 * // user-defined states
	 * state("closed", style({ height: 0 }))
	 * state("open, visible", style({ height: "*" }))
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} name
	 * @param {?} styles
	 * @return {?}
	 */
	function state$1(name, styles) {
	    return { type: 0 /* State */, name: name, styles: styles };
	}
	/**
	 * `keyframes` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
	 * by an `offset` value.
	 *
	 * ### Usage
	 *
	 * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
	 * animation function. Instead of applying animations from where they are currently to their
	 * destination, keyframes can describe how each style entry is applied and at what point within the
	 * animation arc (much like CSS Keyframe Animations do).
	 *
	 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what
	 * percentage of the animate time the styles will be applied.
	 *
	 * ```typescript
	 * // the provided offset values describe when each backgroundColor value is applied.
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red", offset: 0 }),
	 *   style({ backgroundColor: "blue", offset: 0.2 }),
	 *   style({ backgroundColor: "orange", offset: 0.3 }),
	 *   style({ backgroundColor: "black", offset: 1 })
	 * ]))
	 * ```
	 *
	 * Alternatively, if there are no `offset` values used within the style entries then the offsets
	 * will be calculated automatically.
	 *
	 * ```typescript
	 * animate("5s", keyframes([
	 *   style({ backgroundColor: "red" }) // offset = 0
	 *   style({ backgroundColor: "blue" }) // offset = 0.33
	 *   style({ backgroundColor: "orange" }) // offset = 0.66
	 *   style({ backgroundColor: "black" }) // offset = 1
	 * ]))
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} steps
	 * @return {?}
	 */
	function keyframes$1(steps) {
	    return { type: 5 /* KeyframeSequence */, steps: steps };
	}
	/**
	 * `transition` is an animation-specific function that is designed to be used inside of Angular's
	 * animation DSL language. If this information is new, please navigate to the {\@link
	 * Component#animations-anchor component animations metadata page} to gain a better understanding of
	 * how animations in Angular are used.
	 *
	 * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
	 * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
	 * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
	 * and/or ending state).
	 *
	 * A function can also be provided as the `stateChangeExpr` argument for a transition and this
	 * function will be executed each time a state change occurs. If the value returned within the
	 * function is true then the associated animation will be run.
	 *
	 * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
	 * to animate to a state value and persist its styles then one or more {\@link state animation
	 * states} is expected to be defined.
	 *
	 * ### Usage
	 *
	 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	 * what the previous state is and what the current state has become. In other words, if a transition
	 * is defined that matches the old/current state criteria then the associated animation will be
	 * triggered.
	 *
	 * ```typescript
	 * // all transition/state changes are defined within an animation trigger
	 * trigger("myAnimationTrigger", [
	 *   // if a state is defined then its styles will be persisted when the
	 *   // animation has fully completed itself
	 *   state("on", style({ background: "green" })),
	 *   state("off", style({ background: "grey" })),
	 *
	 *   // a transition animation that will be kicked off when the state value
	 *   // bound to "myAnimationTrigger" changes from "on" to "off"
	 *   transition("on => off", animate(500)),
	 *
	 *   // it is also possible to do run the same animation for both directions
	 *   transition("on <=> off", animate(500)),
	 *
	 *   // or to define multiple states pairs separated by commas
	 *   transition("on => off, off => void", animate(500)),
	 *
	 *   // this is a catch-all state change for when an element is inserted into
	 *   // the page and the destination state is unknown
	 *   transition("void => *", [
	 *     style({ opacity: 0 }),
	 *     animate(500)
	 *   ]),
	 *
	 *   // this will capture a state change between any states
	 *   transition("* => *", animate("1s 0s")),
	 *
	 *   // you can also go full out and include a function
	 *   transition((fromState, toState) => {
	 *     // when `true` then it will allow the animation below to be invoked
	 *     return fromState == "off" && toState == "on";
	 *   }, animate("1s 0s"))
	 * ])
	 * ```
	 *
	 * The template associated with this component will make use of the `myAnimationTrigger` animation
	 * trigger by binding to an element within its template code.
	 *
	 * ```html
	 * <!-- somewhere inside of my-component-tpl.html -->
	 * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	 * ```
	 *
	 * #### The final `animate` call
	 *
	 * If the final step within the transition steps is a call to `animate()` that **only** uses a
	 * timing value with **no style data** then it will be automatically used as the final animation arc
	 * for the element to animate itself to the final state. This involves an automatic mix of
	 * adding/removing CSS styles so that the element will be in the exact state it should be for the
	 * applied state to be presented correctly.
	 *
	 * ```
	 * // start off by hiding the element, but make sure that it animates properly to whatever state
	 * // is currently active for "myAnimationTrigger"
	 * transition("void => *", [
	 *   style({ opacity: 0 }),
	 *   animate(500)
	 * ])
	 * ```
	 *
	 * ### Transition Aliases (`:enter` and `:leave`)
	 *
	 * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
	 * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
	 * => void` state changes.
	 *
	 * ```
	 * transition(":enter", [
	 *   style({ opacity: 0 }),
	 *   animate(500, style({ opacity: 1 }))
	 * ])
	 * transition(":leave", [
	 *   animate(500, style({ opacity: 0 }))
	 * ])
	 * ```
	 *
	 * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	 *
	 * \@experimental Animation support is experimental.
	 * @param {?} stateChangeExpr
	 * @param {?} steps
	 * @return {?}
	 */
	function transition$1(stateChangeExpr, steps) {
	    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps };
	}
	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 */
	var AUTO_STYLE$$1 = '*';
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} name
	 * @param {?} definitions
	 * @return {?}
	 */
	function trigger$$1(name, definitions) {
	    return trigger$1(name, definitions);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} timings
	 * @param {?=} styles
	 * @return {?}
	 */
	function animate$$1(timings, styles) {
	    return animate$1(timings, styles);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} steps
	 * @return {?}
	 */
	function group$$1(steps) {
	    return group$1(steps);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} steps
	 * @return {?}
	 */
	function sequence$$1(steps) {
	    return sequence$1(steps);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} tokens
	 * @return {?}
	 */
	function style$$1(tokens) {
	    return style$1(tokens);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} name
	 * @param {?} styles
	 * @return {?}
	 */
	function state$$1(name, styles) {
	    return state$1(name, styles);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} steps
	 * @return {?}
	 */
	function keyframes$$1(steps) {
	    return keyframes$1(steps);
	}
	/**
	 * @deprecated This symbol has moved. Please Import from \@angular/animations instead!
	 * @param {?} stateChangeExpr
	 * @param {?} steps
	 * @return {?}
	 */
	function transition$$1(stateChangeExpr, steps) {
	    return transition$1(stateChangeExpr, steps);
	}
	
	exports.Class = Class;
	exports.createPlatform = createPlatform;
	exports.assertPlatform = assertPlatform;
	exports.destroyPlatform = destroyPlatform;
	exports.getPlatform = getPlatform;
	exports.PlatformRef = PlatformRef;
	exports.ApplicationRef = ApplicationRef;
	exports.enableProdMode = enableProdMode;
	exports.isDevMode = isDevMode;
	exports.createPlatformFactory = createPlatformFactory;
	exports.NgProbeToken = NgProbeToken;
	exports.APP_ID = APP_ID;
	exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
	exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
	exports.PLATFORM_ID = PLATFORM_ID;
	exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
	exports.APP_INITIALIZER = APP_INITIALIZER;
	exports.ApplicationInitStatus = ApplicationInitStatus;
	exports.DebugElement = DebugElement;
	exports.DebugNode = DebugNode;
	exports.asNativeElements = asNativeElements;
	exports.getDebugNode = getDebugNode;
	exports.Testability = Testability;
	exports.TestabilityRegistry = TestabilityRegistry;
	exports.setTestabilityGetter = setTestabilityGetter;
	exports.TRANSLATIONS = TRANSLATIONS;
	exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
	exports.LOCALE_ID = LOCALE_ID;
	exports.MissingTranslationStrategy = MissingTranslationStrategy;
	exports.ApplicationModule = ApplicationModule;
	exports.wtfCreateScope = wtfCreateScope;
	exports.wtfLeave = wtfLeave;
	exports.wtfStartTimeRange = wtfStartTimeRange;
	exports.wtfEndTimeRange = wtfEndTimeRange;
	exports.Type = Type;
	exports.EventEmitter = EventEmitter;
	exports.ErrorHandler = ErrorHandler;
	exports.Sanitizer = Sanitizer;
	exports.SecurityContext = SecurityContext;
	exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
	exports.Attribute = Attribute;
	exports.ContentChild = ContentChild;
	exports.ContentChildren = ContentChildren;
	exports.Query = Query;
	exports.ViewChild = ViewChild;
	exports.ViewChildren = ViewChildren;
	exports.Component = Component;
	exports.Directive = Directive;
	exports.HostBinding = HostBinding;
	exports.HostListener = HostListener;
	exports.Input = Input;
	exports.Output = Output;
	exports.Pipe = Pipe;
	exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
	exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
	exports.NgModule = NgModule;
	exports.ViewEncapsulation = ViewEncapsulation;
	exports.Version = Version;
	exports.VERSION = VERSION;
	exports.forwardRef = forwardRef;
	exports.resolveForwardRef = resolveForwardRef;
	exports.Injector = Injector;
	exports.ReflectiveInjector = ReflectiveInjector;
	exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	exports.ReflectiveKey = ReflectiveKey;
	exports.InjectionToken = InjectionToken;
	exports.OpaqueToken = OpaqueToken;
	exports.Inject = Inject;
	exports.Optional = Optional;
	exports.Injectable = Injectable;
	exports.Self = Self;
	exports.SkipSelf = SkipSelf;
	exports.Host = Host;
	exports.NgZone = NgZone;
	exports.RenderComponentType = RenderComponentType;
	exports.Renderer = Renderer;
	exports.Renderer2 = Renderer2;
	exports.RendererFactory2 = RendererFactory2;
	exports.RendererStyleFlags2 = RendererStyleFlags2;
	exports.RootRenderer = RootRenderer;
	exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
	exports.Compiler = Compiler;
	exports.CompilerFactory = CompilerFactory;
	exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
	exports.ComponentFactory = ComponentFactory;
	exports.ComponentRef = ComponentRef;
	exports.ComponentFactoryResolver = ComponentFactoryResolver;
	exports.ElementRef = ElementRef;
	exports.NgModuleFactory = NgModuleFactory;
	exports.NgModuleRef = NgModuleRef;
	exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
	exports.getModuleFactory = getModuleFactory;
	exports.QueryList = QueryList;
	exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
	exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
	exports.TemplateRef = TemplateRef;
	exports.ViewContainerRef = ViewContainerRef;
	exports.EmbeddedViewRef = EmbeddedViewRef;
	exports.ViewRef = ViewRef;
	exports.ChangeDetectionStrategy = ChangeDetectionStrategy;
	exports.ChangeDetectorRef = ChangeDetectorRef;
	exports.DefaultIterableDiffer = DefaultIterableDiffer;
	exports.IterableDiffers = IterableDiffers;
	exports.KeyValueDiffers = KeyValueDiffers;
	exports.SimpleChange = SimpleChange;
	exports.WrappedValue = WrappedValue;
	exports.platformCore = platformCore;
	exports.ALLOW_MULTIPLE_PLATFORMS = ALLOW_MULTIPLE_PLATFORMS;
	exports.APP_ID_RANDOM_PROVIDER = APP_ID_RANDOM_PROVIDER;
	exports.ValueUnwrapper = ValueUnwrapper;
	exports.devModeEqual = devModeEqual;
	exports.isListLikeIterable = isListLikeIterable;
	exports.ChangeDetectorStatus = ChangeDetectorStatus;
	exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
	exports.Console = Console;
	exports.ERROR_COMPONENT_TYPE = ERROR_COMPONENT_TYPE;
	exports.ComponentFactory = ComponentFactory;
	exports.CodegenComponentFactoryResolver = CodegenComponentFactoryResolver;
	exports.LIFECYCLE_HOOKS_VALUES = LIFECYCLE_HOOKS_VALUES;
	exports.LifecycleHooks = LifecycleHooks;
	exports.ViewMetadata = ViewMetadata;
	exports.Reflector = Reflector;
	exports.reflector = reflector;
	exports.ReflectionCapabilities = ReflectionCapabilities;
	exports.ReflectorReader = ReflectorReader;
	exports.RenderDebugInfo = RenderDebugInfo;
	exports.global = _global;
	exports.looseIdentical = looseIdentical;
	exports.stringify = stringify;
	exports.makeDecorator = makeDecorator;
	exports.isObservable = isObservable;
	exports.isPromise = isPromise;
	exports.NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR;
	exports.NgModuleInjector = NgModuleInjector;
	exports.registerModuleFactory = registerModuleFactory;
	exports.EMPTY_ARRAY = EMPTY_ARRAY;
	exports.EMPTY_MAP = EMPTY_MAP;
	exports.and = anchorDef;
	exports.ccf = createComponentFactory;
	exports.crt = createRendererType2;
	exports.did = directiveDef;
	exports.eld = elementDef;
	exports.elementEventFullName = elementEventFullName;
	exports.getComponentViewDefinitionFactory = getComponentViewDefinitionFactory;
	exports.inlineInterpolate = inlineInterpolate;
	exports.interpolate = interpolate;
	exports.ncd = ngContentDef;
	exports.nov = nodeValue;
	exports.pid = pipeDef;
	exports.prd = providerDef;
	exports.pad = pureArrayDef;
	exports.pod = pureObjectDef;
	exports.ppd = purePipeDef;
	exports.qud = queryDef;
	exports.ted = textDef;
	exports.unv = unwrapValue;
	exports.vid = viewDef;
	exports.AUTO_STYLE = AUTO_STYLE$$1;
	exports.trigger = trigger$$1;
	exports.animate = animate$$1;
	exports.group = group$$1;
	exports.sequence = sequence$$1;
	exports.style = style$$1;
	exports.state = state$$1;
	exports.keyframes = keyframes$$1;
	exports.transition = transition$$1;
	exports.ba = animate$1;
	exports.bb = group$1;
	exports.bf = keyframes$1;
	exports.bc = sequence$1;
	exports.be = state$1;
	exports.bd = style$1;
	exports.bg = transition$1;
	exports.z = trigger$1;
	exports.o = _initViewEngine;
	exports.l = _iterableDiffersFactory;
	exports.m = _keyValueDiffersFactory;
	exports.n = _localeFactory;
	exports.f = ApplicationRef_;
	exports.g = _appIdRandomProviderFactory;
	exports.h = defaultIterableDiffers;
	exports.i = defaultKeyValueDiffers;
	exports.j = DefaultIterableDifferFactory;
	exports.k = DefaultKeyValueDifferFactory;
	exports.c = ReflectiveInjector_;
	exports.d = ReflectiveDependency;
	exports.e = resolveReflectiveProviders;
	exports.p = wtfEnabled;
	exports.r = createScope$1;
	exports.q = detectWTF;
	exports.u = endTimeRange;
	exports.s = leave;
	exports.t = startTimeRange;
	exports.a = makeParamDecorator;
	exports.b = makePropDecorator;
	exports.w = _def;
	exports.x = DebugContext;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
	//# sourceMappingURL=core.umd.js.map
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(146);
	var toSubscriber_1 = __webpack_require__(147);
	var observable_1 = __webpack_require__(158);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 146 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * window: browser in DOM main thread
	 * self: browser in WebWorker
	 * global: Node.js/other
	 */
	exports.root = (typeof window == 'object' && window.window === window && window
	    || typeof self == 'object' && self.self === self && self
	    || typeof global == 'object' && global.global === global && global);
	if (!exports.root) {
	    throw new Error('RxJS could not find any global context (window, self, global)');
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(148);
	var rxSubscriber_1 = __webpack_require__(157);
	var Observer_1 = __webpack_require__(156);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(149);
	var Subscription_1 = __webpack_require__(150);
	var Observer_1 = __webpack_require__(156);
	var rxSubscriber_1 = __webpack_require__(157);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 149 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(151);
	var isObject_1 = __webpack_require__(152);
	var isFunction_1 = __webpack_require__(149);
	var tryCatch_1 = __webpack_require__(153);
	var errorObject_1 = __webpack_require__(154);
	var UnsubscriptionError_1 = __webpack_require__(155);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 151 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 152 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(154);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 154 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 155 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 156 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(146);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(146);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;
	//# sourceMappingURL=observable.js.map

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var merge_1 = __webpack_require__(160);
	exports.merge = merge_1.mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(145);
	var ArrayObservable_1 = __webpack_require__(161);
	var mergeAll_1 = __webpack_require__(165);
	var isScheduler_1 = __webpack_require__(164);
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {ObservableInput} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} An Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
	}
	exports.merge = merge;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // timer will emit ascending values, one every second(1000ms) to console
	 * // clicks logs MouseEvents to console everytime the "document" is clicked
	 * // Since the two streams are merged you see these happening
	 * // as they occur.
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - First timer1 and timer2 will run concurrently
	 * // - timer1 will emit a value every 1000ms for 10 iterations
	 * // - timer2 will emit a value every 2000ms for 6 iterations
	 * // - after timer1 hits it's max iteration, timer2 will
	 * //   continue, and timer3 will start to run concurrently with timer2
	 * // - when timer2 hits it's max iteration it terminates, and
	 * //   timer3 will continue to emit a value every 500ms until it is complete
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {...ObservableInput} observables Input Observables to merge together.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
	}
	exports.mergeStatic = mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(145);
	var ScalarObservable_1 = __webpack_require__(162);
	var EmptyObservable_1 = __webpack_require__(163);
	var isScheduler_1 = __webpack_require__(164);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` IScheduler, which means the `next`
	     * notifications are sent synchronously, although with a different IScheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.closed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1.Observable));
	exports.ArrayObservable = ArrayObservable;
	//# sourceMappingURL=ArrayObservable.js.map

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(145);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	        if (scheduler) {
	            this._isScalar = false;
	        }
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.closed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1.Observable));
	exports.ScalarObservable = ScalarObservable;
	//# sourceMappingURL=ScalarObservable.js.map

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(145);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following to the console:
	     * // x is equal to the count on the interval eg(0,1,2,3,...)
	     * // x will occur every 1000ms
	     * // if x % 2 is equal to 1 print abc
	     * // if x % 2 is not equal to 1 nothing will be output
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1.Observable));
	exports.EmptyObservable = EmptyObservable;
	//# sourceMappingURL=EmptyObservable.js.map

/***/ },
/* 164 */
/***/ function(module, exports) {

	"use strict";
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	exports.isScheduler = isScheduler;
	//# sourceMappingURL=isScheduler.js.map

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(166);
	var subscribeToResult_1 = __webpack_require__(167);
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	exports.mergeAll = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	exports.MergeAllOperator = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeAllSubscriber = MergeAllSubscriber;
	//# sourceMappingURL=mergeAll.js.map

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(148);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;
	//# sourceMappingURL=OuterSubscriber.js.map

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(146);
	var isArrayLike_1 = __webpack_require__(168);
	var isPromise_1 = __webpack_require__(169);
	var isObject_1 = __webpack_require__(152);
	var Observable_1 = __webpack_require__(145);
	var iterator_1 = __webpack_require__(170);
	var InnerSubscriber_1 = __webpack_require__(171);
	var observable_1 = __webpack_require__(158);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.closed) {
	        return null;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return null;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    else if (isArrayLike_1.isArrayLike(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.closed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.closed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (result && typeof result[iterator_1.iterator] === 'function') {
	        var iterator = result[iterator_1.iterator]();
	        do {
	            var item = iterator.next();
	            if (item.done) {
	                destination.complete();
	                break;
	            }
	            destination.next(item.value);
	            if (destination.closed) {
	                break;
	            }
	        } while (true);
	    }
	    else if (result && typeof result[observable_1.observable] === 'function') {
	        var obs = result[observable_1.observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = ("You provided " + value + " where a stream was expected.")
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        destination.error(new TypeError(msg));
	    }
	    return null;
	}
	exports.subscribeToResult = subscribeToResult;
	//# sourceMappingURL=subscribeToResult.js.map

/***/ },
/* 168 */
/***/ function(module, exports) {

	"use strict";
	exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArrayLike.js.map

/***/ },
/* 169 */
/***/ function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;
	//# sourceMappingURL=isPromise.js.map

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(146);
	function symbolIteratorPonyfill(root) {
	    var Symbol = root.Symbol;
	    if (typeof Symbol === 'function') {
	        if (!Symbol.iterator) {
	            Symbol.iterator = Symbol('iterator polyfill');
	        }
	        return Symbol.iterator;
	    }
	    else {
	        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
	        var Set_1 = root.Set;
	        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
	            return '@@iterator';
	        }
	        var Map_1 = root.Map;
	        // required for compatability with es6-shim
	        if (Map_1) {
	            var keys = Object.getOwnPropertyNames(Map_1.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
	                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
	                    return key;
	                }
	            }
	        }
	        return '@@iterator';
	    }
	}
	exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
	exports.iterator = symbolIteratorPonyfill(root_1.root);
	/**
	 * @deprecated use iterator instead
	 */
	exports.$$iterator = exports.iterator;
	//# sourceMappingURL=iterator.js.map

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(148);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;
	//# sourceMappingURL=InnerSubscriber.js.map

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var multicast_1 = __webpack_require__(173);
	var Subject_1 = __webpack_require__(175);
	function shareSubjectFactory() {
	    return new Subject_1.Subject();
	}
	/**
	 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
	 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
	 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
	 * This is an alias for .publish().refCount().
	 *
	 * <img src="./img/share.png" width="100%">
	 *
	 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
	 * @method share
	 * @owner Observable
	 */
	function share() {
	    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
	}
	exports.share = share;
	;
	//# sourceMappingURL=share.js.map

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ConnectableObservable_1 = __webpack_require__(174);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits the results of invoking a specified selector on items
	 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
	 *
	 * <img src="./img/multicast.png" width="100%">
	 *
	 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
	 * which the source sequence's elements will be multicast to the selector function
	 * or Subject to push source elements into.
	 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
	 * as many times as needed, without causing multiple subscriptions to the source stream.
	 * Subscribers to the given source will receive all notifications of the source from the
	 * time of the subscription forward.
	 * @return {Observable} An Observable that emits the results of invoking the selector
	 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
	 * the underlying stream.
	 * @method multicast
	 * @owner Observable
	 */
	function multicast(subjectOrSubjectFactory, selector) {
	    var subjectFactory;
	    if (typeof subjectOrSubjectFactory === 'function') {
	        subjectFactory = subjectOrSubjectFactory;
	    }
	    else {
	        subjectFactory = function subjectFactory() {
	            return subjectOrSubjectFactory;
	        };
	    }
	    if (typeof selector === 'function') {
	        return this.lift(new MulticastOperator(subjectFactory, selector));
	    }
	    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
	    connectable.source = this;
	    connectable.subjectFactory = subjectFactory;
	    return connectable;
	}
	exports.multicast = multicast;
	var MulticastOperator = (function () {
	    function MulticastOperator(subjectFactory, selector) {
	        this.subjectFactory = subjectFactory;
	        this.selector = selector;
	    }
	    MulticastOperator.prototype.call = function (subscriber, source) {
	        var selector = this.selector;
	        var subject = this.subjectFactory();
	        var subscription = selector(subject).subscribe(subscriber);
	        subscription.add(source.subscribe(subject));
	        return subscription;
	    };
	    return MulticastOperator;
	}());
	exports.MulticastOperator = MulticastOperator;
	//# sourceMappingURL=multicast.js.map

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(175);
	var Observable_1 = __webpack_require__(145);
	var Subscriber_1 = __webpack_require__(148);
	var Subscription_1 = __webpack_require__(150);
	/**
	 * @class ConnectableObservable<T>
	 */
	var ConnectableObservable = (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        _super.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	        this._refCount = 0;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var connection = this._connection;
	        if (!connection) {
	            connection = this._connection = new Subscription_1.Subscription();
	            connection.add(this.source
	                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1.Subscription.EMPTY;
	            }
	            else {
	                this._connection = connection;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return this.lift(new RefCountOperator(this));
	    };
	    return ConnectableObservable;
	}(Observable_1.Observable));
	exports.ConnectableObservable = ConnectableObservable;
	exports.connectableObservableDescriptor = {
	    operator: { value: null },
	    _refCount: { value: 0, writable: true },
	    _subject: { value: null, writable: true },
	    _connection: { value: null, writable: true },
	    _subscribe: { value: ConnectableObservable.prototype._subscribe },
	    getSubject: { value: ConnectableObservable.prototype.getSubject },
	    connect: { value: ConnectableObservable.prototype.connect },
	    refCount: { value: ConnectableObservable.prototype.refCount }
	};
	var ConnectableSubscriber = (function (_super) {
	    __extends(ConnectableSubscriber, _super);
	    function ConnectableSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    ConnectableSubscriber.prototype._error = function (err) {
	        this._unsubscribe();
	        _super.prototype._error.call(this, err);
	    };
	    ConnectableSubscriber.prototype._complete = function () {
	        this._unsubscribe();
	        _super.prototype._complete.call(this);
	    };
	    ConnectableSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (connectable) {
	            this.connectable = null;
	            var connection = connectable._connection;
	            connectable._refCount = 0;
	            connectable._subject = null;
	            connectable._connection = null;
	            if (connection) {
	                connection.unsubscribe();
	            }
	        }
	    };
	    return ConnectableSubscriber;
	}(Subject_1.SubjectSubscriber));
	var RefCountOperator = (function () {
	    function RefCountOperator(connectable) {
	        this.connectable = connectable;
	    }
	    RefCountOperator.prototype.call = function (subscriber, source) {
	        var connectable = this.connectable;
	        connectable._refCount++;
	        var refCounter = new RefCountSubscriber(subscriber, connectable);
	        var subscription = source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            refCounter.connection = connectable.connect();
	        }
	        return subscription;
	    };
	    return RefCountOperator;
	}());
	var RefCountSubscriber = (function (_super) {
	    __extends(RefCountSubscriber, _super);
	    function RefCountSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    RefCountSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (!connectable) {
	            this.connection = null;
	            return;
	        }
	        this.connectable = null;
	        var refCount = connectable._refCount;
	        if (refCount <= 0) {
	            this.connection = null;
	            return;
	        }
	        connectable._refCount = refCount - 1;
	        if (refCount > 1) {
	            this.connection = null;
	            return;
	        }
	        ///
	        // Compare the local RefCountSubscriber's connection Subscription to the
	        // connection Subscription on the shared ConnectableObservable. In cases
	        // where the ConnectableObservable source synchronously emits values, and
	        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
	        // execution continues to here before the RefCountOperator has a chance to
	        // supply the RefCountSubscriber with the shared connection Subscription.
	        // For example:
	        // ```
	        // Observable.range(0, 10)
	        //   .publish()
	        //   .refCount()
	        //   .take(5)
	        //   .subscribe();
	        // ```
	        // In order to account for this case, RefCountSubscriber should only dispose
	        // the ConnectableObservable's shared connection Subscription if the
	        // connection Subscription exists, *and* either:
	        //   a. RefCountSubscriber doesn't have a reference to the shared connection
	        //      Subscription yet, or,
	        //   b. RefCountSubscriber's connection Subscription reference is identical
	        //      to the shared connection Subscription
	        ///
	        var connection = this.connection;
	        var sharedConnection = connectable._connection;
	        this.connection = null;
	        if (sharedConnection && (!connection || sharedConnection === connection)) {
	            sharedConnection.unsubscribe();
	        }
	    };
	    return RefCountSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=ConnectableObservable.js.map

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(145);
	var Subscriber_1 = __webpack_require__(148);
	var Subscription_1 = __webpack_require__(150);
	var ObjectUnsubscribedError_1 = __webpack_require__(176);
	var SubjectSubscription_1 = __webpack_require__(177);
	var rxSubscriber_1 = __webpack_require__(157);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._trySubscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return _super.prototype._trySubscribe.call(this, subscriber);
	        }
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 176 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(150);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map