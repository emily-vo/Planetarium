(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('core-js/es7/reflect'), require('@angular/core')) :
	typeof define === 'function' && define.amd ? define(['exports', 'core-js/es7/reflect', '@angular/core'], factory) :
	(factory((global.standardizedAudioContext = global.standardizedAudioContext || {}),null,global._angular_core));
}(this, (function (exports,coreJs_es7_reflect,_angular_core) { 'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DataCloneErrorFactory = function () {
    function DataCloneErrorFactory() {
        _classCallCheck(this, DataCloneErrorFactory);
    }

    _createClass(DataCloneErrorFactory, [{
        key: 'create',
        value: function create() {
            try {
                return new DOMException('', 'DataCloneError');
            } catch (err) {
                var exception = new Error();
                exception.code = 25;
                exception.name = 'DataCloneError';
                return exception;
            }
        }
    }]);

    return DataCloneErrorFactory;
}();

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EncodingErrorFactory = function () {
    function EncodingErrorFactory() {
        _classCallCheck$1(this, EncodingErrorFactory);
    }

    _createClass$1(EncodingErrorFactory, [{
        key: 'create',
        value: function create() {
            try {
                return new DOMException('', 'EncodingError');
            } catch (err) {
                var exception = new Error();
                exception.code = 0;
                exception.name = 'EncodingError';
                return exception;
            }
        }
    }]);

    return EncodingErrorFactory;
}();

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IndexSizeErrorFactory = function () {
    function IndexSizeErrorFactory() {
        _classCallCheck$2(this, IndexSizeErrorFactory);
    }

    _createClass$2(IndexSizeErrorFactory, [{
        key: 'create',
        value: function create() {
            try {
                return new DOMException('', 'IndexSizeError');
            } catch (err) {
                var exception = new Error();
                exception.code = 1;
                exception.name = 'IndexSizeError';
                return exception;
            }
        }
    }]);

    return IndexSizeErrorFactory;
}();

var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InvalidAccessErrorFactory = function () {
    function InvalidAccessErrorFactory() {
        _classCallCheck$3(this, InvalidAccessErrorFactory);
    }

    _createClass$3(InvalidAccessErrorFactory, [{
        key: 'create',
        value: function create() {
            try {
                return new DOMException('', 'InvalidAccessError');
            } catch (err) {
                var exception = new Error();
                exception.code = 15;
                exception.name = 'InvalidAccessError';
                return exception;
            }
        }
    }]);

    return InvalidAccessErrorFactory;
}();

var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InvalidStateErrorFactory = function () {
    function InvalidStateErrorFactory() {
        _classCallCheck$4(this, InvalidStateErrorFactory);
    }

    _createClass$4(InvalidStateErrorFactory, [{
        key: 'create',
        value: function create() {
            try {
                return new DOMException('', 'InvalidStateError');
            } catch (err) {
                var exception = new Error();
                exception.code = 11;
                exception.name = 'InvalidStateError';
                return exception;
            }
        }
    }]);

    return InvalidStateErrorFactory;
}();

var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NotSupportedErrorFactory = function () {
    function NotSupportedErrorFactory() {
        _classCallCheck$5(this, NotSupportedErrorFactory);
    }

    _createClass$5(NotSupportedErrorFactory, [{
        key: 'create',
        value: function create() {
            try {
                return new DOMException('', 'NotSupportedError');
            } catch (err) {
                var exception = new Error();
                exception.code = 9;
                exception.name = 'NotSupportedError';
                return exception;
            }
        }
    }]);

    return NotSupportedErrorFactory;
}();

var _createClass$7 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OfflineAudioNodeProxy = function () {
    function OfflineAudioNodeProxy(_ref) {
        var channelCountMode = _ref.channelCountMode,
            channelInterpretation = _ref.channelInterpretation,
            fakeNodeStore = _ref.fakeNodeStore,
            numberOfInputs = _ref.numberOfInputs,
            numberOfOutputs = _ref.numberOfOutputs;

        _classCallCheck$7(this, OfflineAudioNodeProxy);

        this._channelCountMode = channelCountMode;
        this._channelInterpretation = channelInterpretation;
        this._fakeNodeStore = fakeNodeStore;
        this._numberOfInputs = numberOfInputs;
        this._numberOfOutputs = numberOfOutputs;
    }

    _createClass$7(OfflineAudioNodeProxy, [{
        key: 'connect',
        value: function connect(destination) {
            var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

            var faker = this._fakeNodeStore.get(destination);
            if (faker === undefined) {
                var exception = void 0;
                try {
                    exception = new DOMException('', 'InvalidAccessError');
                } catch (err) {
                    exception = new Error();
                    exception.code = 15;
                    exception.name = 'InvalidAccessError';
                }
                throw exception;
            }
            return faker.wire(this._fakeNodeStore.get(this), output, input);
        }
    }, {
        key: 'disconnect',
        value: function disconnect(destination) {
            var faker = this._fakeNodeStore.get(destination);
            return faker.unwire(this._fakeNodeStore.get(this));
        }
    }, {
        key: 'channelCountMode',
        get: function get() {
            return this._channelCountMode;
        },
        set: function set(value) {
            this._channelCountMode = value;
        }
    }, {
        key: 'channelInterpretation',
        get: function get() {
            return this._channelInterpretation;
        },
        set: function set(value) {
            this._channelInterpretation = value;
        }
    }, {
        key: 'numberOfInputs',
        get: function get() {
            return this._numberOfInputs;
        },
        set: function set(value) {
            this._numberOfInputs = value;
        }
    }, {
        key: 'numberOfOutputs',
        get: function get() {
            return this._numberOfOutputs;
        },
        set: function set(value) {
            this._numberOfOutputs = value;
        }
    }]);

    return OfflineAudioNodeProxy;
}();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OfflineAudioBufferSourceNodeFakerProxy = function (_OfflineAudioNodeProx) {
    _inherits(OfflineAudioBufferSourceNodeFakerProxy, _OfflineAudioNodeProx);

    function OfflineAudioBufferSourceNodeFakerProxy(_ref) {
        var fakeNodeStore = _ref.fakeNodeStore;

        _classCallCheck$6(this, OfflineAudioBufferSourceNodeFakerProxy);

        var _this = _possibleConstructorReturn(this, (OfflineAudioBufferSourceNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineAudioBufferSourceNodeFakerProxy)).call(this, { fakeNodeStore: fakeNodeStore }));

        _this._buffer = undefined;
        _this._ownFakeNodeStore = fakeNodeStore;
        return _this;
    }

    _createClass$6(OfflineAudioBufferSourceNodeFakerProxy, [{
        key: 'start',
        value: function start() {
            var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var duration = arguments[2];

            var faker = this._ownFakeNodeStore.get(this);
            faker.start = { duration: duration, offset: offset, when: when };
        }
    }, {
        key: 'buffer',
        get: function get() {
            return this._buffer;
        },
        set: function set(value) {
            // @todo Allow to set the buffer only onces.
            this._buffer = value;
        }
    }]);

    return OfflineAudioBufferSourceNodeFakerProxy;
}(OfflineAudioNodeProxy);

var OfflineAudioBufferSourceNodeFaker = function () {
    function OfflineAudioBufferSourceNodeFaker(_ref2) {
        var fakeNodeStore = _ref2.fakeNodeStore;

        _classCallCheck$6(this, OfflineAudioBufferSourceNodeFaker);

        this._node = null;
        this._proxy = new OfflineAudioBufferSourceNodeFakerProxy({ fakeNodeStore: fakeNodeStore });
        this._sources = new Map();
        this._start = null;
        fakeNodeStore.set(this._proxy, this);
    }

    _createClass$6(OfflineAudioBufferSourceNodeFaker, [{
        key: 'render',
        value: function render(offlineAudioContext) {
            var _this2 = this;

            if (this._node !== null) {
                return Promise.resolve(this._node);
            }
            var promises = [];
            this._node = offlineAudioContext.createBufferSource();
            this._node.buffer = this._proxy.buffer;
            if (this._start !== null) {
                var _start = this._start,
                    duration = _start.duration,
                    offset = _start.offset,
                    when = _start.when;

                if (duration === undefined) {
                    this._node.start(when, offset);
                } else {
                    this._node.start(when, offset, duration);
                }
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                var _loop = function _loop() {
                    var _step$value = _slicedToArray(_step.value, 2),
                        source = _step$value[0],
                        _step$value$ = _step$value[1],
                        input = _step$value$.input,
                        output = _step$value$.output;

                    promises.push(source.render(offlineAudioContext).then(function (node) {
                        return node.connect(_this2._node, output, input);
                    }));
                };

                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return Promise.all(promises).then(function () {
                return _this2._node;
            });
        }
    }, {
        key: 'wire',
        value: function wire(source, output, input) {
            this._sources.set(source, { input: input, output: output });
            return this._proxy;
        }
    }, {
        key: 'proxy',
        get: function get() {
            return this._proxy;
        }
    }, {
        key: 'start',
        set: function set(value) {
            this._start = value;
        }
    }]);

    return OfflineAudioBufferSourceNodeFaker;
}();
var OfflineAudioBufferSourceNodeFakerFactory = function () {
    function OfflineAudioBufferSourceNodeFakerFactory() {
        _classCallCheck$6(this, OfflineAudioBufferSourceNodeFakerFactory);
    }

    _createClass$6(OfflineAudioBufferSourceNodeFakerFactory, [{
        key: 'create',
        value: function create(_ref3) {
            var fakeNodeStore = _ref3.fakeNodeStore;

            return new OfflineAudioBufferSourceNodeFaker({ fakeNodeStore: fakeNodeStore });
        }
    }]);

    return OfflineAudioBufferSourceNodeFakerFactory;
}();

var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$8 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OfflineAudioDestinationNodeFakerProxy = function (_OfflineAudioNodeProx) {
    _inherits$1(OfflineAudioDestinationNodeFakerProxy, _OfflineAudioNodeProx);

    function OfflineAudioDestinationNodeFakerProxy(_ref) {
        var fakeNodeStore = _ref.fakeNodeStore;

        _classCallCheck$8(this, OfflineAudioDestinationNodeFakerProxy);

        return _possibleConstructorReturn$1(this, (OfflineAudioDestinationNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineAudioDestinationNodeFakerProxy)).call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 0
        }));
    }

    _createClass$8(OfflineAudioDestinationNodeFakerProxy, [{
        key: 'maxChannelCount',
        get: function get() {
            // @todo
            return 2;
        }
    }]);

    return OfflineAudioDestinationNodeFakerProxy;
}(OfflineAudioNodeProxy);

var OfflineAudioDestinationNodeFaker = function () {
    function OfflineAudioDestinationNodeFaker(_ref2) {
        var fakeNodeStore = _ref2.fakeNodeStore;

        _classCallCheck$8(this, OfflineAudioDestinationNodeFaker);

        this._node = null;
        this._proxy = new OfflineAudioDestinationNodeFakerProxy({ fakeNodeStore: fakeNodeStore });
        this._sources = new Map();
        fakeNodeStore.set(this._proxy, this);
    }

    _createClass$8(OfflineAudioDestinationNodeFaker, [{
        key: 'render',
        value: function render(offlineAudioContext) {
            var _this2 = this;

            if (this._node !== null) {
                return Promise.resolve(this._node);
            }
            var promises = [];
            this._node = offlineAudioContext.destination;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                var _loop = function _loop() {
                    var _step$value = _slicedToArray$1(_step.value, 2),
                        source = _step$value[0],
                        _step$value$ = _step$value[1],
                        input = _step$value$.input,
                        output = _step$value$.output;

                    promises.push(source.render(offlineAudioContext).then(function (node) {
                        return node.connect(_this2._node, output, input);
                    }));
                };

                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return Promise.all(promises).then(function () {
                return _this2._node;
            });
        }
    }, {
        key: 'wire',
        value: function wire(source, output, input) {
            this._sources.set(source, { input: input, output: output });
            return this._proxy;
        }
    }, {
        key: 'proxy',
        get: function get() {
            return this._proxy;
        }
    }]);

    return OfflineAudioDestinationNodeFaker;
}();
var OfflineAudioDestinationNodeFakerFactory = function () {
    function OfflineAudioDestinationNodeFakerFactory() {
        _classCallCheck$8(this, OfflineAudioDestinationNodeFakerFactory);
    }

    _createClass$8(OfflineAudioDestinationNodeFakerFactory, [{
        key: 'create',
        value: function create(_ref3) {
            var fakeNodeStore = _ref3.fakeNodeStore;

            return new OfflineAudioDestinationNodeFaker({ fakeNodeStore: fakeNodeStore });
        }
    }]);

    return OfflineAudioDestinationNodeFakerFactory;
}();

var _slicedToArray$2 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$9 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OfflineBiquadFilterNodeFakerProxy = function (_OfflineAudioNodeProx) {
    _inherits$2(OfflineBiquadFilterNodeFakerProxy, _OfflineAudioNodeProx);

    function OfflineBiquadFilterNodeFakerProxy(_ref) {
        var fakeNodeStore = _ref.fakeNodeStore,
            nativeNode = _ref.nativeNode;

        _classCallCheck$9(this, OfflineBiquadFilterNodeFakerProxy);

        var _this = _possibleConstructorReturn$2(this, (OfflineBiquadFilterNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineBiquadFilterNodeFakerProxy)).call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 1
        }));

        _this._nativeNode = nativeNode;
        _this._type = nativeNode.type;
        return _this;
    }

    _createClass$9(OfflineBiquadFilterNodeFakerProxy, [{
        key: 'getFrequencyResponse',
        value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
            return this._nativeNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
        }
    }, {
        key: 'detune',
        get: function get() {
            // @todo Fake a proper AudioParam.
            return {
                cancelScheduledValues: function cancelScheduledValues() {},
                defaultValue: 0,
                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
                linearRampToValueAtTime: function linearRampToValueAtTime() {},
                setTargetAtTime: function setTargetAtTime() {},
                setValueCurveAtTime: function setValueCurveAtTime() {},
                value: 0
            };
        }
    }, {
        key: 'frequency',
        get: function get() {
            // @todo Fake a proper AudioParam.
            return {
                cancelScheduledValues: function cancelScheduledValues() {},
                defaultValue: 350,
                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
                linearRampToValueAtTime: function linearRampToValueAtTime() {},
                setTargetAtTime: function setTargetAtTime() {},
                setValueCurveAtTime: function setValueCurveAtTime() {},
                value: 350
            };
        }
    }, {
        key: 'gain',
        get: function get() {
            // @todo Fake a proper AudioParam.
            return {
                cancelScheduledValues: function cancelScheduledValues() {},
                defaultValue: 0,
                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
                linearRampToValueAtTime: function linearRampToValueAtTime() {},
                setTargetAtTime: function setTargetAtTime() {},
                setValueCurveAtTime: function setValueCurveAtTime() {},
                value: 0
            };
        }
    }, {
        key: 'Q',
        get: function get() {
            // @todo Fake a proper AudioParam.
            return {
                cancelScheduledValues: function cancelScheduledValues() {},
                defaultValue: 1,
                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
                linearRampToValueAtTime: function linearRampToValueAtTime() {},
                setTargetAtTime: function setTargetAtTime() {},
                setValueCurveAtTime: function setValueCurveAtTime() {},
                value: 1
            };
        }
    }, {
        key: 'type',
        get: function get() {
            return this._type;
        },
        set: function set(value) {
            this._type = value;
        }
    }]);

    return OfflineBiquadFilterNodeFakerProxy;
}(OfflineAudioNodeProxy);

var OfflineBiquadFilterNodeFaker = function () {
    function OfflineBiquadFilterNodeFaker(_ref2) {
        var fakeNodeStore = _ref2.fakeNodeStore,
            nativeNode = _ref2.nativeNode;

        _classCallCheck$9(this, OfflineBiquadFilterNodeFaker);

        this._node = null;
        this._proxy = new OfflineBiquadFilterNodeFakerProxy({ fakeNodeStore: fakeNodeStore, nativeNode: nativeNode });
        this._sources = new Map();
        fakeNodeStore.set(this._proxy, this);
    }

    _createClass$9(OfflineBiquadFilterNodeFaker, [{
        key: 'render',
        value: function render(offlineAudioContext) {
            var _this2 = this;

            if (this._node !== null) {
                return Promise.resolve(this._node);
            }
            var promises = [];
            this._node = offlineAudioContext.createBiquadFilter();
            this._node.type = this._proxy.type;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                var _loop = function _loop() {
                    var _step$value = _slicedToArray$2(_step.value, 2),
                        source = _step$value[0],
                        _step$value$ = _step$value[1],
                        input = _step$value$.input,
                        output = _step$value$.output;

                    promises.push(source.render(offlineAudioContext).then(function (node) {
                        return node.connect(_this2._node, output, input);
                    }));
                };

                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return Promise.all(promises).then(function () {
                return _this2._node;
            });
        }
    }, {
        key: 'wire',
        value: function wire(source, output, input) {
            this._sources.set(source, { input: input, output: output });
            return this._proxy;
        }
    }, {
        key: 'unwire',
        value: function unwire(source) {
            this._sources.delete(source);
        }
    }, {
        key: 'proxy',
        get: function get() {
            return this._proxy;
        }
    }]);

    return OfflineBiquadFilterNodeFaker;
}();
var OfflineBiquadFilterNodeFakerFactory = function () {
    function OfflineBiquadFilterNodeFakerFactory() {
        _classCallCheck$9(this, OfflineBiquadFilterNodeFakerFactory);
    }

    _createClass$9(OfflineBiquadFilterNodeFakerFactory, [{
        key: 'create',
        value: function create(_ref3) {
            var fakeNodeStore = _ref3.fakeNodeStore,
                nativeNode = _ref3.nativeNode;

            return new OfflineBiquadFilterNodeFaker({
                fakeNodeStore: fakeNodeStore,
                nativeNode: nativeNode
            });
        }
    }]);

    return OfflineBiquadFilterNodeFakerFactory;
}();

var _slicedToArray$3 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$10 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$10(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OfflineGainNodeFakerProxy = function (_OfflineAudioNodeProx) {
    _inherits$3(OfflineGainNodeFakerProxy, _OfflineAudioNodeProx);

    function OfflineGainNodeFakerProxy(_ref) {
        var fakeNodeStore = _ref.fakeNodeStore;

        _classCallCheck$10(this, OfflineGainNodeFakerProxy);

        return _possibleConstructorReturn$3(this, (OfflineGainNodeFakerProxy.__proto__ || Object.getPrototypeOf(OfflineGainNodeFakerProxy)).call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 1
        }));
    }

    _createClass$10(OfflineGainNodeFakerProxy, [{
        key: 'gain',
        get: function get() {
            // @todo Fake a proper AudioParam.
            return {
                cancelScheduledValues: function cancelScheduledValues() {},
                defaultValue: 1,
                exponentialRampToValueAtTime: function exponentialRampToValueAtTime() {},
                linearRampToValueAtTime: function linearRampToValueAtTime() {},
                setTargetAtTime: function setTargetAtTime() {},
                setValueCurveAtTime: function setValueCurveAtTime() {},
                value: 1
            };
        }
    }]);

    return OfflineGainNodeFakerProxy;
}(OfflineAudioNodeProxy);

var OfflineGainNodeFaker = function () {
    function OfflineGainNodeFaker(_ref2) {
        var fakeNodeStore = _ref2.fakeNodeStore;

        _classCallCheck$10(this, OfflineGainNodeFaker);

        this._node = null;
        this._proxy = new OfflineGainNodeFakerProxy({ fakeNodeStore: fakeNodeStore });
        this._sources = new Map();
        fakeNodeStore.set(this._proxy, this);
    }

    _createClass$10(OfflineGainNodeFaker, [{
        key: 'render',
        value: function render(offlineAudioContext) {
            var _this2 = this;

            if (this._node !== null) {
                return Promise.resolve(this._node);
            }
            var promises = [];
            this._node = offlineAudioContext.createGain();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                var _loop = function _loop() {
                    var _step$value = _slicedToArray$3(_step.value, 2),
                        source = _step$value[0],
                        _step$value$ = _step$value[1],
                        input = _step$value$.input,
                        output = _step$value$.output;

                    promises.push(source.render(offlineAudioContext).then(function (node) {
                        return node.connect(_this2._node, output, input);
                    }));
                };

                for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    _loop();
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return Promise.all(promises).then(function () {
                return _this2._node;
            });
        }
    }, {
        key: 'wire',
        value: function wire(source, output, input) {
            this._sources.set(source, { input: input, output: output });
            return this._proxy;
        }
    }, {
        key: 'unwire',
        value: function unwire(source) {
            this._sources.delete(source);
        }
    }, {
        key: 'proxy',
        get: function get() {
            return this._proxy;
        }
    }]);

    return OfflineGainNodeFaker;
}();
var OfflineGainNodeFakerFactory = function () {
    function OfflineGainNodeFakerFactory() {
        _classCallCheck$10(this, OfflineGainNodeFakerFactory);
    }

    _createClass$10(OfflineGainNodeFakerFactory, [{
        key: 'create',
        value: function create(_ref3) {
            var fakeNodeStore = _ref3.fakeNodeStore;

            return new OfflineGainNodeFaker({ fakeNodeStore: fakeNodeStore });
        }
    }]);

    return OfflineGainNodeFakerFactory;
}();

var Window = new _angular_core.OpaqueToken('WINDOW'); // tslint:disable-line:variable-name
// tslint:disable-line:variable-name
var WINDOW_PROVIDER = { provide: Window, useValue: window };

var unpatchedOfflineAudioContextConstructor = new _angular_core.OpaqueToken('UNPATCHED_OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR');
var UNPATCHED_OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
    deps: [Window],
    provide: unpatchedOfflineAudioContextConstructor,
    useFactory: function useFactory(window) {
        return window.hasOwnProperty('OfflineAudioContext') ? window.OfflineAudioContext : window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;
    }
};

var _createClass$12 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$12(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PromiseSupportTester = function () {
    function PromiseSupportTester() {
        _classCallCheck$12(this, PromiseSupportTester);
    }

    _createClass$12(PromiseSupportTester, [{
        key: "test",
        value: function test(audioContext) {
            // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.
            var uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
            try {
                // Bug #1: Chrome Canary & Safari requires a successCallback.
                var promise = audioContext.decodeAudioData(uint32Array.buffer, function () {
                    // Ignore the success callback.
                });
                if (promise === undefined) {
                    return false;
                }
                promise.catch(function () {
                    // Ignore rejected errors.
                });
                return true;
            } catch (err) {
                // Ignore thrown errors.
            }
            return false;
        }
    }]);

    return PromiseSupportTester;
}();

var _slicedToArray$4 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass$11 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$11(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
function divide(a, b) {
    var denominator = b[0] * b[0] + b[1] * b[1];
    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
}
function multiply(a, b) {
    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
}
function evaluatePolynomial(coefficient, z) {
    var result = [0, 0];
    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
        result = multiply(result, z);
        result[0] += coefficient[i];
    }
    return result;
}

var OfflineIIRFilterNodeProxy = function (_OfflineAudioNodeProx) {
    _inherits$4(OfflineIIRFilterNodeProxy, _OfflineAudioNodeProx);

    function OfflineIIRFilterNodeProxy(_ref) {
        var fakeNodeStore = _ref.fakeNodeStore,
            feedback = _ref.feedback,
            feedforward = _ref.feedforward,
            nativeNode = _ref.nativeNode,
            notSupportedErrorFactory = _ref.notSupportedErrorFactory,
            sampleRate = _ref.sampleRate;

        _classCallCheck$11(this, OfflineIIRFilterNodeProxy);

        var _this = _possibleConstructorReturn$4(this, (OfflineIIRFilterNodeProxy.__proto__ || Object.getPrototypeOf(OfflineIIRFilterNodeProxy)).call(this, {
            channelCountMode: 'max',
            channelInterpretation: 'speakers',
            fakeNodeStore: fakeNodeStore,
            numberOfInputs: 1,
            numberOfOutputs: 1
        }));

        _this._feedback = feedback;
        _this._feedforward = feedforward;
        _this._nativeNode = nativeNode;
        _this._notSupportedErrorFactory = notSupportedErrorFactory;
        _this._nyquist = sampleRate / 2;
        return _this;
    }

    _createClass$11(OfflineIIRFilterNodeProxy, [{
        key: "getFrequencyResponse",
        value: function getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
            // Bug #9: Safari does not support IIRFilterNodes.
            if (this._nativeNode) {
                return this._nativeNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
            }
            if (magResponse.length === 0 || phaseResponse.length === 0) {
                throw this._notSupportedErrorFactory.create();
            }
            var length = frequencyHz.length;
            for (var i = 0; i < length; i += 1) {
                var omega = -Math.PI * (frequencyHz[i] / this._nyquist);
                var z = [Math.cos(omega), Math.sin(omega)];
                var numerator = evaluatePolynomial(this._feedforward, z);
                var denominator = evaluatePolynomial(this._feedback, z);
                var response = divide(numerator, denominator);
                magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
                phaseResponse[i] = Math.atan2(response[1], response[0]);
            }
        }
    }]);

    return OfflineIIRFilterNodeProxy;
}(OfflineAudioNodeProxy);

var OfflineIIRFilterNodeFaker = function () {
    function OfflineIIRFilterNodeFaker(_ref2) {
        var fakeNodeStore = _ref2.fakeNodeStore,
            feedback = _ref2.feedback,
            feedforward = _ref2.feedforward,
            invalidStateErrorFactory = _ref2.invalidStateErrorFactory,
            length = _ref2.length,
            nativeNode = _ref2.nativeNode,
            notSupportedErrorFactory = _ref2.notSupportedErrorFactory,
            numberOfChannels = _ref2.numberOfChannels,
            promiseSupportTester = _ref2.promiseSupportTester,
            sampleRate = _ref2.sampleRate,
            UnpatchedOfflineAudioContext = _ref2.UnpatchedOfflineAudioContext;

        _classCallCheck$11(this, OfflineIIRFilterNodeFaker);

        if (feedback.length === 0 || feedback.length > 20) {
            throw notSupportedErrorFactory.create();
        }
        if (feedback[0] === 0) {
            throw invalidStateErrorFactory.create();
        }
        if (feedforward.length === 0 || feedforward.length > 20) {
            throw notSupportedErrorFactory.create();
        }
        if (feedforward[0] === 0) {
            throw invalidStateErrorFactory.create();
        }
        this._feedback = feedback;
        this._feedforward = feedforward;
        this._invalidStateErrorFactory = invalidStateErrorFactory;
        this._length = length;
        this._nativeNode = nativeNode;
        this._node = null;
        this._notSupportedErrorFactory = notSupportedErrorFactory;
        this._numberOfChannels = numberOfChannels;
        this._promiseSupportTester = promiseSupportTester;
        this._proxy = new OfflineIIRFilterNodeProxy({
            fakeNodeStore: fakeNodeStore,
            feedback: feedback,
            feedforward: feedforward,
            nativeNode: nativeNode,
            notSupportedErrorFactory: notSupportedErrorFactory,
            sampleRate: sampleRate
        });
        this._sources = new Map();
        this._UnpatchedOfflineAudioContext = UnpatchedOfflineAudioContext;
        fakeNodeStore.set(this._proxy, this);
    }

    _createClass$11(OfflineIIRFilterNodeFaker, [{
        key: "_applyFilter",
        value: function _applyFilter(renderedBuffer, offlineAudioContext) {
            var bufferIndex = 0;
            var bufferLength = 32;
            var feedback = this._feedback;
            var feedbackLength = this._feedback.length;
            var feedforward = this._feedforward;
            var feedforwardLength = this._feedforward.length;
            if (feedforward.length === 0 || feedforward.length > 20 || feedback.length === 0 || feedback.length > 20) {
                throw this._notSupportedErrorFactory.create();
            }
            if (feedforward[0] === 0 || feedback[0] === 0) {
                throw this._invalidStateErrorFactory.create();
            }
            if (feedback[0] !== 1) {
                for (var i = 0; i < feedbackLength; i += 1) {
                    feedforward[i] /= feedback[0];
                }
                for (var _i = 1; _i < feedforwardLength; _i += 1) {
                    feedback[_i] /= feedback[0];
                }
            }
            var xBuffer = new Float32Array(bufferLength);
            var yBuffer = new Float32Array(bufferLength);
            var minLength = Math.min(feedbackLength, feedforwardLength);
            var filteredBuffer = offlineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
            // This implementation as shamelessly inspired by source code of
            // tslint:disable-next-line:max-line-length
            // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
            var numberOfChannels = renderedBuffer.numberOfChannels;
            for (var _i2 = 0; _i2 < numberOfChannels; _i2 += 1) {
                var input = renderedBuffer.getChannelData(_i2);
                var output = filteredBuffer.getChannelData(_i2);
                // @todo Use TypedArray.prototype.fill() once it lands in Safari.
                for (var j = 0; j < bufferLength; j += 1) {
                    xBuffer[j] = 0;
                    yBuffer[j] = 0;
                }
                var inputLength = input.length;
                for (var _j = 0; _j < inputLength; _j += 1) {
                    var y = feedforward[0] * input[_j];
                    for (var k = 1; k < minLength; k += 1) {
                        var x = bufferIndex - k & bufferLength - 1; // tslint:disable-line:no-bitwise
                        y += feedforward[k] * xBuffer[x];
                        y -= feedback[k] * yBuffer[x];
                    }
                    for (var _k = minLength; _k < feedforwardLength; _k += 1) {
                        y += feedforward[_k] * xBuffer[bufferIndex - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise
                    }
                    for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {
                        y -= feedback[_k2] * yBuffer[bufferIndex - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise
                    }
                    xBuffer[bufferIndex] = input[_j];
                    yBuffer[bufferIndex] = y;
                    bufferIndex = bufferIndex + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise
                    output[_j] = y;
                }
            }
            return filteredBuffer;
        }
    }, {
        key: "render",
        value: function render(offlineAudioContext) {
            var _this2 = this;

            if (this._node !== null) {
                return Promise.resolve(this._node);
            }
            var promises = [];
            // Bug #9: Safari does not support IIRFilterNodes.
            if (this._nativeNode) {
                this._node = offlineAudioContext.createIIRFilter(this._feedforward, this._feedback);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    var _loop = function _loop() {
                        var _step$value = _slicedToArray$4(_step.value, 2),
                            source = _step$value[0],
                            _step$value$ = _step$value[1],
                            input = _step$value$.input,
                            output = _step$value$.output;

                        promises.push(source.render(offlineAudioContext).then(function (node) {
                            return node.connect(_this2._node, output, input);
                        }));
                    };

                    for (var _iterator = this._sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        _loop();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return Promise.all(promises).then(function () {
                    return _this2._node;
                });
            }
            // @todo Somehow retrieve the number of channels.
            var partialOfflineAudioContext = new this._UnpatchedOfflineAudioContext(this._numberOfChannels, this._length, offlineAudioContext.sampleRate);
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                var _loop2 = function _loop2() {
                    var _step2$value = _slicedToArray$4(_step2.value, 2),
                        source = _step2$value[0],
                        _step2$value$ = _step2$value[1],
                        input = _step2$value$.input,
                        output = _step2$value$.output;

                    promises.push(source.render(partialOfflineAudioContext).then(function (node) {
                        return node.connect(partialOfflineAudioContext.destination, output, input);
                    }));
                };

                for (var _iterator2 = this._sources[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    _loop2();
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            return Promise.all(promises).then(function () {
                // Bug #21: Safari does not support promises yet.
                if (_this2._promiseSupportTester.test(partialOfflineAudioContext)) {
                    return partialOfflineAudioContext.startRendering();
                }
                return new Promise(function (resolve) {
                    partialOfflineAudioContext.oncomplete = function (event) {
                        return resolve(event.renderedBuffer);
                    };
                    partialOfflineAudioContext.startRendering();
                });
            }).then(function (renderedBuffer) {
                _this2._node = offlineAudioContext.createBufferSource();
                _this2._node.buffer = _this2._applyFilter(renderedBuffer, offlineAudioContext);
                _this2._node.start(0);
                return _this2._node;
            });
        }
    }, {
        key: "wire",
        value: function wire(source, output, input) {
            this._sources.set(source, { input: input, output: output });
            return this._proxy;
        }
    }, {
        key: "unwire",
        value: function unwire(source) {
            this._sources.delete(source);
        }
    }, {
        key: "proxy",
        get: function get() {
            return this._proxy;
        }
    }]);

    return OfflineIIRFilterNodeFaker;
}();
var OfflineIIRFilterNodeFakerFactory = function () {
    function OfflineIIRFilterNodeFakerFactory(_UnpatchedOfflineAudioContext, _invalidStateErrorFactory, _notSupportedErrorFactory, _promiseSupportTester) {
        _classCallCheck$11(this, OfflineIIRFilterNodeFakerFactory);

        this._UnpatchedOfflineAudioContext = _UnpatchedOfflineAudioContext;
        this._invalidStateErrorFactory = _invalidStateErrorFactory;
        this._notSupportedErrorFactory = _notSupportedErrorFactory;
        this._promiseSupportTester = _promiseSupportTester;
    }

    _createClass$11(OfflineIIRFilterNodeFakerFactory, [{
        key: "create",
        value: function create(_ref3) {
            var fakeNodeStore = _ref3.fakeNodeStore,
                feedback = _ref3.feedback,
                feedforward = _ref3.feedforward,
                length = _ref3.length,
                nativeNode = _ref3.nativeNode,
                numberOfChannels = _ref3.numberOfChannels,
                sampleRate = _ref3.sampleRate;

            return new OfflineIIRFilterNodeFaker({
                UnpatchedOfflineAudioContext: this._UnpatchedOfflineAudioContext,
                fakeNodeStore: fakeNodeStore,
                feedback: feedback,
                feedforward: feedforward,
                invalidStateErrorFactory: this._invalidStateErrorFactory,
                length: length,
                nativeNode: nativeNode,
                notSupportedErrorFactory: this._notSupportedErrorFactory,
                numberOfChannels: numberOfChannels,
                promiseSupportTester: this._promiseSupportTester,
                sampleRate: sampleRate
            });
        }
    }]);

    return OfflineIIRFilterNodeFakerFactory;
}();
OfflineIIRFilterNodeFakerFactory = __decorate([_angular_core.Injectable(), __param(0, _angular_core.Inject(unpatchedOfflineAudioContextConstructor)), __param(1, _angular_core.Inject(InvalidStateErrorFactory)), __param(2, _angular_core.Inject(NotSupportedErrorFactory)), __param(3, _angular_core.Inject(PromiseSupportTester))], OfflineIIRFilterNodeFakerFactory);

var _createClass$13 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$13(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$1(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
function divide$1(a, b) {
    var denominator = b[0] * b[0] + b[1] * b[1];
    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
}
function multiply$1(a, b) {
    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
}
function evaluatePolynomial$1(coefficient, z) {
    var result = [0, 0];
    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
        result = multiply$1(result, z);
        result[0] += coefficient[i];
    }
    return result;
}
var IIRFilterNodeFaker = function () {
    function IIRFilterNodeFaker(_invalidAccessErrorFactory, _invalidStateErrorFactory, _notSupportedErrorFactory) {
        _classCallCheck$13(this, IIRFilterNodeFaker);

        this._invalidAccessErrorFactory = _invalidAccessErrorFactory;
        this._invalidStateErrorFactory = _invalidStateErrorFactory;
        this._notSupportedErrorFactory = _notSupportedErrorFactory;
    }

    _createClass$13(IIRFilterNodeFaker, [{
        key: "fake",
        value: function fake(feedforward, feedback, audioContext, unpatchedAudioContext) {
            var _this = this;

            var bufferIndex = 0;
            var bufferLength = 32;
            var feedbackLength = feedback.length;
            var feedforwardLength = feedforward.length;
            if (feedforward.length === 0 || feedforward.length > 20 || feedback.length === 0 || feedback.length > 20) {
                throw this._notSupportedErrorFactory.create();
            }
            if (feedforward[0] === 0 || feedback[0] === 0) {
                throw this._invalidStateErrorFactory.create();
            }
            if (feedback[0] !== 1) {
                for (var i = 0; i < feedforwardLength; i += 1) {
                    feedforward[i] /= feedback[0];
                }
                for (var _i = 1; _i < feedbackLength; _i += 1) {
                    feedback[_i] /= feedback[0];
                }
            }
            var gainNode = audioContext.createGain();
            var nyquist = audioContext.sampleRate / 2;
            // @todo Remove this once the audioContext supports the createScriptProcessor() method, too.
            var scriptProcessorNode = unpatchedAudioContext.createScriptProcessor(256, gainNode.channelCount, gainNode.channelCount);
            var bufferSize = scriptProcessorNode.bufferSize;
            var xBuffer = new Float32Array(bufferLength);
            var yBuffer = new Float32Array(bufferLength);
            var minLength = Math.min(feedbackLength, feedforwardLength);
            // @todo Use TypedArray.prototype.fill() once it lands in Safari.
            for (var _i2 = 0; _i2 < bufferLength; _i2 += 1) {
                xBuffer[_i2] = 0;
                yBuffer[_i2] = 0;
            }
            // This implementation as shamelessly inspired by source code of
            // tslint:disable-next-line:max-line-length
            // {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.
            scriptProcessorNode.onaudioprocess = function (event) {
                var inputBuffer = event.inputBuffer;
                var outputBuffer = event.outputBuffer;
                var numberOfChannels = inputBuffer.numberOfChannels;
                for (var _i3 = 0; _i3 < numberOfChannels; _i3 += 1) {
                    var input = inputBuffer.getChannelData(_i3);
                    var output = outputBuffer.getChannelData(_i3);
                    for (var j = 0; j < bufferSize; j += 1) {
                        var y = feedforward[0] * input[j];
                        for (var k = 1; k < minLength; k += 1) {
                            var x = bufferIndex - k & bufferLength - 1; // tslint:disable-line:no-bitwise
                            y += feedforward[k] * xBuffer[x];
                            y -= feedback[k] * yBuffer[x];
                        }
                        for (var _k = minLength; _k < feedforwardLength; _k += 1) {
                            y += feedforward[_k] * xBuffer[bufferIndex - _k & bufferLength - 1]; // tslint:disable-line:no-bitwise
                        }
                        for (var _k2 = minLength; _k2 < feedbackLength; _k2 += 1) {
                            y -= feedback[_k2] * yBuffer[bufferIndex - _k2 & bufferLength - 1]; // tslint:disable-line:no-bitwise
                        }
                        xBuffer[bufferIndex] = input[j];
                        yBuffer[bufferIndex] = y;
                        bufferIndex = bufferIndex + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise
                        output[j] = y;
                    }
                }
            };
            gainNode.getFrequencyResponse = function (frequencyHz, magResponse, phaseResponse) {
                if (magResponse.length === 0 || phaseResponse.length === 0) {
                    throw _this._notSupportedErrorFactory.create();
                }
                var length = frequencyHz.length;
                for (var _i4 = 0; _i4 < length; _i4 += 1) {
                    var omega = -Math.PI * (frequencyHz[_i4] / nyquist);
                    var z = [Math.cos(omega), Math.sin(omega)];
                    var numerator = evaluatePolynomial$1(feedforward, z);
                    var denominator = evaluatePolynomial$1(feedback, z);
                    var response = divide$1(numerator, denominator);
                    magResponse[_i4] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
                    phaseResponse[_i4] = Math.atan2(response[1], response[0]);
                }
            };
            gainNode.connect(scriptProcessorNode);
            gainNode.connect = function (destination) {
                var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                console.log('HEY');
                try {
                    scriptProcessorNode.connect.call(scriptProcessorNode, destination, output, input);
                } catch (err) {
                    console.log(err, err.code);
                    if (err.code === 12) {
                        throw _this._invalidAccessErrorFactory.create();
                    }
                    throw err;
                }
                return destination;
            };
            return gainNode;
        }
    }]);

    return IIRFilterNodeFaker;
}();
IIRFilterNodeFaker = __decorate$1([_angular_core.Injectable(), __param$1(0, _angular_core.Inject(InvalidAccessErrorFactory)), __param$1(1, _angular_core.Inject(InvalidStateErrorFactory)), __param$1(2, _angular_core.Inject(NotSupportedErrorFactory))], IIRFilterNodeFaker);

var _createClass$15 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$15(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AnalyserNodeGetFloatTimeDomainDataSupportTester = function () {
    function AnalyserNodeGetFloatTimeDomainDataSupportTester() {
        _classCallCheck$15(this, AnalyserNodeGetFloatTimeDomainDataSupportTester);
    }

    _createClass$15(AnalyserNodeGetFloatTimeDomainDataSupportTester, [{
        key: 'test',
        value: function test(audioContext) {
            var analyserNode = audioContext.createAnalyser();
            return typeof analyserNode.getFloatTimeDomainData === 'function';
        }
    }]);

    return AnalyserNodeGetFloatTimeDomainDataSupportTester;
}();

var _createClass$16 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$16(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioBufferCopyChannelMethodsSupportTester = function () {
    function AudioBufferCopyChannelMethodsSupportTester() {
        _classCallCheck$16(this, AudioBufferCopyChannelMethodsSupportTester);
    }

    _createClass$16(AudioBufferCopyChannelMethodsSupportTester, [{
        key: "test",
        value: function test(audioContext) {
            var audioBuffer = audioContext.createBuffer(1, 1, audioContext.sampleRate);
            var source = new Float32Array(2);
            try {
                /*
                 * Only Firefox does not fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those
                 * methods is enough to know if the other one it supported as well.
                 */
                audioBuffer.copyToChannel(source, 0);
            } catch (err) {
                return false;
            }
            return true;
        }
    }]);

    return AudioBufferCopyChannelMethodsSupportTester;
}();

var _createClass$17 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$17(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ChainingSupportTester = function () {
    function ChainingSupportTester() {
        _classCallCheck$17(this, ChainingSupportTester);
    }

    _createClass$17(ChainingSupportTester, [{
        key: "test",
        value: function test(audioContext) {
            var destination = audioContext.createGain();
            var target = audioContext.createGain();
            var isSupportingChaining = target.connect(destination) === destination;
            target.disconnect(destination);
            return isSupportingChaining;
        }
    }]);

    return ChainingSupportTester;
}();

var unpatchedAudioContextConstructor = new _angular_core.OpaqueToken('UNPATCHED_AUDIO_CONTEXT_CONSTRUCTOR');
var UNPATCHED_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
    deps: [Window],
    provide: unpatchedAudioContextConstructor,
    useFactory: function useFactory(window) {
        return window.hasOwnProperty('AudioContext') ? window.AudioContext : window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;
    }
};

var _createClass$18 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$18(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$2(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var ConnectingSupportTester = function () {
    function ConnectingSupportTester(_UnpatchedAudioContext) {
        _classCallCheck$18(this, ConnectingSupportTester);

        this._UnpatchedAudioContext = _UnpatchedAudioContext;
    }

    _createClass$18(ConnectingSupportTester, [{
        key: "test",
        value: function test(audioContext) {
            if (this._UnpatchedAudioContext === null) {
                return false;
            }
            var analyserNode = audioContext.createAnalyser();
            var anotherAudioContext = new this._UnpatchedAudioContext();
            try {
                analyserNode.connect(anotherAudioContext.destination);
            } catch (err) {
                return err.code === 15;
            } finally {
                anotherAudioContext.close();
            }
        }
    }]);

    return ConnectingSupportTester;
}();
ConnectingSupportTester = __decorate$2([_angular_core.Injectable(), __param$2(0, _angular_core.Inject(unpatchedAudioContextConstructor))], ConnectingSupportTester);

var _createClass$19 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$19(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DisconnectingSupportTester = function () {
    function DisconnectingSupportTester() {
        _classCallCheck$19(this, DisconnectingSupportTester);
    }

    _createClass$19(DisconnectingSupportTester, [{
        key: "test",
        value: function test(audioContext) {
            return new Promise(function (resolve, reject) {
                var analyzer = audioContext.createScriptProcessor(256, 1, 1);
                var dummy = audioContext.createGain();
                // Safari does not play buffers which contain just one frame.
                var ones = audioContext.createBuffer(1, 2, 44100);
                var channelData = ones.getChannelData(0);
                channelData[0] = 1;
                channelData[1] = 1;
                var source = audioContext.createBufferSource();
                source.buffer = ones;
                source.loop = true;
                source.connect(analyzer);
                analyzer.connect(audioContext.destination);
                source.connect(dummy);
                source.disconnect(dummy);
                analyzer.onaudioprocess = function (event) {
                    var chnnlDt = event.inputBuffer.getChannelData(0);
                    if (Array.prototype.some.call(chnnlDt, function (sample) {
                        return sample === 1;
                    })) {
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                    source.stop();
                    analyzer.onaudioprocess = null;
                    source.disconnect(analyzer);
                    analyzer.disconnect(audioContext.destination);
                };
                source.start();
            });
        }
    }]);

    return DisconnectingSupportTester;
}();

var _createClass$20 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$20(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StopStoppedSupportTester = function () {
    function StopStoppedSupportTester() {
        _classCallCheck$20(this, StopStoppedSupportTester);
    }

    _createClass$20(StopStoppedSupportTester, [{
        key: "test",
        value: function test(audioContext) {
            var audioBuffer = audioContext.createBuffer(1, 1, 44100);
            var audioBufferSourceNode = audioContext.createBufferSource();
            audioBufferSourceNode.buffer = audioBuffer;
            audioBufferSourceNode.start();
            audioBufferSourceNode.stop();
            try {
                audioBufferSourceNode.stop();
                return true;
            } catch (err) {
                return false;
            }
        }
    }]);

    return StopStoppedSupportTester;
}();

var _createClass$21 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$21(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AnalyserNodeGetFloatTimeDomainDataMethodWrapper = function () {
    function AnalyserNodeGetFloatTimeDomainDataMethodWrapper() {
        _classCallCheck$21(this, AnalyserNodeGetFloatTimeDomainDataMethodWrapper);
    }

    _createClass$21(AnalyserNodeGetFloatTimeDomainDataMethodWrapper, [{
        key: "wrap",
        value: function wrap(analyserNode) {
            analyserNode.getFloatTimeDomainData = function (array) {
                var byteTimeDomainData = new Uint8Array(array.length);
                analyserNode.getByteTimeDomainData(byteTimeDomainData);
                var length = Math.max(byteTimeDomainData.length, analyserNode.fftSize);
                for (var i = 0; i < length; i += 1) {
                    array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;
                }
                return array;
            };
        }
    }]);

    return AnalyserNodeGetFloatTimeDomainDataMethodWrapper;
}();

var _createClass$22 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$22(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$3(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var AudioBufferWrapper = function () {
    function AudioBufferWrapper(_indexSizeErrorFactory) {
        _classCallCheck$22(this, AudioBufferWrapper);

        this._indexSizeErrorFactory = _indexSizeErrorFactory;
    }

    _createClass$22(AudioBufferWrapper, [{
        key: "wrap",
        value: function wrap(audioBuffer) {
            var _this = this;

            audioBuffer.copyFromChannel = function (destination, channelNumber) {
                var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                if (channelNumber >= audioBuffer.numberOfChannels || startInChannel >= audioBuffer.length) {
                    throw _this._indexSizeErrorFactory.create();
                }
                var channelData = audioBuffer.getChannelData(channelNumber);
                var channelLength = channelData.length;
                var destinationLength = destination.length;
                for (var i = 0; i + startInChannel < channelLength && i < destinationLength; i += 1) {
                    destination[i] = channelData[i + startInChannel];
                }
            };
            audioBuffer.copyToChannel = function (source, channelNumber) {
                var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                if (channelNumber >= audioBuffer.numberOfChannels || startInChannel >= audioBuffer.length) {
                    throw _this._indexSizeErrorFactory.create();
                }
                var channelData = audioBuffer.getChannelData(channelNumber);
                var channelLength = channelData.length;
                var sourceLength = source.length;
                for (var i = 0; i + startInChannel < channelLength && i < sourceLength; i += 1) {
                    channelData[i + startInChannel] = source[i];
                }
            };
        }
    }]);

    return AudioBufferWrapper;
}();
AudioBufferWrapper = __decorate$3([_angular_core.Injectable(), __param$3(0, _angular_core.Inject(IndexSizeErrorFactory))], AudioBufferWrapper);

var _createClass$23 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$23(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioBufferCopyChannelMethodsWrapper = function () {
    function AudioBufferCopyChannelMethodsWrapper() {
        _classCallCheck$23(this, AudioBufferCopyChannelMethodsWrapper);
    }

    _createClass$23(AudioBufferCopyChannelMethodsWrapper, [{
        key: "wrap",
        value: function wrap(audioBuffer) {
            audioBuffer.copyFromChannel = function (copyFromChannel) {
                return function (destination, channelNumber) {
                    var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                    if (startInChannel < audioBuffer.length && audioBuffer.length - startInChannel < destination.length) {
                        return copyFromChannel.call(audioBuffer, destination.subarray(0, audioBuffer.length - startInChannel), channelNumber, startInChannel);
                    }
                    return copyFromChannel.call(audioBuffer, destination, channelNumber, startInChannel);
                };
            }(audioBuffer.copyFromChannel);
            audioBuffer.copyToChannel = function (copyToChannel) {
                return function (source, channelNumber) {
                    var startInChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                    if (startInChannel < audioBuffer.length && audioBuffer.length - startInChannel < source.length) {
                        return copyToChannel.call(audioBuffer, source.subarray(0, audioBuffer.length - startInChannel), channelNumber, startInChannel);
                    }
                    return copyToChannel.call(audioBuffer, source, channelNumber, startInChannel);
                };
            }(audioBuffer.copyToChannel);
        }
    }]);

    return AudioBufferCopyChannelMethodsWrapper;
}();

var _createClass$24 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$24(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioBufferSourceNodeStopMethodWrapper = function () {
    function AudioBufferSourceNodeStopMethodWrapper() {
        _classCallCheck$24(this, AudioBufferSourceNodeStopMethodWrapper);
    }

    _createClass$24(AudioBufferSourceNodeStopMethodWrapper, [{
        key: 'wrap',
        value: function wrap(audioBufferSourceNode, audioContext) {
            var gainNode = audioContext.createGain();
            audioBufferSourceNode.connect(gainNode);
            audioBufferSourceNode.addEventListener('ended', function () {
                return audioBufferSourceNode.disconnect(gainNode);
            });
            audioBufferSourceNode.connect = function (destination) {
                var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                gainNode.connect.call(gainNode, destination, output, input);
                return destination;
            };
            audioBufferSourceNode.disconnect = function () {
                gainNode.disconnect.apply(gainNode, arguments);
            };
            audioBufferSourceNode.stop = function (stop) {
                var isStopped = false;
                return function () {
                    var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

                    if (isStopped) {
                        try {
                            stop.call(audioBufferSourceNode, when);
                        } catch (err) {
                            gainNode.gain.setValueAtTime(0, when);
                        }
                    } else {
                        stop.call(audioBufferSourceNode, when);
                        isStopped = true;
                    }
                };
            }(audioBufferSourceNode.stop);
        }
    }]);

    return AudioBufferSourceNodeStopMethodWrapper;
}();

var _createClass$25 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$4 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$25(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$4(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var AudioNodeConnectMethodWrapper = function () {
    function AudioNodeConnectMethodWrapper(_invalidAccessErrorFactory) {
        _classCallCheck$25(this, AudioNodeConnectMethodWrapper);

        this._invalidAccessErrorFactory = _invalidAccessErrorFactory;
    }

    _createClass$25(AudioNodeConnectMethodWrapper, [{
        key: "wrap",
        value: function wrap(audioNode) {
            var _this = this;

            audioNode.connect = function (connect, isSupportingChaining, isSupportingConnecting) {
                if (isSupportingChaining) {
                    return function (destination) {
                        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                        try {
                            return connect.call(audioNode, destination, output, input);
                        } catch (err) {
                            if (err.code === 12) {
                                throw _this._invalidAccessErrorFactory.create();
                            }
                            throw err;
                        }
                    };
                } else {
                    return function (destination) {
                        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                        try {
                            connect.call(audioNode, destination, output, input);
                        } catch (err) {
                            if (err.code === 12) {
                                throw _this._invalidAccessErrorFactory.create();
                            }
                            throw err;
                        }
                        return destination;
                    };
                }
            }(audioNode.connect);
        }
    }]);

    return AudioNodeConnectMethodWrapper;
}();
AudioNodeConnectMethodWrapper = __decorate$4([_angular_core.Injectable(), __param$4(0, _angular_core.Inject(InvalidAccessErrorFactory))], AudioNodeConnectMethodWrapper);

var _createClass$26 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$26(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioNodeDisconnectMethodWrapper = function () {
    function AudioNodeDisconnectMethodWrapper() {
        _classCallCheck$26(this, AudioNodeDisconnectMethodWrapper);
    }

    _createClass$26(AudioNodeDisconnectMethodWrapper, [{
        key: "wrap",
        value: function wrap(audioNode) {
            var destinations = new Map();
            audioNode.connect = function (connect) {
                return function (destination) {
                    var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                    destinations.set(destination, { input: input, output: output });
                    return connect.call(audioNode, destination, output, input);
                };
            }(audioNode.connect);
            audioNode.disconnect = function (disconnect) {
                return function () {
                    var destination = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                    disconnect.apply(audioNode);
                    if (destination !== null && destinations.has(destination)) {
                        destinations.delete(destination);
                        destinations.forEach(function (_ref, dstntn) {
                            var input = _ref.input,
                                output = _ref.output;

                            audioNode.connect(dstntn, input, output);
                        });
                    }
                };
            }(audioNode.disconnect);
        }
    }]);

    return AudioNodeDisconnectMethodWrapper;
}();

var _createClass$27 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$5 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$27(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$5(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var ChannelMergerNodeWrapper = function () {
    function ChannelMergerNodeWrapper(_invalidStateErrorFactory) {
        _classCallCheck$27(this, ChannelMergerNodeWrapper);

        this._invalidStateErrorFactory = _invalidStateErrorFactory;
    }

    _createClass$27(ChannelMergerNodeWrapper, [{
        key: "wrap",
        value: function wrap(audioContext, channelMergerNode) {
            var _this = this;

            var audioBufferSourceNode = audioContext.createBufferSource();
            channelMergerNode.channelCount = 1;
            channelMergerNode.channelCountMode = 'explicit';
            // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.
            var length = channelMergerNode.numberOfInputs;
            for (var i = 0; i < length; i += 1) {
                audioBufferSourceNode.connect(channelMergerNode, 0, i);
            }
            Object.defineProperty(channelMergerNode, 'channelCount', {
                get: function get() {
                    return 1;
                },
                set: function set() {
                    throw _this._invalidStateErrorFactory.create();
                }
            });
            Object.defineProperty(channelMergerNode, 'channelCountMode', {
                get: function get() {
                    return 'explicit';
                },
                set: function set() {
                    throw _this._invalidStateErrorFactory.create();
                }
            });
        }
    }]);

    return ChannelMergerNodeWrapper;
}();
ChannelMergerNodeWrapper = __decorate$5([_angular_core.Injectable(), __param$5(0, _angular_core.Inject(InvalidStateErrorFactory))], ChannelMergerNodeWrapper);

var _createClass$28 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$6 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$28(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$6(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var ChannelSplitterNodeWrapper = function () {
    function ChannelSplitterNodeWrapper(_invalidStateErrorFactory) {
        _classCallCheck$28(this, ChannelSplitterNodeWrapper);

        this._invalidStateErrorFactory = _invalidStateErrorFactory;
    }

    _createClass$28(ChannelSplitterNodeWrapper, [{
        key: "wrap",
        value: function wrap(channelSplitterNode) {
            var _this = this;

            channelSplitterNode.channelCountMode = 'explicit';
            channelSplitterNode.channelInterpretation = 'discrete';
            Object.defineProperty(channelSplitterNode, 'channelCountMode', {
                get: function get() {
                    return 'explicit';
                },
                set: function set() {
                    throw _this._invalidStateErrorFactory.create();
                }
            });
            Object.defineProperty(channelSplitterNode, 'channelInterpretation', {
                get: function get() {
                    return 'discrete';
                },
                set: function set() {
                    throw _this._invalidStateErrorFactory.create();
                }
            });
        }
    }]);

    return ChannelSplitterNodeWrapper;
}();
ChannelSplitterNodeWrapper = __decorate$6([_angular_core.Injectable(), __param$6(0, _angular_core.Inject(InvalidStateErrorFactory))], ChannelSplitterNodeWrapper);

var _createClass$29 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$7 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$29(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$7(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var IIRFilterNodeGetFrequencyResponseMethodWrapper = function () {
    function IIRFilterNodeGetFrequencyResponseMethodWrapper(_notSupportedErrorFactory) {
        _classCallCheck$29(this, IIRFilterNodeGetFrequencyResponseMethodWrapper);

        this._notSupportedErrorFactory = _notSupportedErrorFactory;
    }

    _createClass$29(IIRFilterNodeGetFrequencyResponseMethodWrapper, [{
        key: "wrap",
        value: function wrap(iIRFilterNode) {
            var _this = this;

            iIRFilterNode.getFrequencyResponse = function (getFrequencyResponse) {
                return function (frequencyHz, magResponse, phaseResponse) {
                    if (magResponse.length === 0 || phaseResponse.length === 0) {
                        throw _this._notSupportedErrorFactory.create();
                    }
                    return getFrequencyResponse.call(iIRFilterNode, frequencyHz, magResponse, phaseResponse);
                };
            }(iIRFilterNode.getFrequencyResponse);
        }
    }]);

    return IIRFilterNodeGetFrequencyResponseMethodWrapper;
}();
IIRFilterNodeGetFrequencyResponseMethodWrapper = __decorate$7([_angular_core.Injectable(), __param$7(0, _angular_core.Inject(NotSupportedErrorFactory))], IIRFilterNodeGetFrequencyResponseMethodWrapper);

var DetachedAudioBuffers = new _angular_core.OpaqueToken('DETACHED_AUDIO_BUFFERS'); // tslint:disable-line:variable-name
// tslint:disable-line:variable-name
var DETACHED_AUDIO_BUFFERS_PROVIDER = { provide: DetachedAudioBuffers, useValue: new WeakSet() };

var _createClass$14 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$14(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var audioContextConstructor = new _angular_core.OpaqueToken('AUDIO_CONTEXT_CONSTRUCTOR');
var AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
    deps: [AnalyserNodeGetFloatTimeDomainDataMethodWrapper, AnalyserNodeGetFloatTimeDomainDataSupportTester, AudioBufferCopyChannelMethodsSupportTester, AudioBufferCopyChannelMethodsWrapper, AudioBufferSourceNodeStopMethodWrapper, AudioBufferWrapper, AudioNodeConnectMethodWrapper, AudioNodeDisconnectMethodWrapper, ChainingSupportTester, ChannelMergerNodeWrapper, ChannelSplitterNodeWrapper, ConnectingSupportTester, DataCloneErrorFactory, DetachedAudioBuffers, DisconnectingSupportTester, EncodingErrorFactory, InvalidAccessErrorFactory, InvalidStateErrorFactory, IIRFilterNodeFaker, IIRFilterNodeGetFrequencyResponseMethodWrapper, PromiseSupportTester, StopStoppedSupportTester, unpatchedAudioContextConstructor],
    provide: audioContextConstructor,
    useFactory: function useFactory(analyserNodeGetFloatTimeDomainDataMethodWrapper, analyserNodeGetFloatTimeDomainDataSupportTester, audioBufferCopyChannelMethodsSupportTester, audioBufferCopyChannelMethodsWrapper, audioBufferSourceNodeStopMethodWrapper, audioBufferWrapper, audioNodeConnectMethodWrapper, audioNodeDisconnectMethodWrapper, chainingSupportTester, channelMergerNodeWrapper, channelSplitterNodeWrapper, connectingSupportTester, dataCloneErrorFactory, detachedAudioBuffers, disconnectingSupportTester, encodingErrorFactory, invalidAccessErrorFactory, invalidStateErrorFactory, iIRFilterNodeFaker, iIRFilterNodeGetFrequencyResponseMethodWrapper, promiseSupportTester, stopStoppedSupportTester, UnpatchedAudioContext // tslint:disable-line:variable-name
    ) {
        var AudioContext = function () {
            function AudioContext() {
                var _this = this;

                _classCallCheck$14(this, AudioContext);

                var unpatchedAudioContext = new UnpatchedAudioContext();
                this._isSupportingAnalyserNodeGetFloatTimeDomainData = analyserNodeGetFloatTimeDomainDataSupportTester.test(unpatchedAudioContext);
                this._isSupportingChaining = chainingSupportTester.test(unpatchedAudioContext);
                this._isSupportingCopyChannelMethods = audioBufferCopyChannelMethodsSupportTester.test(unpatchedAudioContext);
                this._isSupportingConnecting = connectingSupportTester.test(unpatchedAudioContext);
                this._isSupportingDisconnecting = false;
                // @todo Actually check for getFrequencyResponse() errors support.
                this._isSupportingGetFrequencyResponseErrors = false;
                this._isSupportingPromises = promiseSupportTester.test(unpatchedAudioContext);
                this._isSupportingStoppingOfStoppedNodes = stopStoppedSupportTester.test(unpatchedAudioContext);
                this._onStateChangeListener = null;
                this._unpatchedAudioContext = unpatchedAudioContext;
                this._state = null;
                disconnectingSupportTester.test(unpatchedAudioContext).then(function (isSupportingDisconnecting) {
                    _this._isSupportingDisconnecting = isSupportingDisconnecting;
                });
                /*
                 * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually
                 * changes to 'running'.
                 */
                if (unpatchedAudioContext.state === 'running') {
                    this._state = 'suspended';
                    var revokeState = function revokeState() {
                        if (_this._state === 'suspended') {
                            _this._state = null;
                        }
                        if (unpatchedAudioContext.removeEventListener) {
                            unpatchedAudioContext.removeEventListener('statechange', revokeState);
                        }
                    };
                    unpatchedAudioContext.addEventListener('statechange', revokeState);
                }
            }

            _createClass$14(AudioContext, [{
                key: 'close',
                value: function close() {
                    // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
                    if (this.state === 'closed') {
                        return this._unpatchedAudioContext.close().then(function () {
                            throw invalidStateErrorFactory.create();
                        });
                    }
                    // Bug #34: If the state was set to suspended before it should be revoked now.
                    if (this._state === 'suspended') {
                        this._state = null;
                    }
                    return this._unpatchedAudioContext.close();
                }
            }, {
                key: 'createAnalyser',
                value: function createAnalyser() {
                    if (this._unpatchedAudioContext === null) {
                        throw invalidStateErrorFactory.create();
                    }
                    var analyserNode = this._unpatchedAudioContext.createAnalyser();
                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                    // tslint:disable-next-line:comment-format
                    // the behaviour of throwing an error.
                    if (this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #37: Only Chrome Canary and Firefox create an AnalyserNode with default properties.
                    if (analyserNode.channelCount === 2) {
                        analyserNode.channelCount = 1;
                    }
                    // Bug #36: Safari does not support getFloatTimeDomainData() yet.
                    if (!this._isSupportingAnalyserNodeGetFloatTimeDomainData) {
                        analyserNodeGetFloatTimeDomainDataMethodWrapper.wrap(analyserNode);
                    }
                    // Bug #11: Safari does not support chaining yet.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(analyserNode, this._isSupportingChaining, this._isSupportingConnecting);
                    }
                    // Only Chrome and Opera support disconnecting of a specific destination.
                    if (!this._isSupportingDisconnecting) {
                        audioNodeDisconnectMethodWrapper.wrap(analyserNode);
                    }
                    return analyserNode;
                }
            }, {
                key: 'createBiquadFilter',
                value: function createBiquadFilter() {
                    if (this._unpatchedAudioContext === null) {
                        throw invalidStateErrorFactory.create();
                    }
                    var biquadFilterNode = this._unpatchedAudioContext.createBiquadFilter();
                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                    // tslint:disable-next-line:comment-format
                    // the behaviour of throwing an error.
                    if (this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #11: Safari does not support chaining yet.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(biquadFilterNode, this._isSupportingChaining, this._isSupportingConnecting);
                    }
                    return biquadFilterNode;
                }
            }, {
                key: 'createBuffer',
                value: function createBuffer(numberOfChannels, length, sampleRate) {
                    var audioBuffer = this._unpatchedAudioContext.createBuffer(numberOfChannels, length, sampleRate);
                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                    if (typeof audioBuffer.copyFromChannel !== 'function') {
                        audioBufferWrapper.wrap(audioBuffer);
                        // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                    } else if (!this._isSupportingCopyChannelMethods) {
                        audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
                    }
                    return audioBuffer;
                }
            }, {
                key: 'createBufferSource',
                value: function createBufferSource() {
                    var audioBufferSourceNode = this._unpatchedAudioContext.createBufferSource();
                    // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.
                    if (!this._isSupportingStoppingOfStoppedNodes) {
                        audioBufferSourceNodeStopMethodWrapper.wrap(audioBufferSourceNode, this);
                        return audioBufferSourceNode;
                    }
                    // Bug #11: Safari does not support chaining yet but is already patched above.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(audioBufferSourceNode, true, this._isSupportingConnecting);
                    }
                    return audioBufferSourceNode;
                }
            }, {
                key: 'createChannelMerger',
                value: function createChannelMerger() {
                    if (this._unpatchedAudioContext === null) {
                        throw invalidStateErrorFactory.create();
                    }
                    var channelMergerNode = this._unpatchedAudioContext.createChannelMerger.apply(this._unpatchedAudioContext, arguments);
                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                    // tslint:disable-next-line:comment-format
                    // the behaviour of throwing an error.
                    if (this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #11: Safari does not support chaining yet.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(channelMergerNode, this._isSupportingChaining, this._isSupportingConnecting);
                    }
                    // Bug #15: Safari does not return the default properties.
                    if (channelMergerNode.channelCount !== 1 && channelMergerNode.channelCountMode !== 'explicit') {
                        channelMergerNodeWrapper.wrap(this._unpatchedAudioContext, channelMergerNode);
                    }
                    // Bug #16: Firefox does not throw an error when setting a different channelCount or channelCountMode.
                    try {
                        channelMergerNode.channelCount = 2;
                        channelMergerNodeWrapper.wrap(this._unpatchedAudioContext, channelMergerNode);
                    } catch (err) {} // tslint:disable-line:no-empty
                    return channelMergerNode;
                }
            }, {
                key: 'createChannelSplitter',
                value: function createChannelSplitter() {
                    if (this._unpatchedAudioContext === null) {
                        throw invalidStateErrorFactory.create();
                    }
                    var channelSplitterNode = this._unpatchedAudioContext.createChannelSplitter.apply(this._unpatchedAudioContext, arguments);
                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                    // tslint:disable-next-line:comment-format
                    // the behaviour of throwing an error.
                    if (this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #11: Safari does not support chaining yet.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(channelSplitterNode, this._isSupportingChaining, this._isSupportingConnecting);
                    }
                    // Bug #29 - #32: Only Chrome partially supports the spec yet.
                    channelSplitterNodeWrapper.wrap(channelSplitterNode);
                    return channelSplitterNode;
                }
            }, {
                key: 'createGain',
                value: function createGain() {
                    if (this._unpatchedAudioContext === null) {
                        throw invalidStateErrorFactory.create();
                    }
                    var gainNode = this._unpatchedAudioContext.createGain();
                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                    // tslint:disable-next-line:comment-format
                    // the behaviour of throwing an error.
                    if (this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #11: Safari does not support chaining yet.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(gainNode, this._isSupportingChaining, this._isSupportingConnecting);
                    }
                    // Bug #12: Firefox and Safari do not support to disconnect a specific destination.
                    if (!this._isSupportingDisconnecting) {
                        audioNodeDisconnectMethodWrapper.wrap(gainNode);
                    }
                    return gainNode;
                }
            }, {
                key: 'createIIRFilter',
                value: function createIIRFilter(feedforward, feedback) {
                    // Bug #10: Edge does not throw an error when the context is closed.
                    if (this._unpatchedAudioContext === null && this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #9: Safari does not support IIRFilterNodes.
                    if (this._unpatchedAudioContext.createIIRFilter === undefined) {
                        return iIRFilterNodeFaker.fake(feedforward, feedback, this, this._unpatchedAudioContext);
                    }
                    var iIRFilterNode = this._unpatchedAudioContext.createIIRFilter(feedforward, feedback);
                    // Bug 23 & 24: FirefoxDeveloper does not throw NotSupportedErrors anymore.
                    if (!this._isSupportingGetFrequencyResponseErrors) {
                        iIRFilterNodeGetFrequencyResponseMethodWrapper.wrap(iIRFilterNode);
                    }
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(iIRFilterNode, true, this._isSupportingConnecting);
                    }
                    return iIRFilterNode;
                }
            }, {
                key: 'createOscillator',
                value: function createOscillator() {
                    if (this._unpatchedAudioContext === null) {
                        throw invalidStateErrorFactory.create();
                    }
                    var oscillatorNode = this._unpatchedAudioContext.createOscillator();
                    // If the unpatched AudioContext throws an error by itself, this code will never get executed. If it does it will imitate
                    // tslint:disable-next-line:comment-format
                    // the behaviour of throwing an error.
                    if (this.state === 'closed') {
                        throw invalidStateErrorFactory.create();
                    }
                    // Bug #11: Safari does not support chaining yet.
                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.
                    if (!this._isSupportingChaining || !this._isSupportingConnecting) {
                        audioNodeConnectMethodWrapper.wrap(oscillatorNode, this._isSupportingChaining, this._isSupportingConnecting);
                    }
                    return oscillatorNode;
                }
            }, {
                key: 'decodeAudioData',
                value: function decodeAudioData(audioData, successCallback, errorCallback) {
                    var _this2 = this;

                    // Bug #43: Only Chrome Canary does yet throw a DataCloneError.
                    if (detachedAudioBuffers.has(audioData)) {
                        var err = dataCloneErrorFactory.create();
                        if (typeof errorCallback === 'function') {
                            errorCallback(err);
                        }
                        return Promise.reject(err);
                    }
                    // The audioData parameter maybe of a type which can't be added to a WeakSet.
                    try {
                        detachedAudioBuffers.add(audioData);
                    } catch (err) {}
                    // Ignore errors.

                    // Bug #21: Safari does not support promises yet.
                    if (this._isSupportingPromises) {
                        // Bug #1: Chrome requires a successCallback.
                        if (successCallback === undefined) {
                            successCallback = function successCallback() {}; // tslint:disable-line:no-empty
                        }
                        return this._unpatchedAudioContext.decodeAudioData(audioData, successCallback, function (err) {
                            if (typeof errorCallback === 'function') {
                                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                                if (err instanceof DOMException && err.name === 'NotSupportedError') {
                                    errorCallback(new TypeError());
                                } else {
                                    errorCallback(err);
                                }
                            }
                        }).catch(function (err) {
                            // Bug #6: Chrome, Firefox and Opera do not call the errorCallback in case of an invalid buffer.
                            if (typeof errorCallback === 'function' && err instanceof TypeError) {
                                errorCallback(err);
                            }
                            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                            if (err instanceof DOMException && err.name === 'NotSupportedError') {
                                throw new TypeError();
                            }
                            throw err;
                        });
                    }
                    // Bug #21: Safari does not return a Promise yet.
                    return new Promise(function (resolve, reject) {
                        var fail = function fail(err) {
                            if (typeof errorCallback === 'function') {
                                errorCallback(err);
                            }
                            reject(err);
                        };
                        var succeed = function succeed(dBffrWrppr) {
                            resolve(dBffrWrppr);
                            if (typeof successCallback === 'function') {
                                successCallback(dBffrWrppr);
                            }
                        };
                        // Bug #26: Safari throws a synchronous error.
                        try {
                            // Bug #1: Safari requires a successCallback.
                            _this2._unpatchedAudioContext.decodeAudioData(audioData, function (audioBuffer) {
                                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                                if (typeof audioBuffer.copyFromChannel !== 'function') {
                                    audioBufferWrapper.wrap(audioBuffer);
                                    // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                                } else if (!_this2._isSupportingCopyChannelMethods) {
                                    audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
                                }
                                succeed(audioBuffer);
                            }, function (err) {
                                // Bug #4: Safari returns null instead of an error.
                                if (err === null) {
                                    fail(encodingErrorFactory.create());
                                } else {
                                    fail(err);
                                }
                            });
                        } catch (err) {
                            fail(err);
                        }
                    });
                }
            }, {
                key: 'currentTime',
                get: function get() {
                    return this._unpatchedAudioContext.currentTime;
                },
                set: function set(value) {
                    this._unpatchedAudioContext.currentTime = value;
                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
                    throw new TypeError();
                }
            }, {
                key: 'destination',
                get: function get() {
                    return this._unpatchedAudioContext.destination;
                },
                set: function set(value) {
                    this._unpatchedAudioContext.destination = value;
                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
                    throw new TypeError();
                }
            }, {
                key: 'onstatechange',
                get: function get() {
                    if ('onstatechange' in this._unpatchedAudioContext) {
                        return this._unpatchedAudioContext.onstatechange;
                    }
                    return this._onStateChangeListener;
                },
                set: function set(value) {
                    if ('onstatechange' in this._unpatchedAudioContext) {
                        this._unpatchedAudioContext.onstatechange = value;
                    } else {
                        this._onStateChangeListener = typeof value === 'function' ? value : null;
                    }
                }
            }, {
                key: 'sampleRate',
                get: function get() {
                    return this._unpatchedAudioContext.sampleRate;
                },
                set: function set(value) {
                    this._unpatchedAudioContext.sampleRate = value;
                    // If the unpatched AudioContext does not throw an error by itself, it has to be faked.
                    throw new TypeError();
                }
            }, {
                key: 'state',
                get: function get() {
                    return this._state !== null ? this._state : this._unpatchedAudioContext.state;
                },
                set: function set(value) {
                    if (this._unpatchedAudioContext.state !== undefined) {
                        this._unpatchedAudioContext.state = value;
                    }
                    // If the unpatched AudioContext does not have a property called state or does not throw an error by itself, it has to be
                    // tslint:disable-next-line:comment-format
                    // faked.
                    throw new TypeError();
                }
            }]);

            return AudioContext;
        }();

        return AudioContext;
    }
};

var _createClass$30 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$8 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$30(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$8(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
var CloseSupportTester = function () {
    function CloseSupportTester(_UnpatchedAudioContext) {
        _classCallCheck$30(this, CloseSupportTester);

        this._UnpatchedAudioContext = _UnpatchedAudioContext;
    }

    _createClass$30(CloseSupportTester, [{
        key: "test",
        value: function test() {
            if (this._UnpatchedAudioContext === null) {
                return false;
            }
            var audioContext = new this._UnpatchedAudioContext();
            var isAudioContextClosable = audioContext.close !== undefined;
            try {
                audioContext.close();
            } catch (err) {
                // Ignore errors.
            }
            return isAudioContextClosable;
        }
    }]);

    return CloseSupportTester;
}();
CloseSupportTester = __decorate$8([_angular_core.Injectable(), __param$8(0, _angular_core.Inject(unpatchedAudioContextConstructor))], CloseSupportTester);

var _createClass$31 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$9 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$31(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$9(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
/**
 * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers
 * did not refuse to decode invalid parameters with a TypeError.
 */
var DecodeAudioDataTypeErrorSupportTester = function () {
    function DecodeAudioDataTypeErrorSupportTester(_UnpatchedAudioContext) {
        _classCallCheck$31(this, DecodeAudioDataTypeErrorSupportTester);

        this._UnpatchedAudioContext = _UnpatchedAudioContext;
    }

    _createClass$31(DecodeAudioDataTypeErrorSupportTester, [{
        key: "test",
        value: function test() {
            if (this._UnpatchedAudioContext === null) {
                return Promise.resolve(false);
            }
            var audioContext = new this._UnpatchedAudioContext();
            // Bug #21: Safari does not support promises yet.
            // Bug #1: Chrome Canary & Safari requires a successCallback.
            return new Promise(function (resolve) {
                audioContext.decodeAudioData(null, function () {
                    // Ignore the success callback.
                }, function (err) {
                    audioContext.close().catch(function () {
                        // Ignore errors.
                    });
                    resolve(err instanceof TypeError);
                }).catch(function () {
                    // Ignore errors.
                });
            });
        }
    }]);

    return DecodeAudioDataTypeErrorSupportTester;
}();
DecodeAudioDataTypeErrorSupportTester = __decorate$9([_angular_core.Injectable(), __param$9(0, _angular_core.Inject(unpatchedAudioContextConstructor))], DecodeAudioDataTypeErrorSupportTester);

var _createClass$32 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof$10 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck$32(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$10(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param$10 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
        decorator(target, key, paramIndex);
    };
};
/**
 * Firefox up to version 44 had a bug which resulted in a misbehaving ChannelMergerNode. If one of
 * its channels would be unconnected the remaining channels were somehow upmixed to spread the
 * signal across all available channels.
 */
var MergingSupportTester = function () {
    function MergingSupportTester(_UnpatchedAudioContext) {
        _classCallCheck$32(this, MergingSupportTester);

        this._UnpatchedAudioContext = _UnpatchedAudioContext;
    }

    _createClass$32(MergingSupportTester, [{
        key: "test",
        value: function test() {
            if (this._UnpatchedAudioContext === null) {
                return Promise.resolve(false);
            }
            var audioContext = new this._UnpatchedAudioContext();
            var audioBufferSourceNode = audioContext.createBufferSource();
            var audioBuffer = audioContext.createBuffer(2, 2, audioContext.sampleRate);
            var channelMergerNode = audioContext.createChannelMerger(2);
            var scriptProcessorNode = audioContext.createScriptProcessor(256);
            return new Promise(function (resolve) {
                var startTime = void 0;
                // @todo Safari does not play/loop 1 sample buffers. This should be patched.
                audioBuffer.getChannelData(0)[0] = 1;
                audioBuffer.getChannelData(0)[1] = 1;
                audioBuffer.getChannelData(1)[0] = 1;
                audioBuffer.getChannelData(1)[1] = 1;
                audioBufferSourceNode.buffer = audioBuffer;
                audioBufferSourceNode.loop = true;
                scriptProcessorNode.onaudioprocess = function (event) {
                    var channelData = event.inputBuffer.getChannelData(1);
                    var length = channelData.length;
                    for (var i = 0; i < length; i += 1) {
                        if (channelData[i] !== 0) {
                            resolve(false);
                            return;
                        }
                    }
                    if (startTime + 1 / audioContext.sampleRate < event.playbackTime) {
                        resolve(true);
                    }
                };
                audioBufferSourceNode.connect(channelMergerNode, 0, 0);
                channelMergerNode.connect(scriptProcessorNode);
                scriptProcessorNode.connect(audioContext.destination);
                startTime = audioContext.currentTime;
                audioBufferSourceNode.start(startTime);
            }).then(function (result) {
                audioBufferSourceNode.stop();
                audioBufferSourceNode.disconnect();
                channelMergerNode.disconnect();
                scriptProcessorNode.disconnect();
                audioContext.close();
                return result;
            });
        }
    }]);

    return MergingSupportTester;
}();
MergingSupportTester = __decorate$10([_angular_core.Injectable(), __param$10(0, _angular_core.Inject(unpatchedAudioContextConstructor))], MergingSupportTester);

var _typeof$11 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * modernizr v3.5.0
 * Build https://modernizr.com/download?-promises-typedarrays-webaudio-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */
var modernizr = ((function (window, document, undefined) {
    var tests = [];
    /**
     *
     * ModernizrProto is the constructor for Modernizr
     *
     * @class
     * @access public
     */
    var ModernizrProto = {
        // The current version, dummy
        _version: '3.5.0',
        // Any settings that don't work as separate modules
        // can go in here as configuration.
        _config: {
            'classPrefix': '',
            'enableClasses': true,
            'enableJSClass': true,
            'usePrefixes': true
        },
        // Queue of tests
        _q: [],
        // Stub these for people who are listening
        on: function on(test, cb) {
            // I don't really think people should do this, but we can
            // safe guard it a bit.
            // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
            // This is in case people listen to synchronous tests. I would leave it out,
            // but the code to *disallow* sync tests in the real version of this
            // function is actually larger than this.
            var self = this;
            setTimeout(function () {
                cb(self[test]);
            }, 0);
        },
        addTest: function addTest(name, fn, options) {
            tests.push({ name: name, fn: fn, options: options });
        },
        addAsyncTest: function addAsyncTest(fn) {
            tests.push({ name: null, fn: fn });
        }
    };
    // Fake some of Object.create so we can force non test results to be non "own" properties.
    var Modernizr = function Modernizr() {};
    Modernizr.prototype = ModernizrProto;
    // Leak modernizr globally when you `require` it rather than force it here.
    // Overwrite name so constructor name is nicer :D
    Modernizr = new Modernizr();
    var classes = [];
    /**
     * is returns a boolean if the typeof an obj is exactly type.
     *
     * @access private
     * @function is
     * @param {*} obj - A thing we want to check the type of
     * @param {string} type - A string to compare the typeof against
     * @returns {boolean}
     */
    function is(obj, type) {
        return (typeof obj === 'undefined' ? 'undefined' : _typeof$11(obj)) === type;
    }
    
    /**
     * Run through all tests and detect their support in the current UA.
     *
     * @access private
     */
    function testRunner() {
        var featureNames;
        var feature;
        var aliasIdx;
        var result;
        var nameIdx;
        var featureName;
        var featureNameSplit;
        for (var featureIdx in tests) {
            if (tests.hasOwnProperty(featureIdx)) {
                featureNames = [];
                feature = tests[featureIdx];
                // run the test, throw the return value into the Modernizr,
                // then based on that boolean, define an appropriate className
                // and push it into an array of classes we'll join later.
                //
                // If there is no name, it's an 'async' test that is run,
                // but not directly added to the object. That should
                // be done with a post-run addTest call.
                if (feature.name) {
                    featureNames.push(feature.name.toLowerCase());
                    if (feature.options && feature.options.aliases && feature.options.aliases.length) {
                        // Add all the aliases into the names list
                        for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
                            featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
                        }
                    }
                }
                // Run the test, or use the raw value if it's not a function
                result = is(feature.fn, 'function') ? feature.fn() : feature.fn;
                // Set each of the names on the Modernizr object
                for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
                    featureName = featureNames[nameIdx];
                    // Support dot properties as sub tests. We don't do checking to make sure
                    // that the implied parent tests have been added. You must call them in
                    // order (either in the test, or make the parent test a dependency).
                    //
                    // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
                    // hashtag famous last words
                    featureNameSplit = featureName.split('.');
                    if (featureNameSplit.length === 1) {
                        Modernizr[featureNameSplit[0]] = result;
                    } else {
                        // cast to a Boolean, if not one already
                        if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
                            Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
                        }
                        Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
                    }
                    classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
                }
            }
        }
    }
    
    /*!
    {
      "name": "ES6 Promises",
      "property": "promises",
      "caniuse": "promises",
      "polyfills": ["es6promises"],
      "authors": ["Krister Kari", "Jake Archibald"],
      "tags": ["es6"],
      "notes": [{
        "name": "The ES6 promises spec",
        "href": "https://github.com/domenic/promises-unwrapping"
      },{
        "name": "Chromium dashboard - ES6 Promises",
        "href": "https://www.chromestatus.com/features/5681726336532480"
      },{
        "name": "JavaScript Promises: There and back again - HTML5 Rocks",
        "href": "http://www.html5rocks.com/en/tutorials/es6/promises/"
      }]
    }
    !*/
    /* DOC
    Check if browser implements ECMAScript 6 Promises per specification.
    */
    Modernizr.addTest('promises', function () {
        return 'Promise' in window &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        'resolve' in window.Promise && 'reject' in window.Promise && 'all' in window.Promise && 'race' in window.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        function () {
            var resolve;
            new window.Promise(function (r) {
                resolve = r;
            });
            return typeof resolve === 'function';
        }();
    });
    /*!
    {
      "name": "Typed arrays",
      "property": "typedarrays",
      "caniuse": "typedarrays",
      "tags": ["js"],
      "authors": ["Stanley Stuart (@fivetanley)"],
      "notes": [{
        "name": "MDN documentation",
        "href": "https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays"
      },{
        "name": "Kronos spec",
        "href": "https://www.khronos.org/registry/typedarray/specs/latest/"
      }],
      "polyfills": ["joshuabell-polyfill"]
    }
    !*/
    /* DOC
    Detects support for native binary data manipulation via Typed Arrays in JavaScript.
    
    Does not check for DataView support; use `Modernizr.dataview` for that.
    */
    // Should fail in:
    // Internet Explorer <= 9
    // Firefox <= 3.6
    // Chrome <= 6.0
    // iOS Safari < 4.2
    // Safari < 5.1
    // Opera < 11.6
    // Opera Mini, <= 7.0
    // Android Browser < 4.0
    // Blackberry Browser < 10.0
    Modernizr.addTest('typedarrays', 'ArrayBuffer' in window);
    /*!
    {
      "name": "Web Audio API",
      "property": "webaudio",
      "caniuse": "audio-api",
      "polyfills": ["xaudiojs", "dynamicaudiojs", "audiolibjs"],
      "tags": ["audio", "media"],
      "builderAliases": ["audio_webaudio_api"],
      "authors": ["Addy Osmani"],
      "notes": [{
        "name": "W3 Specification",
        "href": "https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html"
      }]
    }
    !*/
    /* DOC
    Detects the older non standard webaudio API, (as opposed to the standards based AudioContext API)
    */
    Modernizr.addTest('webaudio', function () {
        var prefixed = 'webkitAudioContext' in window;
        var unprefixed = 'AudioContext' in window;
        if (Modernizr._config.usePrefixes) {
            return prefixed || unprefixed;
        }
        return unprefixed;
    });
    // Run each test
    testRunner();
    delete ModernizrProto.addTest;
    delete ModernizrProto.addAsyncTest;
    // Run the things that are supposed to run after the tests
    for (var i = 0; i < Modernizr._q.length; i++) {
        Modernizr._q[i]();
    }
    // Leak Modernizr namespace
    return Modernizr;
    
}))(window, document);

var Modernizr = new _angular_core.OpaqueToken('MODERNIZR'); // tslint:disable-line:variable-name
// tslint:disable-line:variable-name
var MODERNIZR_PROVIDER = { provide: Modernizr, useValue: modernizr };

var _slicedToArray$5 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var IsSupportedPromise = new _angular_core.OpaqueToken('IS_SUPPORTED_PROMISE'); // tslint:disable-line:variable-name
// tslint:disable-line:variable-name
var IS_SUPPORTED_PROMISE_PROVIDER = {
    deps: [CloseSupportTester, DecodeAudioDataTypeErrorSupportTester, MergingSupportTester, Modernizr],
    provide: IsSupportedPromise,
    useFactory: function useFactory(closeSupportTester, decodeAudioDataTypeErrorSupportTester, mergingSupportTester, modernizr) {
        if (modernizr.promises && modernizr.typedarrays && modernizr.webaudio && closeSupportTester.test()) {
            return Promise.all([decodeAudioDataTypeErrorSupportTester.test(), mergingSupportTester.test()]).then(function (_ref) {
                var _ref2 = _slicedToArray$5(_ref, 2),
                    decodeAudioDataTypeErrorSupport = _ref2[0],
                    mergingSupport = _ref2[1];

                return decodeAudioDataTypeErrorSupport && mergingSupport;
            });
        }
        return Promise.resolve(false);
    }
};

var _createClass$33 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$33(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var offlineAudioContextConstructor = new _angular_core.OpaqueToken('OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR');
var OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER = {
    deps: [AudioBufferCopyChannelMethodsSupportTester, AudioBufferCopyChannelMethodsWrapper, AudioBufferWrapper, DataCloneErrorFactory, DetachedAudioBuffers, EncodingErrorFactory, IIRFilterNodeGetFrequencyResponseMethodWrapper, OfflineAudioBufferSourceNodeFakerFactory, OfflineAudioDestinationNodeFakerFactory, OfflineBiquadFilterNodeFakerFactory, OfflineGainNodeFakerFactory, OfflineIIRFilterNodeFakerFactory, PromiseSupportTester, unpatchedOfflineAudioContextConstructor],
    provide: offlineAudioContextConstructor,
    useFactory: function useFactory(audioBufferCopyChannelMethodsSupportTester, audioBufferCopyChannelMethodsWrapper, audioBufferWrapper, dataCloneErrorFactory, detachedAudioBuffers, encodingErrorFactory, iIRFilterNodeGetFrequencyResponseMethodWrapper, offlineAudioBufferSourceNodeFakerFactory, offlineAudioDestinationNodeFakerFactory, offlineBiquadFilterNodeFakerFactory, offlineGainNodeFakerFactory, offlineIIRFilterNodeFakerFactory, promiseSupportTester, UnpatchedOfflineAudioContext // tslint:disable-line:variable-name
    ) {
        var OfflineAudioContext = function () {
            function OfflineAudioContext(numberOfChannels, length, sampleRate) {
                _classCallCheck$33(this, OfflineAudioContext);

                var fakeNodeStore = new WeakMap();
                var unpatchedOfflineAudioContext = new UnpatchedOfflineAudioContext(numberOfChannels, length, sampleRate);
                this._destination = offlineAudioDestinationNodeFakerFactory.create({ fakeNodeStore: fakeNodeStore });
                this._fakeNodeStore = fakeNodeStore;
                this._isSupportingCopyChannelMethods = audioBufferCopyChannelMethodsSupportTester.test(unpatchedOfflineAudioContext);
                this._isSupportingGetFrequencyResponseErrors = false;
                this._isSupportingPromises = promiseSupportTester.test(unpatchedOfflineAudioContext);
                this._length = length;
                this._numberOfChannels = numberOfChannels;
                this._unpatchedOfflineAudioContext = unpatchedOfflineAudioContext;
            }

            _createClass$33(OfflineAudioContext, [{
                key: 'createBiquadFilter',
                value: function createBiquadFilter() {
                    return offlineBiquadFilterNodeFakerFactory.create({
                        fakeNodeStore: this._fakeNodeStore,
                        nativeNode: this._unpatchedOfflineAudioContext.createBiquadFilter()
                    }).proxy;
                }
            }, {
                key: 'createBuffer',
                value: function createBuffer(numberOfChannels, length, sampleRate) {
                    // @todo Consider browsers which do not fully support this method yet.
                    return this._unpatchedOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
                }
            }, {
                key: 'createBufferSource',
                value: function createBufferSource() {
                    return offlineAudioBufferSourceNodeFakerFactory.create({
                        fakeNodeStore: this._fakeNodeStore
                    }).proxy;
                }
            }, {
                key: 'createGain',
                value: function createGain() {
                    return offlineGainNodeFakerFactory.create({
                        fakeNodeStore: this._fakeNodeStore
                    }).proxy;
                }
            }, {
                key: 'createIIRFilter',
                value: function createIIRFilter(feedforward, feedback) {
                    var nativeNode = null;
                    // Bug #9: Safari does not support IIRFilterNodes.
                    if (this._unpatchedOfflineAudioContext.createIIRFilter !== undefined) {
                        nativeNode = this._unpatchedOfflineAudioContext.createIIRFilter(feedforward, feedback);
                        // Bug 23 & 24: FirefoxDeveloper does not throw NotSupportedErrors anymore.
                        if (!this._isSupportingGetFrequencyResponseErrors) {
                            iIRFilterNodeGetFrequencyResponseMethodWrapper.wrap(nativeNode);
                        }
                    }
                    return offlineIIRFilterNodeFakerFactory.create({
                        fakeNodeStore: this._fakeNodeStore,
                        feedback: feedback,
                        feedforward: feedforward,
                        length: this.length,
                        nativeNode: nativeNode,
                        numberOfChannels: this._numberOfChannels,
                        sampleRate: this._unpatchedOfflineAudioContext.sampleRate
                    }).proxy;
                }
            }, {
                key: 'decodeAudioData',
                value: function decodeAudioData(audioData, successCallback, errorCallback) {
                    var _this = this;

                    // Bug #43: Only Chrome Canary does yet throw a DataCloneError.
                    if (detachedAudioBuffers.has(audioData)) {
                        var err = dataCloneErrorFactory.create();
                        if (typeof errorCallback === 'function') {
                            errorCallback(err);
                        }
                        return Promise.reject(err);
                    }
                    // The audioData parameter maybe of a type which can't be added to a WeakSet.
                    try {
                        detachedAudioBuffers.add(audioData);
                    } catch (err) {}
                    // Ignore errors.

                    // Bug #21: Safari does not support promises yet.
                    if (this._isSupportingPromises) {
                        // Bug #1: Chrome requires a successCallback.
                        if (successCallback === undefined) {
                            successCallback = function successCallback() {}; // tslint:disable-line:no-empty
                        }
                        return this._unpatchedOfflineAudioContext.decodeAudioData(audioData, successCallback, function (err) {
                            if (typeof errorCallback === 'function') {
                                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                                if (err instanceof DOMException && err.name === 'NotSupportedError') {
                                    errorCallback(new TypeError());
                                } else {
                                    errorCallback(err);
                                }
                            }
                        }).catch(function (err) {
                            // Bug #6: Chrome, Firefox and Opera do not call the errorCallback in case of an invalid buffer.
                            if (typeof errorCallback === 'function' && err instanceof TypeError) {
                                errorCallback(err);
                            }
                            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
                            if (err instanceof DOMException && err.name === 'NotSupportedError') {
                                throw new TypeError();
                            }
                            throw err;
                        });
                    }
                    // Bug #21: Safari does not return a Promise yet.
                    return new Promise(function (resolve, reject) {
                        var fail = function fail(err) {
                            if (typeof errorCallback === 'function') {
                                errorCallback(err);
                            }
                            reject(err);
                        };
                        var succeed = function succeed(dBffrWrppr) {
                            resolve(dBffrWrppr);
                            if (typeof successCallback === 'function') {
                                successCallback(dBffrWrppr);
                            }
                        };
                        // Bug #26: Safari throws a synchronous error.
                        try {
                            // Bug #1: Safari requires a successCallback.
                            _this._unpatchedOfflineAudioContext.decodeAudioData(audioData, function (audioBuffer) {
                                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                                if (typeof audioBuffer.copyFromChannel !== 'function') {
                                    audioBufferWrapper.wrap(audioBuffer);
                                    // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                                } else if (!_this._isSupportingCopyChannelMethods) {
                                    audioBufferCopyChannelMethodsWrapper.wrap(audioBuffer);
                                }
                                succeed(audioBuffer);
                            }, function (err) {
                                // Bug #4: Safari returns null instead of an error.
                                if (err === null) {
                                    fail(encodingErrorFactory.create());
                                } else {
                                    fail(err);
                                }
                            });
                        } catch (err) {
                            fail(err);
                        }
                    });
                }
                // @todo public resume () {
                // @todo     return this._unpatchedOfflineAudioContext.resume();
                // @todo }

            }, {
                key: 'startRendering',
                value: function startRendering() {
                    var _this2 = this;

                    return this._destination.render(this._unpatchedOfflineAudioContext).then(function () {
                        // Bug #21: Safari does not support promises yet.
                        if (_this2._isSupportingPromises) {
                            return _this2._unpatchedOfflineAudioContext.startRendering();
                        }
                        return new Promise(function (resolve) {
                            _this2._unpatchedOfflineAudioContext.oncomplete = function (event) {
                                return resolve(event.renderedBuffer);
                            };
                            _this2._unpatchedOfflineAudioContext.startRendering();
                        });
                    });
                }
            }, {
                key: 'currentTime',
                get: function get() {
                    return this._unpatchedOfflineAudioContext.currentTime;
                }
            }, {
                key: 'destination',
                get: function get() {
                    return this._destination.proxy;
                }
            }, {
                key: 'length',
                get: function get() {
                    // Bug #17: Safari does not yet expose the length.
                    if (this._unpatchedOfflineAudioContext.length === undefined) {
                        return this._length;
                    }
                    return this._unpatchedOfflineAudioContext.length;
                }
            }, {
                key: 'sampleRate',
                get: function get() {
                    return this._unpatchedOfflineAudioContext.sampleRate;
                }
            }]);

            return OfflineAudioContext;
        }();

        return OfflineAudioContext;
    }
};

(function (AudioContextState) {
    AudioContextState[AudioContextState["closed"] = 0] = "closed";
    AudioContextState[AudioContextState["running"] = 1] = "running";
    AudioContextState[AudioContextState["suspended"] = 2] = "suspended";
})(exports.AudioContextState || (exports.AudioContextState = {}));

var injector = _angular_core.ReflectiveInjector.resolveAndCreate([AnalyserNodeGetFloatTimeDomainDataMethodWrapper, AnalyserNodeGetFloatTimeDomainDataSupportTester, AudioBufferCopyChannelMethodsSupportTester, AudioBufferCopyChannelMethodsWrapper, AudioBufferSourceNodeStopMethodWrapper, AudioBufferWrapper, AudioNodeConnectMethodWrapper, AudioNodeDisconnectMethodWrapper, AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, ChainingSupportTester, ChannelMergerNodeWrapper, ChannelSplitterNodeWrapper, CloseSupportTester, ConnectingSupportTester, DETACHED_AUDIO_BUFFERS_PROVIDER, DataCloneErrorFactory, DecodeAudioDataTypeErrorSupportTester, DisconnectingSupportTester, EncodingErrorFactory, IIRFilterNodeFaker, IIRFilterNodeGetFrequencyResponseMethodWrapper, IndexSizeErrorFactory, InvalidAccessErrorFactory, InvalidStateErrorFactory, IS_SUPPORTED_PROMISE_PROVIDER, MergingSupportTester, MODERNIZR_PROVIDER, NotSupportedErrorFactory, OfflineAudioBufferSourceNodeFakerFactory, OfflineAudioDestinationNodeFakerFactory, OfflineBiquadFilterNodeFakerFactory, OfflineGainNodeFakerFactory, OfflineIIRFilterNodeFakerFactory, OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, PromiseSupportTester, StopStoppedSupportTester, UNPATCHED_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, UNPATCHED_OFFLINE_AUDIO_CONTEXT_CONSTRUCTOR_PROVIDER, WINDOW_PROVIDER]);
// tslint:disable-next-line:variable-name
var AudioContext = injector.get(audioContextConstructor);
var isSupported = injector.get(IsSupportedPromise);
// tslint:disable-next-line:variable-name
var OfflineAudioContext = injector.get(offlineAudioContextConstructor);

exports.AudioContext = AudioContext;
exports.isSupported = isSupported;
exports.OfflineAudioContext = OfflineAudioContext;

Object.defineProperty(exports, '__esModule', { value: true });

})));
