(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('standardized-audio-context')) :
	typeof define === 'function' && define.amd ? define(['exports', 'standardized-audio-context'], factory) :
	(factory((global.webAudioBeatDetector = global.webAudioBeatDetector || {}),global.standardizedAudioContext));
}(this, (function (exports,standardizedAudioContext) { 'use strict';

var _this = undefined;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var INITIAL_THRESHOLD = 0.9;
var MINUMUM_NUMBER_OF_PEAKS = 30;
var MINIMUM_THRESHOLD = 0.3;
var countIntervalsBetweenNearbyPeaks = function countIntervalsBetweenNearbyPeaks(peaks) {
    var intervalBuckets = [];
    peaks.forEach(function (peak, index) {
        var length = Math.min(peaks.length - index, 10);

        var _loop = function _loop(i) {
            var interval = peaks[index + i] - peak;
            var foundInterval = intervalBuckets.some(function (intervalBucket) {
                if (intervalBucket.interval === interval) {
                    intervalBucket.peaks.push(peak);
                    return true;
                }
                return false;
            });
            if (!foundInterval) {
                intervalBuckets.push({
                    peaks: [peak],
                    interval: interval
                });
            }
        };

        for (var i = 1; i < length; i += 1) {
            _loop(i);
        }
    });
    return intervalBuckets;
};
var getPeaksAtThreshold = function getPeaksAtThreshold(channelData, threshold, sampleRate) {
    var peaks = [];
    var length = channelData.length;
    for (var i = 0; i < length; i += 1) {
        if (channelData[i] > threshold) {
            peaks.push(i);
            // Skip 0.25 seconds forward to get past this peak.
            i += sampleRate / 4 - 1;
        }
    }
    return peaks;
};
var groupNeighborsByTempo = function groupNeighborsByTempo(intervalBuckets, sampleRate) {
    var tempoBuckets = [];
    intervalBuckets.forEach(function (intervalBucket) {
        // Convert an interval to a tempo (aka BPM).
        var theoreticalTempo = 60 / (intervalBucket.interval / sampleRate);
        // Adjust the tempo to fit within the 90-180 BPM range.
        while (theoreticalTempo < 90) {
            theoreticalTempo *= 2;
        }
        while (theoreticalTempo > 180) {
            theoreticalTempo /= 2;
        }
        var foundTempo = tempoBuckets.some(function (tempoCount) {
            if (tempoCount.tempo === theoreticalTempo) {
                tempoCount.peaks = [].concat(_toConsumableArray(tempoCount.peaks), _toConsumableArray(intervalBucket.peaks));
                return true;
            }
            return false;
        });
        if (!foundTempo) {
            tempoBuckets.push({
                peaks: intervalBucket.peaks,
                tempo: theoreticalTempo
            });
        }
    });
    return tempoBuckets;
};
var computeTempoBuckets = function computeTempoBuckets(audioBuffer, offset, duration) {
    var offlineAudioContext = new standardizedAudioContext.OfflineAudioContext(audioBuffer.numberOfChannels, duration * audioBuffer.sampleRate, audioBuffer.sampleRate);
    var biquadFilter = offlineAudioContext.createBiquadFilter();
    var bufferSourceNode = offlineAudioContext.createBufferSource();
    biquadFilter.frequency.value = 200;
    biquadFilter.type = 'lowpass';
    bufferSourceNode.buffer = audioBuffer;
    bufferSourceNode.connect(biquadFilter).connect(offlineAudioContext.destination);
    bufferSourceNode.start(0, offset, duration);
    return offlineAudioContext.startRendering().then(function (renderedBuffer) {
        var peaks = [];
        var threshold = INITIAL_THRESHOLD;
        var channelData = new Float32Array(renderedBuffer.length);
        renderedBuffer.copyFromChannel(channelData, 0);
        while (peaks.length < MINUMUM_NUMBER_OF_PEAKS && threshold >= MINIMUM_THRESHOLD) {
            peaks = getPeaksAtThreshold(channelData, threshold, renderedBuffer.sampleRate);
            threshold -= 0.05;
        }
        var intervalBuckets = countIntervalsBetweenNearbyPeaks(peaks);
        var tempoBuckets = groupNeighborsByTempo(intervalBuckets, renderedBuffer.sampleRate);
        tempoBuckets.sort(function (a, b) {
            return b.peaks.length - a.peaks.length;
        });
        return tempoBuckets;
    });
};
var analyze = function analyze(audioBuffer) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : audioBuffer.duration - offset;
    return __awaiter(_this, void 0, void 0, regeneratorRuntime.mark(function _callee() {
        var tempoBuckets;
        return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _context.next = 2;
                        return computeTempoBuckets(audioBuffer, offset, duration);

                    case 2:
                        tempoBuckets = _context.sent;
                        return _context.abrupt('return', tempoBuckets[0].tempo);

                    case 4:
                    case 'end':
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));
};
var guess = function guess(audioBuffer) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : audioBuffer.duration - offset;
    return __awaiter(_this, void 0, void 0, regeneratorRuntime.mark(function _callee2() {
        var tempoBuckets, _tempoBuckets$, peaks, tempo, bpm, secondsPerBeat;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        _context2.next = 2;
                        return computeTempoBuckets(audioBuffer, offset, duration);

                    case 2:
                        tempoBuckets = _context2.sent;
                        _tempoBuckets$ = tempoBuckets[0], peaks = _tempoBuckets$.peaks, tempo = _tempoBuckets$.tempo;
                        bpm = Math.round(tempo);
                        secondsPerBeat = 60 / bpm;

                        peaks.sort(function (a, b) {
                            return a - b;
                        });
                        offset = peaks[0] / audioBuffer.sampleRate;
                        while (offset > secondsPerBeat) {
                            offset -= secondsPerBeat;
                        }
                        return _context2.abrupt('return', {
                            bpm: bpm,
                            offset: offset
                        });

                    case 10:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, _callee2, this);
    }));
};

exports.analyze = analyze;
exports.guess = guess;
exports.isSupported = standardizedAudioContext.isSupported;

Object.defineProperty(exports, '__esModule', { value: true });

})));
